// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha2

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v3/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// BackendTLSPolicy provides a way to configure how a Gateway connects to a Backend via TLS.
type BackendTLSPolicyType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of BackendTLSPolicy.
	Spec BackendTLSPolicySpec `pulumi:"spec"`
	// Status defines the current state of BackendTLSPolicy.
	Status *BackendTLSPolicyStatus `pulumi:"status"`
}

type BackendTLSPolicyMetadata struct {
}

// Spec defines the desired state of BackendTLSPolicy.
type BackendTLSPolicySpec struct {
	// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	TargetRef BackendTLSPolicySpecTargetRef `pulumi:"targetRef"`
	// TLS contains backend TLS policy configuration.
	Tls BackendTLSPolicySpecTls `pulumi:"tls"`
}

// BackendTLSPolicySpecInput is an input type that accepts BackendTLSPolicySpecArgs and BackendTLSPolicySpecOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecInput` via:
//
//	BackendTLSPolicySpecArgs{...}
type BackendTLSPolicySpecInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecOutput() BackendTLSPolicySpecOutput
	ToBackendTLSPolicySpecOutputWithContext(context.Context) BackendTLSPolicySpecOutput
}

// Spec defines the desired state of BackendTLSPolicy.
type BackendTLSPolicySpecArgs struct {
	// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	TargetRef BackendTLSPolicySpecTargetRefInput `pulumi:"targetRef"`
	// TLS contains backend TLS policy configuration.
	Tls BackendTLSPolicySpecTlsInput `pulumi:"tls"`
}

func (BackendTLSPolicySpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpec)(nil)).Elem()
}

func (i BackendTLSPolicySpecArgs) ToBackendTLSPolicySpecOutput() BackendTLSPolicySpecOutput {
	return i.ToBackendTLSPolicySpecOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecArgs) ToBackendTLSPolicySpecOutputWithContext(ctx context.Context) BackendTLSPolicySpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecOutput)
}

func (i BackendTLSPolicySpecArgs) ToBackendTLSPolicySpecPtrOutput() BackendTLSPolicySpecPtrOutput {
	return i.ToBackendTLSPolicySpecPtrOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecArgs) ToBackendTLSPolicySpecPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecOutput).ToBackendTLSPolicySpecPtrOutputWithContext(ctx)
}

// BackendTLSPolicySpecPtrInput is an input type that accepts BackendTLSPolicySpecArgs, BackendTLSPolicySpecPtr and BackendTLSPolicySpecPtrOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecPtrInput` via:
//
//	        BackendTLSPolicySpecArgs{...}
//
//	or:
//
//	        nil
type BackendTLSPolicySpecPtrInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecPtrOutput() BackendTLSPolicySpecPtrOutput
	ToBackendTLSPolicySpecPtrOutputWithContext(context.Context) BackendTLSPolicySpecPtrOutput
}

type backendTLSPolicySpecPtrType BackendTLSPolicySpecArgs

func BackendTLSPolicySpecPtr(v *BackendTLSPolicySpecArgs) BackendTLSPolicySpecPtrInput {
	return (*backendTLSPolicySpecPtrType)(v)
}

func (*backendTLSPolicySpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpec)(nil)).Elem()
}

func (i *backendTLSPolicySpecPtrType) ToBackendTLSPolicySpecPtrOutput() BackendTLSPolicySpecPtrOutput {
	return i.ToBackendTLSPolicySpecPtrOutputWithContext(context.Background())
}

func (i *backendTLSPolicySpecPtrType) ToBackendTLSPolicySpecPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecPtrOutput)
}

// Spec defines the desired state of BackendTLSPolicy.
type BackendTLSPolicySpecOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpec)(nil)).Elem()
}

func (o BackendTLSPolicySpecOutput) ToBackendTLSPolicySpecOutput() BackendTLSPolicySpecOutput {
	return o
}

func (o BackendTLSPolicySpecOutput) ToBackendTLSPolicySpecOutputWithContext(ctx context.Context) BackendTLSPolicySpecOutput {
	return o
}

func (o BackendTLSPolicySpecOutput) ToBackendTLSPolicySpecPtrOutput() BackendTLSPolicySpecPtrOutput {
	return o.ToBackendTLSPolicySpecPtrOutputWithContext(context.Background())
}

func (o BackendTLSPolicySpecOutput) ToBackendTLSPolicySpecPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BackendTLSPolicySpec) *BackendTLSPolicySpec {
		return &v
	}).(BackendTLSPolicySpecPtrOutput)
}

// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
//
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o BackendTLSPolicySpecOutput) TargetRef() BackendTLSPolicySpecTargetRefOutput {
	return o.ApplyT(func(v BackendTLSPolicySpec) BackendTLSPolicySpecTargetRef { return v.TargetRef }).(BackendTLSPolicySpecTargetRefOutput)
}

// TLS contains backend TLS policy configuration.
func (o BackendTLSPolicySpecOutput) Tls() BackendTLSPolicySpecTlsOutput {
	return o.ApplyT(func(v BackendTLSPolicySpec) BackendTLSPolicySpecTls { return v.Tls }).(BackendTLSPolicySpecTlsOutput)
}

type BackendTLSPolicySpecPtrOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpec)(nil)).Elem()
}

func (o BackendTLSPolicySpecPtrOutput) ToBackendTLSPolicySpecPtrOutput() BackendTLSPolicySpecPtrOutput {
	return o
}

func (o BackendTLSPolicySpecPtrOutput) ToBackendTLSPolicySpecPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecPtrOutput {
	return o
}

func (o BackendTLSPolicySpecPtrOutput) Elem() BackendTLSPolicySpecOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpec) BackendTLSPolicySpec {
		if v != nil {
			return *v
		}
		var ret BackendTLSPolicySpec
		return ret
	}).(BackendTLSPolicySpecOutput)
}

// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
//
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o BackendTLSPolicySpecPtrOutput) TargetRef() BackendTLSPolicySpecTargetRefPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpec) *BackendTLSPolicySpecTargetRef {
		if v == nil {
			return nil
		}
		return &v.TargetRef
	}).(BackendTLSPolicySpecTargetRefPtrOutput)
}

// TLS contains backend TLS policy configuration.
func (o BackendTLSPolicySpecPtrOutput) Tls() BackendTLSPolicySpecTlsPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpec) *BackendTLSPolicySpecTls {
		if v == nil {
			return nil
		}
		return &v.Tls
	}).(BackendTLSPolicySpecTlsPtrOutput)
}

// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
//
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type BackendTLSPolicySpecTargetRef struct {
	// Group is the group of the target resource.
	Group string `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind string `pulumi:"kind"`
	// Name is the name of the target resource.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
	Namespace *string `pulumi:"namespace"`
	// SectionName is the name of a section within the target resource. When unspecified, this targetRef targets the entire resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name * Service: Port Name
	//     If a SectionName is specified, but does not exist on the targeted object, the Policy must fail to attach, and the policy implementation should record a `ResolvedRefs` or similar Condition in the Policy's status.
	SectionName *string `pulumi:"sectionName"`
}

// BackendTLSPolicySpecTargetRefInput is an input type that accepts BackendTLSPolicySpecTargetRefArgs and BackendTLSPolicySpecTargetRefOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTargetRefInput` via:
//
//	BackendTLSPolicySpecTargetRefArgs{...}
type BackendTLSPolicySpecTargetRefInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTargetRefOutput() BackendTLSPolicySpecTargetRefOutput
	ToBackendTLSPolicySpecTargetRefOutputWithContext(context.Context) BackendTLSPolicySpecTargetRefOutput
}

// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
//
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type BackendTLSPolicySpecTargetRefArgs struct {
	// Group is the group of the target resource.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the target resource.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// SectionName is the name of a section within the target resource. When unspecified, this targetRef targets the entire resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name * Service: Port Name
	//     If a SectionName is specified, but does not exist on the targeted object, the Policy must fail to attach, and the policy implementation should record a `ResolvedRefs` or similar Condition in the Policy's status.
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (BackendTLSPolicySpecTargetRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTargetRef)(nil)).Elem()
}

func (i BackendTLSPolicySpecTargetRefArgs) ToBackendTLSPolicySpecTargetRefOutput() BackendTLSPolicySpecTargetRefOutput {
	return i.ToBackendTLSPolicySpecTargetRefOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTargetRefArgs) ToBackendTLSPolicySpecTargetRefOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTargetRefOutput)
}

func (i BackendTLSPolicySpecTargetRefArgs) ToBackendTLSPolicySpecTargetRefPtrOutput() BackendTLSPolicySpecTargetRefPtrOutput {
	return i.ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTargetRefArgs) ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTargetRefOutput).ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(ctx)
}

// BackendTLSPolicySpecTargetRefPtrInput is an input type that accepts BackendTLSPolicySpecTargetRefArgs, BackendTLSPolicySpecTargetRefPtr and BackendTLSPolicySpecTargetRefPtrOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTargetRefPtrInput` via:
//
//	        BackendTLSPolicySpecTargetRefArgs{...}
//
//	or:
//
//	        nil
type BackendTLSPolicySpecTargetRefPtrInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTargetRefPtrOutput() BackendTLSPolicySpecTargetRefPtrOutput
	ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(context.Context) BackendTLSPolicySpecTargetRefPtrOutput
}

type backendTLSPolicySpecTargetRefPtrType BackendTLSPolicySpecTargetRefArgs

func BackendTLSPolicySpecTargetRefPtr(v *BackendTLSPolicySpecTargetRefArgs) BackendTLSPolicySpecTargetRefPtrInput {
	return (*backendTLSPolicySpecTargetRefPtrType)(v)
}

func (*backendTLSPolicySpecTargetRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpecTargetRef)(nil)).Elem()
}

func (i *backendTLSPolicySpecTargetRefPtrType) ToBackendTLSPolicySpecTargetRefPtrOutput() BackendTLSPolicySpecTargetRefPtrOutput {
	return i.ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(context.Background())
}

func (i *backendTLSPolicySpecTargetRefPtrType) ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTargetRefPtrOutput)
}

// TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy.
//
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type BackendTLSPolicySpecTargetRefOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTargetRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTargetRef)(nil)).Elem()
}

func (o BackendTLSPolicySpecTargetRefOutput) ToBackendTLSPolicySpecTargetRefOutput() BackendTLSPolicySpecTargetRefOutput {
	return o
}

func (o BackendTLSPolicySpecTargetRefOutput) ToBackendTLSPolicySpecTargetRefOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefOutput {
	return o
}

func (o BackendTLSPolicySpecTargetRefOutput) ToBackendTLSPolicySpecTargetRefPtrOutput() BackendTLSPolicySpecTargetRefPtrOutput {
	return o.ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(context.Background())
}

func (o BackendTLSPolicySpecTargetRefOutput) ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BackendTLSPolicySpecTargetRef) *BackendTLSPolicySpecTargetRef {
		return &v
	}).(BackendTLSPolicySpecTargetRefPtrOutput)
}

// Group is the group of the target resource.
func (o BackendTLSPolicySpecTargetRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTargetRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the target resource.
func (o BackendTLSPolicySpecTargetRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTargetRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the target resource.
func (o BackendTLSPolicySpecTargetRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTargetRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
func (o BackendTLSPolicySpecTargetRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTargetRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// SectionName is the name of a section within the target resource. When unspecified, this targetRef targets the entire resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name * Service: Port Name
//     If a SectionName is specified, but does not exist on the targeted object, the Policy must fail to attach, and the policy implementation should record a `ResolvedRefs` or similar Condition in the Policy's status.
func (o BackendTLSPolicySpecTargetRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTargetRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type BackendTLSPolicySpecTargetRefPtrOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTargetRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpecTargetRef)(nil)).Elem()
}

func (o BackendTLSPolicySpecTargetRefPtrOutput) ToBackendTLSPolicySpecTargetRefPtrOutput() BackendTLSPolicySpecTargetRefPtrOutput {
	return o
}

func (o BackendTLSPolicySpecTargetRefPtrOutput) ToBackendTLSPolicySpecTargetRefPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTargetRefPtrOutput {
	return o
}

func (o BackendTLSPolicySpecTargetRefPtrOutput) Elem() BackendTLSPolicySpecTargetRefOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) BackendTLSPolicySpecTargetRef {
		if v != nil {
			return *v
		}
		var ret BackendTLSPolicySpecTargetRef
		return ret
	}).(BackendTLSPolicySpecTargetRefOutput)
}

// Group is the group of the target resource.
func (o BackendTLSPolicySpecTargetRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the target resource.
func (o BackendTLSPolicySpecTargetRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the target resource.
func (o BackendTLSPolicySpecTargetRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
func (o BackendTLSPolicySpecTargetRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// SectionName is the name of a section within the target resource. When unspecified, this targetRef targets the entire resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name * Service: Port Name
//     If a SectionName is specified, but does not exist on the targeted object, the Policy must fail to attach, and the policy implementation should record a `ResolvedRefs` or similar Condition in the Policy's status.
func (o BackendTLSPolicySpecTargetRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTargetRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// TLS contains backend TLS policy configuration.
type BackendTLSPolicySpecTls struct {
	// CACertRefs contains one or more references to Kubernetes objects that contain a PEM-encoded TLS CA certificate bundle, which is used to validate a TLS handshake between the Gateway and backend Pod.
	//  If CACertRefs is empty or unspecified, then WellKnownCACerts must be specified. Only one of CACertRefs or WellKnownCACerts may be specified, not both. If CACertRefs is empty or unspecified, the configuration for WellKnownCACerts MUST be honored instead.
	//  References to a resource in a different namespace are invalid for the moment, although we will revisit this in the future.
	//  A single CACertRef to a Kubernetes ConfigMap kind has "Core" support. Implementations MAY choose to support attaching multiple certificates to a backend, but this behavior is implementation-specific.
	//  Support: Core - An optional single reference to a Kubernetes ConfigMap, with the CA certificate in a key named `ca.crt`.
	//  Support: Implementation-specific (More than one reference, or other kinds of resources).
	CaCertRefs []BackendTLSPolicySpecTlsCaCertRefs `pulumi:"caCertRefs"`
	// Hostname is used for two purposes in the connection between Gateways and backends:
	//  1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066). 2. Hostname MUST be used for authentication and MUST match the certificate served by the matching backend.
	//      Support: Core
	Hostname string `pulumi:"hostname"`
	// WellKnownCACerts specifies whether system CA certificates may be used in the TLS handshake between the gateway and backend pod.
	//  If WellKnownCACerts is unspecified or empty (""), then CACertRefs must be specified with at least one entry for a valid configuration. Only one of CACertRefs or WellKnownCACerts may be specified, not both.
	//  Support: Core for "System"
	WellKnownCACerts *string `pulumi:"wellKnownCACerts"`
}

// BackendTLSPolicySpecTlsInput is an input type that accepts BackendTLSPolicySpecTlsArgs and BackendTLSPolicySpecTlsOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTlsInput` via:
//
//	BackendTLSPolicySpecTlsArgs{...}
type BackendTLSPolicySpecTlsInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTlsOutput() BackendTLSPolicySpecTlsOutput
	ToBackendTLSPolicySpecTlsOutputWithContext(context.Context) BackendTLSPolicySpecTlsOutput
}

// TLS contains backend TLS policy configuration.
type BackendTLSPolicySpecTlsArgs struct {
	// CACertRefs contains one or more references to Kubernetes objects that contain a PEM-encoded TLS CA certificate bundle, which is used to validate a TLS handshake between the Gateway and backend Pod.
	//  If CACertRefs is empty or unspecified, then WellKnownCACerts must be specified. Only one of CACertRefs or WellKnownCACerts may be specified, not both. If CACertRefs is empty or unspecified, the configuration for WellKnownCACerts MUST be honored instead.
	//  References to a resource in a different namespace are invalid for the moment, although we will revisit this in the future.
	//  A single CACertRef to a Kubernetes ConfigMap kind has "Core" support. Implementations MAY choose to support attaching multiple certificates to a backend, but this behavior is implementation-specific.
	//  Support: Core - An optional single reference to a Kubernetes ConfigMap, with the CA certificate in a key named `ca.crt`.
	//  Support: Implementation-specific (More than one reference, or other kinds of resources).
	CaCertRefs BackendTLSPolicySpecTlsCaCertRefsArrayInput `pulumi:"caCertRefs"`
	// Hostname is used for two purposes in the connection between Gateways and backends:
	//  1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066). 2. Hostname MUST be used for authentication and MUST match the certificate served by the matching backend.
	//      Support: Core
	Hostname pulumi.StringInput `pulumi:"hostname"`
	// WellKnownCACerts specifies whether system CA certificates may be used in the TLS handshake between the gateway and backend pod.
	//  If WellKnownCACerts is unspecified or empty (""), then CACertRefs must be specified with at least one entry for a valid configuration. Only one of CACertRefs or WellKnownCACerts may be specified, not both.
	//  Support: Core for "System"
	WellKnownCACerts pulumi.StringPtrInput `pulumi:"wellKnownCACerts"`
}

func (BackendTLSPolicySpecTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTls)(nil)).Elem()
}

func (i BackendTLSPolicySpecTlsArgs) ToBackendTLSPolicySpecTlsOutput() BackendTLSPolicySpecTlsOutput {
	return i.ToBackendTLSPolicySpecTlsOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTlsArgs) ToBackendTLSPolicySpecTlsOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTlsOutput)
}

func (i BackendTLSPolicySpecTlsArgs) ToBackendTLSPolicySpecTlsPtrOutput() BackendTLSPolicySpecTlsPtrOutput {
	return i.ToBackendTLSPolicySpecTlsPtrOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTlsArgs) ToBackendTLSPolicySpecTlsPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTlsOutput).ToBackendTLSPolicySpecTlsPtrOutputWithContext(ctx)
}

// BackendTLSPolicySpecTlsPtrInput is an input type that accepts BackendTLSPolicySpecTlsArgs, BackendTLSPolicySpecTlsPtr and BackendTLSPolicySpecTlsPtrOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTlsPtrInput` via:
//
//	        BackendTLSPolicySpecTlsArgs{...}
//
//	or:
//
//	        nil
type BackendTLSPolicySpecTlsPtrInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTlsPtrOutput() BackendTLSPolicySpecTlsPtrOutput
	ToBackendTLSPolicySpecTlsPtrOutputWithContext(context.Context) BackendTLSPolicySpecTlsPtrOutput
}

type backendTLSPolicySpecTlsPtrType BackendTLSPolicySpecTlsArgs

func BackendTLSPolicySpecTlsPtr(v *BackendTLSPolicySpecTlsArgs) BackendTLSPolicySpecTlsPtrInput {
	return (*backendTLSPolicySpecTlsPtrType)(v)
}

func (*backendTLSPolicySpecTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpecTls)(nil)).Elem()
}

func (i *backendTLSPolicySpecTlsPtrType) ToBackendTLSPolicySpecTlsPtrOutput() BackendTLSPolicySpecTlsPtrOutput {
	return i.ToBackendTLSPolicySpecTlsPtrOutputWithContext(context.Background())
}

func (i *backendTLSPolicySpecTlsPtrType) ToBackendTLSPolicySpecTlsPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTlsPtrOutput)
}

// TLS contains backend TLS policy configuration.
type BackendTLSPolicySpecTlsOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTls)(nil)).Elem()
}

func (o BackendTLSPolicySpecTlsOutput) ToBackendTLSPolicySpecTlsOutput() BackendTLSPolicySpecTlsOutput {
	return o
}

func (o BackendTLSPolicySpecTlsOutput) ToBackendTLSPolicySpecTlsOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsOutput {
	return o
}

func (o BackendTLSPolicySpecTlsOutput) ToBackendTLSPolicySpecTlsPtrOutput() BackendTLSPolicySpecTlsPtrOutput {
	return o.ToBackendTLSPolicySpecTlsPtrOutputWithContext(context.Background())
}

func (o BackendTLSPolicySpecTlsOutput) ToBackendTLSPolicySpecTlsPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BackendTLSPolicySpecTls) *BackendTLSPolicySpecTls {
		return &v
	}).(BackendTLSPolicySpecTlsPtrOutput)
}

// CACertRefs contains one or more references to Kubernetes objects that contain a PEM-encoded TLS CA certificate bundle, which is used to validate a TLS handshake between the Gateway and backend Pod.
//
//	If CACertRefs is empty or unspecified, then WellKnownCACerts must be specified. Only one of CACertRefs or WellKnownCACerts may be specified, not both. If CACertRefs is empty or unspecified, the configuration for WellKnownCACerts MUST be honored instead.
//	References to a resource in a different namespace are invalid for the moment, although we will revisit this in the future.
//	A single CACertRef to a Kubernetes ConfigMap kind has "Core" support. Implementations MAY choose to support attaching multiple certificates to a backend, but this behavior is implementation-specific.
//	Support: Core - An optional single reference to a Kubernetes ConfigMap, with the CA certificate in a key named `ca.crt`.
//	Support: Implementation-specific (More than one reference, or other kinds of resources).
func (o BackendTLSPolicySpecTlsOutput) CaCertRefs() BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTls) []BackendTLSPolicySpecTlsCaCertRefs { return v.CaCertRefs }).(BackendTLSPolicySpecTlsCaCertRefsArrayOutput)
}

// Hostname is used for two purposes in the connection between Gateways and backends:
//  1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066). 2. Hostname MUST be used for authentication and MUST match the certificate served by the matching backend.
//     Support: Core
func (o BackendTLSPolicySpecTlsOutput) Hostname() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTls) string { return v.Hostname }).(pulumi.StringOutput)
}

// WellKnownCACerts specifies whether system CA certificates may be used in the TLS handshake between the gateway and backend pod.
//
//	If WellKnownCACerts is unspecified or empty (""), then CACertRefs must be specified with at least one entry for a valid configuration. Only one of CACertRefs or WellKnownCACerts may be specified, not both.
//	Support: Core for "System"
func (o BackendTLSPolicySpecTlsOutput) WellKnownCACerts() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTls) *string { return v.WellKnownCACerts }).(pulumi.StringPtrOutput)
}

type BackendTLSPolicySpecTlsPtrOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicySpecTls)(nil)).Elem()
}

func (o BackendTLSPolicySpecTlsPtrOutput) ToBackendTLSPolicySpecTlsPtrOutput() BackendTLSPolicySpecTlsPtrOutput {
	return o
}

func (o BackendTLSPolicySpecTlsPtrOutput) ToBackendTLSPolicySpecTlsPtrOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsPtrOutput {
	return o
}

func (o BackendTLSPolicySpecTlsPtrOutput) Elem() BackendTLSPolicySpecTlsOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTls) BackendTLSPolicySpecTls {
		if v != nil {
			return *v
		}
		var ret BackendTLSPolicySpecTls
		return ret
	}).(BackendTLSPolicySpecTlsOutput)
}

// CACertRefs contains one or more references to Kubernetes objects that contain a PEM-encoded TLS CA certificate bundle, which is used to validate a TLS handshake between the Gateway and backend Pod.
//
//	If CACertRefs is empty or unspecified, then WellKnownCACerts must be specified. Only one of CACertRefs or WellKnownCACerts may be specified, not both. If CACertRefs is empty or unspecified, the configuration for WellKnownCACerts MUST be honored instead.
//	References to a resource in a different namespace are invalid for the moment, although we will revisit this in the future.
//	A single CACertRef to a Kubernetes ConfigMap kind has "Core" support. Implementations MAY choose to support attaching multiple certificates to a backend, but this behavior is implementation-specific.
//	Support: Core - An optional single reference to a Kubernetes ConfigMap, with the CA certificate in a key named `ca.crt`.
//	Support: Implementation-specific (More than one reference, or other kinds of resources).
func (o BackendTLSPolicySpecTlsPtrOutput) CaCertRefs() BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTls) []BackendTLSPolicySpecTlsCaCertRefs {
		if v == nil {
			return nil
		}
		return v.CaCertRefs
	}).(BackendTLSPolicySpecTlsCaCertRefsArrayOutput)
}

// Hostname is used for two purposes in the connection between Gateways and backends:
//  1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066). 2. Hostname MUST be used for authentication and MUST match the certificate served by the matching backend.
//     Support: Core
func (o BackendTLSPolicySpecTlsPtrOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTls) *string {
		if v == nil {
			return nil
		}
		return &v.Hostname
	}).(pulumi.StringPtrOutput)
}

// WellKnownCACerts specifies whether system CA certificates may be used in the TLS handshake between the gateway and backend pod.
//
//	If WellKnownCACerts is unspecified or empty (""), then CACertRefs must be specified with at least one entry for a valid configuration. Only one of CACertRefs or WellKnownCACerts may be specified, not both.
//	Support: Core for "System"
func (o BackendTLSPolicySpecTlsPtrOutput) WellKnownCACerts() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BackendTLSPolicySpecTls) *string {
		if v == nil {
			return nil
		}
		return v.WellKnownCACerts
	}).(pulumi.StringPtrOutput)
}

// LocalObjectReference identifies an API object within the namespace of the referrer. The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
//
//	References to objects with invalid Group and Kind are not valid, and must be rejected by the implementation, with appropriate Conditions set on the containing object.
type BackendTLSPolicySpecTlsCaCertRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// BackendTLSPolicySpecTlsCaCertRefsInput is an input type that accepts BackendTLSPolicySpecTlsCaCertRefsArgs and BackendTLSPolicySpecTlsCaCertRefsOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTlsCaCertRefsInput` via:
//
//	BackendTLSPolicySpecTlsCaCertRefsArgs{...}
type BackendTLSPolicySpecTlsCaCertRefsInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTlsCaCertRefsOutput() BackendTLSPolicySpecTlsCaCertRefsOutput
	ToBackendTLSPolicySpecTlsCaCertRefsOutputWithContext(context.Context) BackendTLSPolicySpecTlsCaCertRefsOutput
}

// LocalObjectReference identifies an API object within the namespace of the referrer. The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
//
//	References to objects with invalid Group and Kind are not valid, and must be rejected by the implementation, with appropriate Conditions set on the containing object.
type BackendTLSPolicySpecTlsCaCertRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (BackendTLSPolicySpecTlsCaCertRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTlsCaCertRefs)(nil)).Elem()
}

func (i BackendTLSPolicySpecTlsCaCertRefsArgs) ToBackendTLSPolicySpecTlsCaCertRefsOutput() BackendTLSPolicySpecTlsCaCertRefsOutput {
	return i.ToBackendTLSPolicySpecTlsCaCertRefsOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTlsCaCertRefsArgs) ToBackendTLSPolicySpecTlsCaCertRefsOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsCaCertRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTlsCaCertRefsOutput)
}

// BackendTLSPolicySpecTlsCaCertRefsArrayInput is an input type that accepts BackendTLSPolicySpecTlsCaCertRefsArray and BackendTLSPolicySpecTlsCaCertRefsArrayOutput values.
// You can construct a concrete instance of `BackendTLSPolicySpecTlsCaCertRefsArrayInput` via:
//
//	BackendTLSPolicySpecTlsCaCertRefsArray{ BackendTLSPolicySpecTlsCaCertRefsArgs{...} }
type BackendTLSPolicySpecTlsCaCertRefsArrayInput interface {
	pulumi.Input

	ToBackendTLSPolicySpecTlsCaCertRefsArrayOutput() BackendTLSPolicySpecTlsCaCertRefsArrayOutput
	ToBackendTLSPolicySpecTlsCaCertRefsArrayOutputWithContext(context.Context) BackendTLSPolicySpecTlsCaCertRefsArrayOutput
}

type BackendTLSPolicySpecTlsCaCertRefsArray []BackendTLSPolicySpecTlsCaCertRefsInput

func (BackendTLSPolicySpecTlsCaCertRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicySpecTlsCaCertRefs)(nil)).Elem()
}

func (i BackendTLSPolicySpecTlsCaCertRefsArray) ToBackendTLSPolicySpecTlsCaCertRefsArrayOutput() BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return i.ToBackendTLSPolicySpecTlsCaCertRefsArrayOutputWithContext(context.Background())
}

func (i BackendTLSPolicySpecTlsCaCertRefsArray) ToBackendTLSPolicySpecTlsCaCertRefsArrayOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicySpecTlsCaCertRefsArrayOutput)
}

// LocalObjectReference identifies an API object within the namespace of the referrer. The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
//
//	References to objects with invalid Group and Kind are not valid, and must be rejected by the implementation, with appropriate Conditions set on the containing object.
type BackendTLSPolicySpecTlsCaCertRefsOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTlsCaCertRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicySpecTlsCaCertRefs)(nil)).Elem()
}

func (o BackendTLSPolicySpecTlsCaCertRefsOutput) ToBackendTLSPolicySpecTlsCaCertRefsOutput() BackendTLSPolicySpecTlsCaCertRefsOutput {
	return o
}

func (o BackendTLSPolicySpecTlsCaCertRefsOutput) ToBackendTLSPolicySpecTlsCaCertRefsOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsCaCertRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o BackendTLSPolicySpecTlsCaCertRefsOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTlsCaCertRefs) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o BackendTLSPolicySpecTlsCaCertRefsOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTlsCaCertRefs) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o BackendTLSPolicySpecTlsCaCertRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicySpecTlsCaCertRefs) string { return v.Name }).(pulumi.StringOutput)
}

type BackendTLSPolicySpecTlsCaCertRefsArrayOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicySpecTlsCaCertRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicySpecTlsCaCertRefs)(nil)).Elem()
}

func (o BackendTLSPolicySpecTlsCaCertRefsArrayOutput) ToBackendTLSPolicySpecTlsCaCertRefsArrayOutput() BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return o
}

func (o BackendTLSPolicySpecTlsCaCertRefsArrayOutput) ToBackendTLSPolicySpecTlsCaCertRefsArrayOutputWithContext(ctx context.Context) BackendTLSPolicySpecTlsCaCertRefsArrayOutput {
	return o
}

func (o BackendTLSPolicySpecTlsCaCertRefsArrayOutput) Index(i pulumi.IntInput) BackendTLSPolicySpecTlsCaCertRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BackendTLSPolicySpecTlsCaCertRefs {
		return vs[0].([]BackendTLSPolicySpecTlsCaCertRefs)[vs[1].(int)]
	}).(BackendTLSPolicySpecTlsCaCertRefsOutput)
}

// Status defines the current state of BackendTLSPolicy.
type BackendTLSPolicyStatus struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are associated with the policy, and the status of the policy with respect to each ancestor. When this policy attaches to a parent, the controller that manages the parent and the ancestors MUST add an entry to this list when the controller first sees the policy and SHOULD update the entry as appropriate when the relevant ancestor is modified.
	//  Note that choosing the relevant ancestor is left to the Policy designers; an important part of Policy design is designing the right object level at which to namespace this status.
	//  Note also that implementations MUST ONLY populate ancestor status for the Ancestor resources they are responsible for. Implementations MUST use the ControllerName field to uniquely identify the entries in this list that they are responsible for.
	//  Note that to achieve this, the list of PolicyAncestorStatus structs MUST be treated as a map with a composite key, made up of the AncestorRef and ControllerName fields combined.
	//  A maximum of 16 ancestors will be represented in this list. An empty list means the Policy is not relevant for any ancestors.
	//  If this slice is full, implementations MUST NOT add further entries. Instead they MUST consider the policy unimplementable and signal that on any related resources such as the ancestor that would be referenced here. For example, if this list was full on BackendTLSPolicy, no additional Gateways would be able to reference the Service targeted by the BackendTLSPolicy.
	Ancestors []BackendTLSPolicyStatusAncestors `pulumi:"ancestors"`
}

// BackendTLSPolicyStatusInput is an input type that accepts BackendTLSPolicyStatusArgs and BackendTLSPolicyStatusOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusInput` via:
//
//	BackendTLSPolicyStatusArgs{...}
type BackendTLSPolicyStatusInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusOutput() BackendTLSPolicyStatusOutput
	ToBackendTLSPolicyStatusOutputWithContext(context.Context) BackendTLSPolicyStatusOutput
}

// Status defines the current state of BackendTLSPolicy.
type BackendTLSPolicyStatusArgs struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are associated with the policy, and the status of the policy with respect to each ancestor. When this policy attaches to a parent, the controller that manages the parent and the ancestors MUST add an entry to this list when the controller first sees the policy and SHOULD update the entry as appropriate when the relevant ancestor is modified.
	//  Note that choosing the relevant ancestor is left to the Policy designers; an important part of Policy design is designing the right object level at which to namespace this status.
	//  Note also that implementations MUST ONLY populate ancestor status for the Ancestor resources they are responsible for. Implementations MUST use the ControllerName field to uniquely identify the entries in this list that they are responsible for.
	//  Note that to achieve this, the list of PolicyAncestorStatus structs MUST be treated as a map with a composite key, made up of the AncestorRef and ControllerName fields combined.
	//  A maximum of 16 ancestors will be represented in this list. An empty list means the Policy is not relevant for any ancestors.
	//  If this slice is full, implementations MUST NOT add further entries. Instead they MUST consider the policy unimplementable and signal that on any related resources such as the ancestor that would be referenced here. For example, if this list was full on BackendTLSPolicy, no additional Gateways would be able to reference the Service targeted by the BackendTLSPolicy.
	Ancestors BackendTLSPolicyStatusAncestorsArrayInput `pulumi:"ancestors"`
}

func (BackendTLSPolicyStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatus)(nil)).Elem()
}

func (i BackendTLSPolicyStatusArgs) ToBackendTLSPolicyStatusOutput() BackendTLSPolicyStatusOutput {
	return i.ToBackendTLSPolicyStatusOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusArgs) ToBackendTLSPolicyStatusOutputWithContext(ctx context.Context) BackendTLSPolicyStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusOutput)
}

func (i BackendTLSPolicyStatusArgs) ToBackendTLSPolicyStatusPtrOutput() BackendTLSPolicyStatusPtrOutput {
	return i.ToBackendTLSPolicyStatusPtrOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusArgs) ToBackendTLSPolicyStatusPtrOutputWithContext(ctx context.Context) BackendTLSPolicyStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusOutput).ToBackendTLSPolicyStatusPtrOutputWithContext(ctx)
}

// BackendTLSPolicyStatusPtrInput is an input type that accepts BackendTLSPolicyStatusArgs, BackendTLSPolicyStatusPtr and BackendTLSPolicyStatusPtrOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusPtrInput` via:
//
//	        BackendTLSPolicyStatusArgs{...}
//
//	or:
//
//	        nil
type BackendTLSPolicyStatusPtrInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusPtrOutput() BackendTLSPolicyStatusPtrOutput
	ToBackendTLSPolicyStatusPtrOutputWithContext(context.Context) BackendTLSPolicyStatusPtrOutput
}

type backendTLSPolicyStatusPtrType BackendTLSPolicyStatusArgs

func BackendTLSPolicyStatusPtr(v *BackendTLSPolicyStatusArgs) BackendTLSPolicyStatusPtrInput {
	return (*backendTLSPolicyStatusPtrType)(v)
}

func (*backendTLSPolicyStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicyStatus)(nil)).Elem()
}

func (i *backendTLSPolicyStatusPtrType) ToBackendTLSPolicyStatusPtrOutput() BackendTLSPolicyStatusPtrOutput {
	return i.ToBackendTLSPolicyStatusPtrOutputWithContext(context.Background())
}

func (i *backendTLSPolicyStatusPtrType) ToBackendTLSPolicyStatusPtrOutputWithContext(ctx context.Context) BackendTLSPolicyStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusPtrOutput)
}

// Status defines the current state of BackendTLSPolicy.
type BackendTLSPolicyStatusOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatus)(nil)).Elem()
}

func (o BackendTLSPolicyStatusOutput) ToBackendTLSPolicyStatusOutput() BackendTLSPolicyStatusOutput {
	return o
}

func (o BackendTLSPolicyStatusOutput) ToBackendTLSPolicyStatusOutputWithContext(ctx context.Context) BackendTLSPolicyStatusOutput {
	return o
}

func (o BackendTLSPolicyStatusOutput) ToBackendTLSPolicyStatusPtrOutput() BackendTLSPolicyStatusPtrOutput {
	return o.ToBackendTLSPolicyStatusPtrOutputWithContext(context.Background())
}

func (o BackendTLSPolicyStatusOutput) ToBackendTLSPolicyStatusPtrOutputWithContext(ctx context.Context) BackendTLSPolicyStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BackendTLSPolicyStatus) *BackendTLSPolicyStatus {
		return &v
	}).(BackendTLSPolicyStatusPtrOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are associated with the policy, and the status of the policy with respect to each ancestor. When this policy attaches to a parent, the controller that manages the parent and the ancestors MUST add an entry to this list when the controller first sees the policy and SHOULD update the entry as appropriate when the relevant ancestor is modified.
//
//	Note that choosing the relevant ancestor is left to the Policy designers; an important part of Policy design is designing the right object level at which to namespace this status.
//	Note also that implementations MUST ONLY populate ancestor status for the Ancestor resources they are responsible for. Implementations MUST use the ControllerName field to uniquely identify the entries in this list that they are responsible for.
//	Note that to achieve this, the list of PolicyAncestorStatus structs MUST be treated as a map with a composite key, made up of the AncestorRef and ControllerName fields combined.
//	A maximum of 16 ancestors will be represented in this list. An empty list means the Policy is not relevant for any ancestors.
//	If this slice is full, implementations MUST NOT add further entries. Instead they MUST consider the policy unimplementable and signal that on any related resources such as the ancestor that would be referenced here. For example, if this list was full on BackendTLSPolicy, no additional Gateways would be able to reference the Service targeted by the BackendTLSPolicy.
func (o BackendTLSPolicyStatusOutput) Ancestors() BackendTLSPolicyStatusAncestorsArrayOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatus) []BackendTLSPolicyStatusAncestors { return v.Ancestors }).(BackendTLSPolicyStatusAncestorsArrayOutput)
}

type BackendTLSPolicyStatusPtrOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BackendTLSPolicyStatus)(nil)).Elem()
}

func (o BackendTLSPolicyStatusPtrOutput) ToBackendTLSPolicyStatusPtrOutput() BackendTLSPolicyStatusPtrOutput {
	return o
}

func (o BackendTLSPolicyStatusPtrOutput) ToBackendTLSPolicyStatusPtrOutputWithContext(ctx context.Context) BackendTLSPolicyStatusPtrOutput {
	return o
}

func (o BackendTLSPolicyStatusPtrOutput) Elem() BackendTLSPolicyStatusOutput {
	return o.ApplyT(func(v *BackendTLSPolicyStatus) BackendTLSPolicyStatus {
		if v != nil {
			return *v
		}
		var ret BackendTLSPolicyStatus
		return ret
	}).(BackendTLSPolicyStatusOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are associated with the policy, and the status of the policy with respect to each ancestor. When this policy attaches to a parent, the controller that manages the parent and the ancestors MUST add an entry to this list when the controller first sees the policy and SHOULD update the entry as appropriate when the relevant ancestor is modified.
//
//	Note that choosing the relevant ancestor is left to the Policy designers; an important part of Policy design is designing the right object level at which to namespace this status.
//	Note also that implementations MUST ONLY populate ancestor status for the Ancestor resources they are responsible for. Implementations MUST use the ControllerName field to uniquely identify the entries in this list that they are responsible for.
//	Note that to achieve this, the list of PolicyAncestorStatus structs MUST be treated as a map with a composite key, made up of the AncestorRef and ControllerName fields combined.
//	A maximum of 16 ancestors will be represented in this list. An empty list means the Policy is not relevant for any ancestors.
//	If this slice is full, implementations MUST NOT add further entries. Instead they MUST consider the policy unimplementable and signal that on any related resources such as the ancestor that would be referenced here. For example, if this list was full on BackendTLSPolicy, no additional Gateways would be able to reference the Service targeted by the BackendTLSPolicy.
func (o BackendTLSPolicyStatusPtrOutput) Ancestors() BackendTLSPolicyStatusAncestorsArrayOutput {
	return o.ApplyT(func(v *BackendTLSPolicyStatus) []BackendTLSPolicyStatusAncestors {
		if v == nil {
			return nil
		}
		return v.Ancestors
	}).(BackendTLSPolicyStatusAncestorsArrayOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an associated Ancestor.
//
//	Ancestors refer to objects that are either the Target of a policy or above it in terms of object hierarchy. For example, if a policy targets a Service, the Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most useful object to place Policy status on, so we recommend that implementations SHOULD use Gateway as the PolicyAncestorStatus object unless the designers have a _very_ good reason otherwise.
//	In the context of policy attachment, the Ancestor is used to distinguish which resource results in a distinct application of this policy. For example, if a policy targets a Service, it may have a distinct result per attached Gateway.
//	Policies targeting the same resource may have different effects depending on the ancestors of those resources. For example, different Gateways targeting the same Service may have different capabilities, especially if they have different underlying implementations.
//	For example, in BackendTLSPolicy, the Policy attaches to a Service that is used as a backend in a HTTPRoute that is itself attached to a Gateway. In this case, the relevant object for status is the Gateway, and that is the ancestor object referred to in this status.
//	Note that a parent is also an ancestor, so for objects where the parent is the relevant object for status, this struct SHOULD still be used.
//	This struct is intended to be used in a slice that's effectively a map, with a composite key made up of the AncestorRef and the ControllerName.
type BackendTLSPolicyStatusAncestors struct {
	// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
	AncestorRef BackendTLSPolicyStatusAncestorsAncestorRef `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions []BackendTLSPolicyStatusAncestorsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName string `pulumi:"controllerName"`
}

// Defaults sets the appropriate defaults for BackendTLSPolicyStatusAncestors
func (val *BackendTLSPolicyStatusAncestors) Defaults() *BackendTLSPolicyStatusAncestors {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.AncestorRef = *tmp.AncestorRef.Defaults()

	return &tmp
}

// BackendTLSPolicyStatusAncestorsInput is an input type that accepts BackendTLSPolicyStatusAncestorsArgs and BackendTLSPolicyStatusAncestorsOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusAncestorsInput` via:
//
//	BackendTLSPolicyStatusAncestorsArgs{...}
type BackendTLSPolicyStatusAncestorsInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusAncestorsOutput() BackendTLSPolicyStatusAncestorsOutput
	ToBackendTLSPolicyStatusAncestorsOutputWithContext(context.Context) BackendTLSPolicyStatusAncestorsOutput
}

// PolicyAncestorStatus describes the status of a route with respect to an associated Ancestor.
//
//	Ancestors refer to objects that are either the Target of a policy or above it in terms of object hierarchy. For example, if a policy targets a Service, the Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most useful object to place Policy status on, so we recommend that implementations SHOULD use Gateway as the PolicyAncestorStatus object unless the designers have a _very_ good reason otherwise.
//	In the context of policy attachment, the Ancestor is used to distinguish which resource results in a distinct application of this policy. For example, if a policy targets a Service, it may have a distinct result per attached Gateway.
//	Policies targeting the same resource may have different effects depending on the ancestors of those resources. For example, different Gateways targeting the same Service may have different capabilities, especially if they have different underlying implementations.
//	For example, in BackendTLSPolicy, the Policy attaches to a Service that is used as a backend in a HTTPRoute that is itself attached to a Gateway. In this case, the relevant object for status is the Gateway, and that is the ancestor object referred to in this status.
//	Note that a parent is also an ancestor, so for objects where the parent is the relevant object for status, this struct SHOULD still be used.
//	This struct is intended to be used in a slice that's effectively a map, with a composite key made up of the AncestorRef and the ControllerName.
type BackendTLSPolicyStatusAncestorsArgs struct {
	// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
	AncestorRef BackendTLSPolicyStatusAncestorsAncestorRefInput `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions BackendTLSPolicyStatusAncestorsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
}

// Defaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsArgs
func (val *BackendTLSPolicyStatusAncestorsArgs) Defaults() *BackendTLSPolicyStatusAncestorsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (BackendTLSPolicyStatusAncestorsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestors)(nil)).Elem()
}

func (i BackendTLSPolicyStatusAncestorsArgs) ToBackendTLSPolicyStatusAncestorsOutput() BackendTLSPolicyStatusAncestorsOutput {
	return i.ToBackendTLSPolicyStatusAncestorsOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusAncestorsArgs) ToBackendTLSPolicyStatusAncestorsOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusAncestorsOutput)
}

// BackendTLSPolicyStatusAncestorsArrayInput is an input type that accepts BackendTLSPolicyStatusAncestorsArray and BackendTLSPolicyStatusAncestorsArrayOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusAncestorsArrayInput` via:
//
//	BackendTLSPolicyStatusAncestorsArray{ BackendTLSPolicyStatusAncestorsArgs{...} }
type BackendTLSPolicyStatusAncestorsArrayInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusAncestorsArrayOutput() BackendTLSPolicyStatusAncestorsArrayOutput
	ToBackendTLSPolicyStatusAncestorsArrayOutputWithContext(context.Context) BackendTLSPolicyStatusAncestorsArrayOutput
}

type BackendTLSPolicyStatusAncestorsArray []BackendTLSPolicyStatusAncestorsInput

func (BackendTLSPolicyStatusAncestorsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicyStatusAncestors)(nil)).Elem()
}

func (i BackendTLSPolicyStatusAncestorsArray) ToBackendTLSPolicyStatusAncestorsArrayOutput() BackendTLSPolicyStatusAncestorsArrayOutput {
	return i.ToBackendTLSPolicyStatusAncestorsArrayOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusAncestorsArray) ToBackendTLSPolicyStatusAncestorsArrayOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusAncestorsArrayOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an associated Ancestor.
//
//	Ancestors refer to objects that are either the Target of a policy or above it in terms of object hierarchy. For example, if a policy targets a Service, the Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most useful object to place Policy status on, so we recommend that implementations SHOULD use Gateway as the PolicyAncestorStatus object unless the designers have a _very_ good reason otherwise.
//	In the context of policy attachment, the Ancestor is used to distinguish which resource results in a distinct application of this policy. For example, if a policy targets a Service, it may have a distinct result per attached Gateway.
//	Policies targeting the same resource may have different effects depending on the ancestors of those resources. For example, different Gateways targeting the same Service may have different capabilities, especially if they have different underlying implementations.
//	For example, in BackendTLSPolicy, the Policy attaches to a Service that is used as a backend in a HTTPRoute that is itself attached to a Gateway. In this case, the relevant object for status is the Gateway, and that is the ancestor object referred to in this status.
//	Note that a parent is also an ancestor, so for objects where the parent is the relevant object for status, this struct SHOULD still be used.
//	This struct is intended to be used in a slice that's effectively a map, with a composite key made up of the AncestorRef and the ControllerName.
type BackendTLSPolicyStatusAncestorsOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusAncestorsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestors)(nil)).Elem()
}

func (o BackendTLSPolicyStatusAncestorsOutput) ToBackendTLSPolicyStatusAncestorsOutput() BackendTLSPolicyStatusAncestorsOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsOutput) ToBackendTLSPolicyStatusAncestorsOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsOutput {
	return o
}

// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
func (o BackendTLSPolicyStatusAncestorsOutput) AncestorRef() BackendTLSPolicyStatusAncestorsAncestorRefOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestors) BackendTLSPolicyStatusAncestorsAncestorRef {
		return v.AncestorRef
	}).(BackendTLSPolicyStatusAncestorsAncestorRefOutput)
}

// Conditions describes the status of the Policy with respect to the given Ancestor.
func (o BackendTLSPolicyStatusAncestorsOutput) Conditions() BackendTLSPolicyStatusAncestorsConditionsArrayOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestors) []BackendTLSPolicyStatusAncestorsConditions {
		return v.Conditions
	}).(BackendTLSPolicyStatusAncestorsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
//
//	Example: "example.net/gateway-controller".
//	The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//	Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
func (o BackendTLSPolicyStatusAncestorsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestors) string { return v.ControllerName }).(pulumi.StringOutput)
}

type BackendTLSPolicyStatusAncestorsArrayOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusAncestorsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicyStatusAncestors)(nil)).Elem()
}

func (o BackendTLSPolicyStatusAncestorsArrayOutput) ToBackendTLSPolicyStatusAncestorsArrayOutput() BackendTLSPolicyStatusAncestorsArrayOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsArrayOutput) ToBackendTLSPolicyStatusAncestorsArrayOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsArrayOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsArrayOutput) Index(i pulumi.IntInput) BackendTLSPolicyStatusAncestorsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BackendTLSPolicyStatusAncestors {
		return vs[0].([]BackendTLSPolicyStatusAncestors)[vs[1].(int)]
	}).(BackendTLSPolicyStatusAncestorsOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
type BackendTLSPolicyStatusAncestorsAncestorRef struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsAncestorRef
func (val *BackendTLSPolicyStatusAncestorsAncestorRef) Defaults() *BackendTLSPolicyStatusAncestorsAncestorRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// BackendTLSPolicyStatusAncestorsAncestorRefInput is an input type that accepts BackendTLSPolicyStatusAncestorsAncestorRefArgs and BackendTLSPolicyStatusAncestorsAncestorRefOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusAncestorsAncestorRefInput` via:
//
//	BackendTLSPolicyStatusAncestorsAncestorRefArgs{...}
type BackendTLSPolicyStatusAncestorsAncestorRefInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusAncestorsAncestorRefOutput() BackendTLSPolicyStatusAncestorsAncestorRefOutput
	ToBackendTLSPolicyStatusAncestorsAncestorRefOutputWithContext(context.Context) BackendTLSPolicyStatusAncestorsAncestorRefOutput
}

// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
type BackendTLSPolicyStatusAncestorsAncestorRefArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsAncestorRefArgs
func (val *BackendTLSPolicyStatusAncestorsAncestorRefArgs) Defaults() *BackendTLSPolicyStatusAncestorsAncestorRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (BackendTLSPolicyStatusAncestorsAncestorRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (i BackendTLSPolicyStatusAncestorsAncestorRefArgs) ToBackendTLSPolicyStatusAncestorsAncestorRefOutput() BackendTLSPolicyStatusAncestorsAncestorRefOutput {
	return i.ToBackendTLSPolicyStatusAncestorsAncestorRefOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusAncestorsAncestorRefArgs) ToBackendTLSPolicyStatusAncestorsAncestorRefOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsAncestorRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusAncestorsAncestorRefOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
type BackendTLSPolicyStatusAncestorsAncestorRefOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusAncestorsAncestorRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) ToBackendTLSPolicyStatusAncestorsAncestorRefOutput() BackendTLSPolicyStatusAncestorsAncestorRefOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) ToBackendTLSPolicyStatusAncestorsAncestorRefOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsAncestorRefOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o BackendTLSPolicyStatusAncestorsAncestorRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsAncestorRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type BackendTLSPolicyStatusAncestorsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// BackendTLSPolicyStatusAncestorsConditionsInput is an input type that accepts BackendTLSPolicyStatusAncestorsConditionsArgs and BackendTLSPolicyStatusAncestorsConditionsOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusAncestorsConditionsInput` via:
//
//	BackendTLSPolicyStatusAncestorsConditionsArgs{...}
type BackendTLSPolicyStatusAncestorsConditionsInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusAncestorsConditionsOutput() BackendTLSPolicyStatusAncestorsConditionsOutput
	ToBackendTLSPolicyStatusAncestorsConditionsOutputWithContext(context.Context) BackendTLSPolicyStatusAncestorsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type BackendTLSPolicyStatusAncestorsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (BackendTLSPolicyStatusAncestorsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (i BackendTLSPolicyStatusAncestorsConditionsArgs) ToBackendTLSPolicyStatusAncestorsConditionsOutput() BackendTLSPolicyStatusAncestorsConditionsOutput {
	return i.ToBackendTLSPolicyStatusAncestorsConditionsOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusAncestorsConditionsArgs) ToBackendTLSPolicyStatusAncestorsConditionsOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusAncestorsConditionsOutput)
}

// BackendTLSPolicyStatusAncestorsConditionsArrayInput is an input type that accepts BackendTLSPolicyStatusAncestorsConditionsArray and BackendTLSPolicyStatusAncestorsConditionsArrayOutput values.
// You can construct a concrete instance of `BackendTLSPolicyStatusAncestorsConditionsArrayInput` via:
//
//	BackendTLSPolicyStatusAncestorsConditionsArray{ BackendTLSPolicyStatusAncestorsConditionsArgs{...} }
type BackendTLSPolicyStatusAncestorsConditionsArrayInput interface {
	pulumi.Input

	ToBackendTLSPolicyStatusAncestorsConditionsArrayOutput() BackendTLSPolicyStatusAncestorsConditionsArrayOutput
	ToBackendTLSPolicyStatusAncestorsConditionsArrayOutputWithContext(context.Context) BackendTLSPolicyStatusAncestorsConditionsArrayOutput
}

type BackendTLSPolicyStatusAncestorsConditionsArray []BackendTLSPolicyStatusAncestorsConditionsInput

func (BackendTLSPolicyStatusAncestorsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (i BackendTLSPolicyStatusAncestorsConditionsArray) ToBackendTLSPolicyStatusAncestorsConditionsArrayOutput() BackendTLSPolicyStatusAncestorsConditionsArrayOutput {
	return i.ToBackendTLSPolicyStatusAncestorsConditionsArrayOutputWithContext(context.Background())
}

func (i BackendTLSPolicyStatusAncestorsConditionsArray) ToBackendTLSPolicyStatusAncestorsConditionsArrayOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendTLSPolicyStatusAncestorsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type BackendTLSPolicyStatusAncestorsConditionsOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusAncestorsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BackendTLSPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (o BackendTLSPolicyStatusAncestorsConditionsOutput) ToBackendTLSPolicyStatusAncestorsConditionsOutput() BackendTLSPolicyStatusAncestorsConditionsOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsConditionsOutput) ToBackendTLSPolicyStatusAncestorsConditionsOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition. This may be an empty string.
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o BackendTLSPolicyStatusAncestorsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v BackendTLSPolicyStatusAncestorsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type BackendTLSPolicyStatusAncestorsConditionsArrayOutput struct{ *pulumi.OutputState }

func (BackendTLSPolicyStatusAncestorsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]BackendTLSPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (o BackendTLSPolicyStatusAncestorsConditionsArrayOutput) ToBackendTLSPolicyStatusAncestorsConditionsArrayOutput() BackendTLSPolicyStatusAncestorsConditionsArrayOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsConditionsArrayOutput) ToBackendTLSPolicyStatusAncestorsConditionsArrayOutputWithContext(ctx context.Context) BackendTLSPolicyStatusAncestorsConditionsArrayOutput {
	return o
}

func (o BackendTLSPolicyStatusAncestorsConditionsArrayOutput) Index(i pulumi.IntInput) BackendTLSPolicyStatusAncestorsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) BackendTLSPolicyStatusAncestorsConditions {
		return vs[0].([]BackendTLSPolicyStatusAncestorsConditions)[vs[1].(int)]
	}).(BackendTLSPolicyStatusAncestorsConditionsOutput)
}

// GRPCRoute provides a way to route gRPC requests. This includes the capability to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header. Filters can be used to specify additional processing steps. Backends specify where matching requests will be routed.
//
//	GRPCRoute falls under extended support within the Gateway API. Within the following specification, the word "MUST" indicates that an implementation supporting GRPCRoute must conform to the indicated requirement, but an implementation not supporting this route type need not follow the requirement unless explicitly indicated.
//	Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via ALPN. If the implementation does not support this, then it MUST set the "Accepted" condition to "False" for the affected listener with a reason of "UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections with an upgrade from HTTP/1.
//	Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST support HTTP/2 over cleartext TCP (h2c, https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial upgrade from HTTP/1.1, i.e. with prior knowledge (https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation does not support this, then it MUST set the "Accepted" condition to "False" for the affected listener with a reason of "UnsupportedProtocol". Implementations MAY also accept HTTP/2 connections with an upgrade from HTTP/1, i.e. without prior knowledge.
type GRPCRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of GRPCRoute.
	Spec *GRPCRouteSpec `pulumi:"spec"`
	// Status defines the current state of GRPCRoute.
	Status *GRPCRouteStatus `pulumi:"status"`
}

type GRPCRouteMetadata struct {
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpec struct {
	// Hostnames defines a set of hostnames to match against the GRPC Host header to select a GRPCRoute to process the request. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
	//  1. IPs are not allowed. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label MUST appear by itself as the first label.
	//      If a hostname is specified by both the Listener and GRPCRoute, there MUST be at least one intersecting hostname for the GRPCRoute to be attached to the Listener. For example:
	//  * A Listener with `test.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
	//     Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//     If both the Listener and GRPCRoute have specified hostnames, any GRPCRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the GRPCRoute specified `test.example.com` and `test.example.net`, `test.example.net` MUST NOT be considered for a match.
	//     If both the Listener and GRPCRoute have specified hostnames, and none match with the criteria above, then the GRPCRoute MUST NOT be accepted by the implementation. The implementation MUST raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
	//     If a Route (A) of type HTTPRoute or GRPCRoute is attached to a Listener and that listener already has another Route (B) of the other type attached and the intersection of the hostnames of A and B is non-empty, then the implementation MUST accept exactly one of these two routes, determined by the following criteria, in order:
	//  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
	//     The rejected Route MUST raise an 'Accepted' condition with a status of 'False' in the corresponding RouteParentStatus.
	//     Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs []GRPCRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules []GRPCRouteSpecRules `pulumi:"rules"`
}

// GRPCRouteSpecInput is an input type that accepts GRPCRouteSpecArgs and GRPCRouteSpecOutput values.
// You can construct a concrete instance of `GRPCRouteSpecInput` via:
//
//	GRPCRouteSpecArgs{...}
type GRPCRouteSpecInput interface {
	pulumi.Input

	ToGRPCRouteSpecOutput() GRPCRouteSpecOutput
	ToGRPCRouteSpecOutputWithContext(context.Context) GRPCRouteSpecOutput
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecArgs struct {
	// Hostnames defines a set of hostnames to match against the GRPC Host header to select a GRPCRoute to process the request. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
	//  1. IPs are not allowed. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label MUST appear by itself as the first label.
	//      If a hostname is specified by both the Listener and GRPCRoute, there MUST be at least one intersecting hostname for the GRPCRoute to be attached to the Listener. For example:
	//  * A Listener with `test.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
	//     Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//     If both the Listener and GRPCRoute have specified hostnames, any GRPCRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the GRPCRoute specified `test.example.com` and `test.example.net`, `test.example.net` MUST NOT be considered for a match.
	//     If both the Listener and GRPCRoute have specified hostnames, and none match with the criteria above, then the GRPCRoute MUST NOT be accepted by the implementation. The implementation MUST raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
	//     If a Route (A) of type HTTPRoute or GRPCRoute is attached to a Listener and that listener already has another Route (B) of the other type attached and the intersection of the hostnames of A and B is non-empty, then the implementation MUST accept exactly one of these two routes, determined by the following criteria, in order:
	//  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
	//     The rejected Route MUST raise an 'Accepted' condition with a status of 'False' in the corresponding RouteParentStatus.
	//     Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs GRPCRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of GRPC matchers, filters and actions.
	Rules GRPCRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (GRPCRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return i.ToGRPCRouteSpecOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput)
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecArgs) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecOutput).ToGRPCRouteSpecPtrOutputWithContext(ctx)
}

// GRPCRouteSpecPtrInput is an input type that accepts GRPCRouteSpecArgs, GRPCRouteSpecPtr and GRPCRouteSpecPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecPtrInput` via:
//
//	        GRPCRouteSpecArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput
	ToGRPCRouteSpecPtrOutputWithContext(context.Context) GRPCRouteSpecPtrOutput
}

type grpcrouteSpecPtrType GRPCRouteSpecArgs

func GRPCRouteSpecPtr(v *GRPCRouteSpecArgs) GRPCRouteSpecPtrInput {
	return (*grpcrouteSpecPtrType)(v)
}

func (*grpcrouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return i.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecPtrType) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecPtrOutput)
}

// Spec defines the desired state of GRPCRoute.
type GRPCRouteSpecOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutput() GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecOutputWithContext(ctx context.Context) GRPCRouteSpecOutput {
	return o
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o.ToGRPCRouteSpecPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpec) *GRPCRouteSpec {
		return &v
	}).(GRPCRouteSpecPtrOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC Host header to select a GRPCRoute to process the request. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
//  1. IPs are not allowed. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label MUST appear by itself as the first label.
//     If a hostname is specified by both the Listener and GRPCRoute, there MUST be at least one intersecting hostname for the GRPCRoute to be attached to the Listener. For example:
//     * A Listener with `test.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
//     Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//     If both the Listener and GRPCRoute have specified hostnames, any GRPCRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the GRPCRoute specified `test.example.com` and `test.example.net`, `test.example.net` MUST NOT be considered for a match.
//     If both the Listener and GRPCRoute have specified hostnames, and none match with the criteria above, then the GRPCRoute MUST NOT be accepted by the implementation. The implementation MUST raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
//     If a Route (A) of type HTTPRoute or GRPCRoute is attached to a Listener and that listener already has another Route (B) of the other type attached and the intersection of the hostnames of A and B is non-empty, then the implementation MUST accept exactly one of these two routes, determined by the following criteria, in order:
//     * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
//     The rejected Route MUST raise an 'Accepted' condition with a status of 'False' in the corresponding RouteParentStatus.
//     Support: Core
func (o GRPCRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o GRPCRouteSpecOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecParentRefs { return v.ParentRefs }).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpec) []GRPCRouteSpecRules { return v.Rules }).(GRPCRouteSpecRulesArrayOutput)
}

type GRPCRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpec)(nil)).Elem()
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutput() GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) ToGRPCRouteSpecPtrOutputWithContext(ctx context.Context) GRPCRouteSpecPtrOutput {
	return o
}

func (o GRPCRouteSpecPtrOutput) Elem() GRPCRouteSpecOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) GRPCRouteSpec {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpec
		return ret
	}).(GRPCRouteSpecOutput)
}

// Hostnames defines a set of hostnames to match against the GRPC Host header to select a GRPCRoute to process the request. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
//  1. IPs are not allowed. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label MUST appear by itself as the first label.
//     If a hostname is specified by both the Listener and GRPCRoute, there MUST be at least one intersecting hostname for the GRPCRoute to be attached to the Listener. For example:
//     * A Listener with `test.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
//     Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
//     If both the Listener and GRPCRoute have specified hostnames, any GRPCRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the GRPCRoute specified `test.example.com` and `test.example.net`, `test.example.net` MUST NOT be considered for a match.
//     If both the Listener and GRPCRoute have specified hostnames, and none match with the criteria above, then the GRPCRoute MUST NOT be accepted by the implementation. The implementation MUST raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
//     If a Route (A) of type HTTPRoute or GRPCRoute is attached to a Listener and that listener already has another Route (B) of the other type attached and the intersection of the hostnames of A and B is non-empty, then the implementation MUST accept exactly one of these two routes, determined by the following criteria, in order:
//     * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
//     The rejected Route MUST raise an 'Accepted' condition with a status of 'False' in the corresponding RouteParentStatus.
//     Support: Core
func (o GRPCRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o GRPCRouteSpecPtrOutput) ParentRefs() GRPCRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(GRPCRouteSpecParentRefsArrayOutput)
}

// Rules are a list of GRPC matchers, filters and actions.
func (o GRPCRouteSpecPtrOutput) Rules() GRPCRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpec) []GRPCRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(GRPCRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecParentRefs
func (val *GRPCRouteSpecParentRefs) Defaults() *GRPCRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecParentRefsInput is an input type that accepts GRPCRouteSpecParentRefsArgs and GRPCRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsInput` via:
//
//	GRPCRouteSpecParentRefsArgs{...}
type GRPCRouteSpecParentRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput
	ToGRPCRouteSpecParentRefsOutputWithContext(context.Context) GRPCRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecParentRefsArgs
func (val *GRPCRouteSpecParentRefsArgs) Defaults() *GRPCRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (GRPCRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return i.ToGRPCRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArgs) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsOutput)
}

// GRPCRouteSpecParentRefsArrayInput is an input type that accepts GRPCRouteSpecParentRefsArray and GRPCRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecParentRefsArrayInput` via:
//
//	GRPCRouteSpecParentRefsArray{ GRPCRouteSpecParentRefsArgs{...} }
type GRPCRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput
	ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Context) GRPCRouteSpecParentRefsArrayOutput
}

type GRPCRouteSpecParentRefsArray []GRPCRouteSpecParentRefsInput

func (GRPCRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return i.ToGRPCRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecParentRefsArray) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type GRPCRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutput() GRPCRouteSpecParentRefsOutput {
	return o
}

func (o GRPCRouteSpecParentRefsOutput) ToGRPCRouteSpecParentRefsOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o GRPCRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o GRPCRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o GRPCRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o GRPCRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o GRPCRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o GRPCRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecParentRefs)(nil)).Elem()
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutput() GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) ToGRPCRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecParentRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecParentRefs {
		return vs[0].([]GRPCRouteSpecParentRefs)[vs[1].(int)]
	}).(GRPCRouteSpecParentRefsOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on conditions (matches), processing it (filters), and forwarding the request to an API object (backendRefs).
type GRPCRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be sent.
	//  Failure behavior here depends on how many BackendRefs are specified and how many are invalid.
	//  If *all* entries in BackendRefs are invalid, and there are also no filters specified in this route rule, *all* traffic which matches this rule MUST receive an `UNAVAILABLE` status.
	//  See the GRPCBackendRef definition for the rules about what makes a single GRPCBackendRef invalid.
	//  When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for requests that would have otherwise been routed to an invalid backend. If multiple backends are specified, and some are invalid, the proportion of requests that would otherwise have been routed to an invalid backend MUST receive an `UNAVAILABLE` status.
	//  For example, if two backends are specified with equal weights, and one is invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status. Implementations may choose how that 50 percent is determined.
	//  Support: Core for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Core
	BackendRefs []GRPCRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match this rule.
	//  The effects of ordering of multiple behaviors are currently unspecified. This can change in the future based on feedback during the alpha stage.
	//  Conformance-levels at this level are defined based on the type of filter:
	//  - ALL core filters MUST be supported by all implementations that support GRPCRoute. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations.
	//     Specifying the same filter multiple times is not supported unless explicitly indicated in the filter.
	//     If an implementation can not support a combination of filters, it must clearly document that limitation. In cases where incompatible or unsupported filters are specified and cause the `Accepted` condition to be set to status `False`, implementations may use the `IncompatibleFilters` reason to specify this configuration error.
	//     Support: Core
	Filters []GRPCRouteSpecRulesFilters `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if **any** one of the matches is satisfied.
	//  For example, take the following matches configuration:
	//  ```matches: - method: service: foo.bar headers: values: version: 2 - method: service: foo.bar.v2```
	//  For a request to match against this rule, it MUST satisfy EITHER of the two conditions:
	//  - service of foo.bar AND contains the header `version: 2` - service of foo.bar.v2
	//     See the documentation for GRPCRouteMatch on how to specify multiple match conditions to be ANDed together.
	//     If no matches are specified, the implementation MUST match every gRPC request.
	//     Proxy or Load Balancer routing configuration generated from GRPCRoutes MUST prioritize rules based on the following criteria, continuing on ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes. Precedence MUST be given to the rule with the largest number of:
	//  * Characters in a matching non-wildcard hostname. * Characters in a matching hostname. * Characters in a matching service. * Characters in a matching method. * Header matches.
	//     If ties still exist across multiple Routes, matching precedence MUST be determined in order of the following criteria, continuing on ties:
	//  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
	//     If ties still exist within the Route that has been given precedence, matching precedence MUST be granted to the first matching rule meeting the above criteria.
	Matches []GRPCRouteSpecRulesMatches `pulumi:"matches"`
}

// GRPCRouteSpecRulesInput is an input type that accepts GRPCRouteSpecRulesArgs and GRPCRouteSpecRulesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesInput` via:
//
//	GRPCRouteSpecRulesArgs{...}
type GRPCRouteSpecRulesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput
	ToGRPCRouteSpecRulesOutputWithContext(context.Context) GRPCRouteSpecRulesOutput
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on conditions (matches), processing it (filters), and forwarding the request to an API object (backendRefs).
type GRPCRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be sent.
	//  Failure behavior here depends on how many BackendRefs are specified and how many are invalid.
	//  If *all* entries in BackendRefs are invalid, and there are also no filters specified in this route rule, *all* traffic which matches this rule MUST receive an `UNAVAILABLE` status.
	//  See the GRPCBackendRef definition for the rules about what makes a single GRPCBackendRef invalid.
	//  When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for requests that would have otherwise been routed to an invalid backend. If multiple backends are specified, and some are invalid, the proportion of requests that would otherwise have been routed to an invalid backend MUST receive an `UNAVAILABLE` status.
	//  For example, if two backends are specified with equal weights, and one is invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status. Implementations may choose how that 50 percent is determined.
	//  Support: Core for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Core
	BackendRefs GRPCRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Filters define the filters that are applied to requests that match this rule.
	//  The effects of ordering of multiple behaviors are currently unspecified. This can change in the future based on feedback during the alpha stage.
	//  Conformance-levels at this level are defined based on the type of filter:
	//  - ALL core filters MUST be supported by all implementations that support GRPCRoute. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations.
	//     Specifying the same filter multiple times is not supported unless explicitly indicated in the filter.
	//     If an implementation can not support a combination of filters, it must clearly document that limitation. In cases where incompatible or unsupported filters are specified and cause the `Accepted` condition to be set to status `False`, implementations may use the `IncompatibleFilters` reason to specify this configuration error.
	//     Support: Core
	Filters GRPCRouteSpecRulesFiltersArrayInput `pulumi:"filters"`
	// Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if **any** one of the matches is satisfied.
	//  For example, take the following matches configuration:
	//  ```matches: - method: service: foo.bar headers: values: version: 2 - method: service: foo.bar.v2```
	//  For a request to match against this rule, it MUST satisfy EITHER of the two conditions:
	//  - service of foo.bar AND contains the header `version: 2` - service of foo.bar.v2
	//     See the documentation for GRPCRouteMatch on how to specify multiple match conditions to be ANDed together.
	//     If no matches are specified, the implementation MUST match every gRPC request.
	//     Proxy or Load Balancer routing configuration generated from GRPCRoutes MUST prioritize rules based on the following criteria, continuing on ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes. Precedence MUST be given to the rule with the largest number of:
	//  * Characters in a matching non-wildcard hostname. * Characters in a matching hostname. * Characters in a matching service. * Characters in a matching method. * Header matches.
	//     If ties still exist across multiple Routes, matching precedence MUST be determined in order of the following criteria, continuing on ties:
	//  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
	//     If ties still exist within the Route that has been given precedence, matching precedence MUST be granted to the first matching rule meeting the above criteria.
	Matches GRPCRouteSpecRulesMatchesArrayInput `pulumi:"matches"`
}

func (GRPCRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return i.ToGRPCRouteSpecRulesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArgs) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesOutput)
}

// GRPCRouteSpecRulesArrayInput is an input type that accepts GRPCRouteSpecRulesArray and GRPCRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesArrayInput` via:
//
//	GRPCRouteSpecRulesArray{ GRPCRouteSpecRulesArgs{...} }
type GRPCRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput
	ToGRPCRouteSpecRulesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesArrayOutput
}

type GRPCRouteSpecRulesArray []GRPCRouteSpecRulesInput

func (GRPCRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return i.ToGRPCRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesArray) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesArrayOutput)
}

// GRPCRouteRule defines the semantics for matching a gRPC request based on conditions (matches), processing it (filters), and forwarding the request to an API object (backendRefs).
type GRPCRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutput() GRPCRouteSpecRulesOutput {
	return o
}

func (o GRPCRouteSpecRulesOutput) ToGRPCRouteSpecRulesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be sent.
//
//	Failure behavior here depends on how many BackendRefs are specified and how many are invalid.
//	If *all* entries in BackendRefs are invalid, and there are also no filters specified in this route rule, *all* traffic which matches this rule MUST receive an `UNAVAILABLE` status.
//	See the GRPCBackendRef definition for the rules about what makes a single GRPCBackendRef invalid.
//	When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for requests that would have otherwise been routed to an invalid backend. If multiple backends are specified, and some are invalid, the proportion of requests that would otherwise have been routed to an invalid backend MUST receive an `UNAVAILABLE` status.
//	For example, if two backends are specified with equal weights, and one is invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status. Implementations may choose how that 50 percent is determined.
//	Support: Core for Kubernetes Service
//	Support: Implementation-specific for any other resource
//	Support for weight: Core
func (o GRPCRouteSpecRulesOutput) BackendRefs() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesBackendRefs { return v.BackendRefs }).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// Filters define the filters that are applied to requests that match this rule.
//
//	The effects of ordering of multiple behaviors are currently unspecified. This can change in the future based on feedback during the alpha stage.
//	Conformance-levels at this level are defined based on the type of filter:
//	- ALL core filters MUST be supported by all implementations that support GRPCRoute. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations.
//	   Specifying the same filter multiple times is not supported unless explicitly indicated in the filter.
//	   If an implementation can not support a combination of filters, it must clearly document that limitation. In cases where incompatible or unsupported filters are specified and cause the `Accepted` condition to be set to status `False`, implementations may use the `IncompatibleFilters` reason to specify this configuration error.
//	   Support: Core
func (o GRPCRouteSpecRulesOutput) Filters() GRPCRouteSpecRulesFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesFilters { return v.Filters }).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if **any** one of the matches is satisfied.
//
//	For example, take the following matches configuration:
//	```matches: - method: service: foo.bar headers: values: version: 2 - method: service: foo.bar.v2```
//	For a request to match against this rule, it MUST satisfy EITHER of the two conditions:
//	- service of foo.bar AND contains the header `version: 2` - service of foo.bar.v2
//	   See the documentation for GRPCRouteMatch on how to specify multiple match conditions to be ANDed together.
//	   If no matches are specified, the implementation MUST match every gRPC request.
//	   Proxy or Load Balancer routing configuration generated from GRPCRoutes MUST prioritize rules based on the following criteria, continuing on ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes. Precedence MUST be given to the rule with the largest number of:
//	* Characters in a matching non-wildcard hostname. * Characters in a matching hostname. * Characters in a matching service. * Characters in a matching method. * Header matches.
//	   If ties still exist across multiple Routes, matching precedence MUST be determined in order of the following criteria, continuing on ties:
//	* The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}".
//	   If ties still exist within the Route that has been given precedence, matching precedence MUST be granted to the first matching rule meeting the above criteria.
func (o GRPCRouteSpecRulesOutput) Matches() GRPCRouteSpecRulesMatchesArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRules) []GRPCRouteSpecRulesMatches { return v.Matches }).(GRPCRouteSpecRulesMatchesArrayOutput)
}

type GRPCRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRules)(nil)).Elem()
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutput() GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) ToGRPCRouteSpecRulesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRules {
		return vs[0].([]GRPCRouteSpecRules)[vs[1].(int)]
	}).(GRPCRouteSpecRulesOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefs struct {
	// Filters defined at this level MUST be executed if and only if the request is being forwarded to the backend defined here.
	//  Support: Implementation-specific (For broader support of filters, use the Filters field in GRPCRouteRule.)
	Filters []GRPCRouteSpecRulesBackendRefsFilters `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefs
func (val *GRPCRouteSpecRulesBackendRefs) Defaults() *GRPCRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// GRPCRouteSpecRulesBackendRefsInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArgs and GRPCRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArgs{...}
type GRPCRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput
	ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsOutput
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsArgs struct {
	// Filters defined at this level MUST be executed if and only if the request is being forwarded to the backend defined here.
	//  Support: Implementation-specific (For broader support of filters, use the Filters field in GRPCRouteRule.)
	Filters GRPCRouteSpecRulesBackendRefsFiltersArrayInput `pulumi:"filters"`
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsArgs
func (val *GRPCRouteSpecRulesBackendRefsArgs) Defaults() *GRPCRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArgs) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteSpecRulesBackendRefsArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsArray and GRPCRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsArray{ GRPCRouteSpecRulesBackendRefsArgs{...} }
type GRPCRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput
	ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput
}

type GRPCRouteSpecRulesBackendRefsArray []GRPCRouteSpecRulesBackendRefsInput

func (GRPCRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsArray) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsArrayOutput)
}

// GRPCBackendRef defines how a GRPCRoute forwards a gRPC request.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
type GRPCRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutput() GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsOutput) ToGRPCRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsOutput {
	return o
}

// Filters defined at this level MUST be executed if and only if the request is being forwarded to the backend defined here.
//
//	Support: Implementation-specific (For broader support of filters, use the Filters field in GRPCRouteRule.)
func (o GRPCRouteSpecRulesBackendRefsOutput) Filters() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) []GRPCRouteSpecRulesBackendRefsFilters { return v.Filters }).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o GRPCRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o GRPCRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
//
//	If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
//	Support for this field varies based on the context where used.
func (o GRPCRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutput() GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) ToGRPCRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefs {
		return vs[0].([]GRPCRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
	//  Support: Implementation-specific
	//  This filter can be used multiple times within the same rule.
	ExtensionRef *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request headers.
	//  Support: Core
	RequestHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
	//  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
	//  Support: Extended
	RequestMirror *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
	//  Support: Extended
	ResponseHeaderModifier *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
	//  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
	//  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
	//  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
	//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
	//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
	Type string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFilters
func (val *GRPCRouteSpecRulesBackendRefsFilters) Defaults() *GRPCRouteSpecRulesBackendRefsFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArgs and GRPCRouteSpecRulesBackendRefsFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
	//  Support: Implementation-specific
	//  This filter can be used multiple times within the same rule.
	ExtensionRef GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request headers.
	//  Support: Core
	RequestHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
	//  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
	//  Support: Extended
	RequestMirror GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
	//  Support: Extended
	ResponseHeaderModifier GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
	//  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
	//  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
	//  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
	//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
	//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
	Type pulumi.StringInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArgs) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersArray and GRPCRouteSpecRulesBackendRefsFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersArray{ GRPCRouteSpecRulesBackendRefsFiltersArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersArray []GRPCRouteSpecRulesBackendRefsFiltersInput

func (GRPCRouteSpecRulesBackendRefsFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersArray) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesBackendRefsFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutput() GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ToGRPCRouteSpecRulesBackendRefsFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ExtensionRef() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return v.ExtensionRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) RequestMirror() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return v.RequestMirror
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
//   - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
//   - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
//   - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesBackendRefsFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFilters) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFilters {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs, GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr and GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
	//  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
	//  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
	//  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
	//  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
	//  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
	//  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirror) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs
func (val *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) Defaults() *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier) []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFilters struct {
	// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
	//  Support: Implementation-specific
	//  This filter can be used multiple times within the same rule.
	ExtensionRef *GRPCRouteSpecRulesFiltersExtensionRef `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request headers.
	//  Support: Core
	RequestHeaderModifier *GRPCRouteSpecRulesFiltersRequestHeaderModifier `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
	//  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
	//  Support: Extended
	RequestMirror *GRPCRouteSpecRulesFiltersRequestMirror `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
	//  Support: Extended
	ResponseHeaderModifier *GRPCRouteSpecRulesFiltersResponseHeaderModifier `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
	//  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
	//  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
	//  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
	//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
	//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
	Type string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFilters
func (val *GRPCRouteSpecRulesFilters) Defaults() *GRPCRouteSpecRulesFilters {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.RequestMirror = tmp.RequestMirror.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesFiltersInput is an input type that accepts GRPCRouteSpecRulesFiltersArgs and GRPCRouteSpecRulesFiltersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersInput` via:
//
//	GRPCRouteSpecRulesFiltersArgs{...}
type GRPCRouteSpecRulesFiltersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput
	ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersOutput
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersArgs struct {
	// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
	//  Support: Implementation-specific
	//  This filter can be used multiple times within the same rule.
	ExtensionRef GRPCRouteSpecRulesFiltersExtensionRefPtrInput `pulumi:"extensionRef"`
	// RequestHeaderModifier defines a schema for a filter that modifies request headers.
	//  Support: Core
	RequestHeaderModifier GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput `pulumi:"requestHeaderModifier"`
	// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
	//  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
	//  Support: Extended
	RequestMirror GRPCRouteSpecRulesFiltersRequestMirrorPtrInput `pulumi:"requestMirror"`
	// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
	//  Support: Extended
	ResponseHeaderModifier GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput `pulumi:"responseHeaderModifier"`
	// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
	//  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
	//  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
	//  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
	//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
	//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
	Type pulumi.StringInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersArgs
func (val *GRPCRouteSpecRulesFiltersArgs) Defaults() *GRPCRouteSpecRulesFiltersArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesFiltersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return i.ToGRPCRouteSpecRulesFiltersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArgs) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersOutput)
}

// GRPCRouteSpecRulesFiltersArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersArray and GRPCRouteSpecRulesFiltersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersArray{ GRPCRouteSpecRulesFiltersArgs{...} }
type GRPCRouteSpecRulesFiltersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput
	ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersArrayOutput
}

type GRPCRouteSpecRulesFiltersArray []GRPCRouteSpecRulesFiltersInput

func (GRPCRouteSpecRulesFiltersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersArray) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersArrayOutput)
}

// GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
type GRPCRouteSpecRulesFiltersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutput() GRPCRouteSpecRulesFiltersOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersOutput) ToGRPCRouteSpecRulesFiltersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersOutput {
	return o
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
func (o GRPCRouteSpecRulesFiltersOutput) ExtensionRef() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersExtensionRef { return v.ExtensionRef }).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
func (o GRPCRouteSpecRulesFiltersOutput) RequestHeaderModifier() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return v.RequestHeaderModifier
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
func (o GRPCRouteSpecRulesFiltersOutput) RequestMirror() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersRequestMirror { return v.RequestMirror }).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
func (o GRPCRouteSpecRulesFiltersOutput) ResponseHeaderModifier() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return v.ResponseHeaderModifier
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:
//   - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters.
//   - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters.
//   - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters.
//     Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
//     If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.
func (o GRPCRouteSpecRulesFiltersOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFilters) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFilters)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutput() GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) ToGRPCRouteSpecRulesFiltersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFilters {
		return vs[0].([]GRPCRouteSpecRulesFilters)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group string `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
}

// GRPCRouteSpecRulesFiltersExtensionRefInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs and GRPCRouteSpecRulesFiltersExtensionRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefInput` via:
//
//	GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
type GRPCRouteSpecRulesFiltersExtensionRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is kind of the referent. For example "HTTPRoute" or "Service".
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
}

func (GRPCRouteSpecRulesFiltersExtensionRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersExtensionRefArgs) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefOutput).ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersExtensionRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersExtensionRefArgs, GRPCRouteSpecRulesFiltersExtensionRefPtr and GRPCRouteSpecRulesFiltersExtensionRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersExtensionRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersExtensionRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersExtensionRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
	ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput
}

type grpcrouteSpecRulesFiltersExtensionRefPtrType GRPCRouteSpecRulesFiltersExtensionRefArgs

func GRPCRouteSpecRulesFiltersExtensionRefPtr(v *GRPCRouteSpecRulesFiltersExtensionRefArgs) GRPCRouteSpecRulesFiltersExtensionRefPtrInput {
	return (*grpcrouteSpecRulesFiltersExtensionRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersExtensionRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersExtensionRefPtrType) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters.
//
//	Support: Implementation-specific
//	This filter can be used multiple times within the same rule.
type GRPCRouteSpecRulesFiltersExtensionRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutput() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersExtensionRef) *GRPCRouteSpecRulesFiltersExtensionRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersExtensionRef) string { return v.Name }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersExtensionRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersExtensionRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutput() GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) ToGRPCRouteSpecRulesFiltersExtensionRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersExtensionRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersExtensionRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) GRPCRouteSpecRulesFiltersExtensionRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersExtensionRef
		return ret
	}).(GRPCRouteSpecRulesFiltersExtensionRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "HTTPRoute" or "Service".
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersExtensionRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersExtensionRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs, GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr and GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs

func GRPCRouteSpecRulesFiltersRequestHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// RequestHeaderModifier defines a schema for a filter that modifies request headers.
//
//	Support: Core
type GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestHeaderModifier) *GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) GRPCRouteSpecRulesFiltersRequestHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestHeaderModifier) []GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray and GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray []GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersRequestHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirror struct {
	// BackendRef references a resource where mirrored requests are sent.
	//  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
	//  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
	//  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
	//  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRef `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirror
func (val *GRPCRouteSpecRulesFiltersRequestMirror) Defaults() *GRPCRouteSpecRulesFiltersRequestMirror {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.BackendRef = *tmp.BackendRef.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesFiltersRequestMirrorInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs and GRPCRouteSpecRulesFiltersRequestMirrorOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorArgs struct {
	// BackendRef references a resource where mirrored requests are sent.
	//  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
	//  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
	//  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
	//  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
	//  Support: Extended for Kubernetes Service
	//  Support: Implementation-specific for any other resource
	BackendRef GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput `pulumi:"backendRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorArgs
func (val *GRPCRouteSpecRulesFiltersRequestMirrorArgs) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesFiltersRequestMirrorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorArgs, GRPCRouteSpecRulesFiltersRequestMirrorPtr and GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorPtrType GRPCRouteSpecRulesFiltersRequestMirrorArgs

func GRPCRouteSpecRulesFiltersRequestMirrorPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorArgs) GRPCRouteSpecRulesFiltersRequestMirrorPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored.
//
//	This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends.
//	Support: Extended
type GRPCRouteSpecRulesFiltersRequestMirrorOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutput() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirror {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesFiltersRequestMirrorOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirror) GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirror)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) GRPCRouteSpecRulesFiltersRequestMirror {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirror
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
func (o GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput) BackendRef() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirror) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v == nil {
			return nil
		}
		return &v.BackendRef
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRef struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
func (val *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput` via:
//
//	GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs
func (val *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) Defaults() *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	return &tmp
}
func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput).ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs, GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr and GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
	ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput
}

type grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs

func GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtr(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput {
	return (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersRequestMirrorBackendRefPtrType) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// BackendRef references a resource where mirrored requests are sent.
//
//	Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef.
//	If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation.
//	If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation.
//	In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem.
//	Support: Extended for Kubernetes Service
//	Support: Implementation-specific for any other resource
type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		return &v
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

type GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersRequestMirrorBackendRef)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) ToGRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Elem() GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
		return ret
	}).(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput)
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersRequestMirrorBackendRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifier struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove []string `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet `pulumi:"set"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs struct {
	// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: add: - name: "my-header" value: "bar,baz"
	//  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
	Add GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput `pulumi:"add"`
	// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
	//  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
	//  Config: remove: ["my-header1", "my-header3"]
	//  Output: GET /foo HTTP/1.1 my-header2: bar
	Remove pulumi.StringArrayInput `pulumi:"remove"`
	// Set overwrites the request with the given header (name, value) before the action.
	//  Input: GET /foo HTTP/1.1 my-header: foo
	//  Config: set: - name: "my-header" value: "bar"
	//  Output: GET /foo HTTP/1.1 my-header: bar
	Set GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput `pulumi:"set"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput).ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs, GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr and GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput` via:
//
//	        GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput
}

type grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs

func GRPCRouteSpecRulesFiltersResponseHeaderModifierPtr(v *GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput {
	return (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType)(v)
}

func (*grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesFiltersResponseHeaderModifierPtrType) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// ResponseHeaderModifier defines a schema for a filter that modifies response headers.
//
//	Support: Extended
type GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesFiltersResponseHeaderModifier) *GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		return &v
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string { return v.Remove }).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesFiltersResponseHeaderModifier)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Elem() GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) GRPCRouteSpecRulesFiltersResponseHeaderModifier {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesFiltersResponseHeaderModifier
		return ret
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput)
}

// Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: add: - name: "my-header" value: "bar,baz"
//	Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Add() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		if v == nil {
			return nil
		}
		return v.Add
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
//
//	Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
//	Config: remove: ["my-header1", "my-header3"]
//	Output: GET /foo HTTP/1.1 my-header2: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Remove() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []string {
		if v == nil {
			return nil
		}
		return v.Remove
	}).(pulumi.StringArrayOutput)
}

// Set overwrites the request with the given header (name, value) before the action.
//
//	Input: GET /foo HTTP/1.1 my-header: foo
//	Config: set: - name: "my-header" value: "bar"
//	Output: GET /foo HTTP/1.1 my-header: bar
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput) Set() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesFiltersResponseHeaderModifier) []GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		if v == nil {
			return nil
		}
		return v.Set
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSet struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value string `pulumi:"value"`
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...}
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs struct {
	// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
	//  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Value is the value of HTTP Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput is an input type that accepts GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray and GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput` via:
//
//	GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{ GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{...} }
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
	ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray []GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return i.ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput)
}

// HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return o
}

// Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
//
//	If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Name }).(pulumi.StringOutput)
}

// Value is the value of HTTP Header to be matched.
func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesFiltersResponseHeaderModifierSet) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)(nil)).Elem()
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput() GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) ToGRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
		return vs[0].([]GRPCRouteSpecRulesFiltersResponseHeaderModifierSet)[vs[1].(int)]
	}).(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied.
//
//	For example, the match below will match a gRPC request only if its service is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatches struct {
	// Headers specifies gRPC request header matchers. Multiple match values are ANDed together, meaning, a request MUST match all the specified headers to select the route.
	Headers []GRPCRouteSpecRulesMatchesHeaders `pulumi:"headers"`
	// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
	Method *GRPCRouteSpecRulesMatchesMethod `pulumi:"method"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatches
func (val *GRPCRouteSpecRulesMatches) Defaults() *GRPCRouteSpecRulesMatches {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.Method = tmp.Method.Defaults()

	return &tmp
}

// GRPCRouteSpecRulesMatchesInput is an input type that accepts GRPCRouteSpecRulesMatchesArgs and GRPCRouteSpecRulesMatchesOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesInput` via:
//
//	GRPCRouteSpecRulesMatchesArgs{...}
type GRPCRouteSpecRulesMatchesInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput
	ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesOutput
}

// GRPCRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied.
//
//	For example, the match below will match a gRPC request only if its service is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesArgs struct {
	// Headers specifies gRPC request header matchers. Multiple match values are ANDed together, meaning, a request MUST match all the specified headers to select the route.
	Headers GRPCRouteSpecRulesMatchesHeadersArrayInput `pulumi:"headers"`
	// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
	Method GRPCRouteSpecRulesMatchesMethodPtrInput `pulumi:"method"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesArgs
func (val *GRPCRouteSpecRulesMatchesArgs) Defaults() *GRPCRouteSpecRulesMatchesArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteSpecRulesMatchesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return i.ToGRPCRouteSpecRulesMatchesOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArgs) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCRouteSpecRulesMatchesArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesArray and GRPCRouteSpecRulesMatchesArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesArray{ GRPCRouteSpecRulesMatchesArgs{...} }
type GRPCRouteSpecRulesMatchesArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput
	ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesArrayOutput
}

type GRPCRouteSpecRulesMatchesArray []GRPCRouteSpecRulesMatchesInput

func (GRPCRouteSpecRulesMatchesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesArray) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesArrayOutput)
}

// GRPCRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied.
//
//	For example, the match below will match a gRPC request only if its service is `foo` AND it contains the `version: v1` header:
type GRPCRouteSpecRulesMatchesOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutput() GRPCRouteSpecRulesMatchesOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesOutput) ToGRPCRouteSpecRulesMatchesOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesOutput {
	return o
}

// Headers specifies gRPC request header matchers. Multiple match values are ANDed together, meaning, a request MUST match all the specified headers to select the route.
func (o GRPCRouteSpecRulesMatchesOutput) Headers() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) []GRPCRouteSpecRulesMatchesHeaders { return v.Headers }).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
func (o GRPCRouteSpecRulesMatchesOutput) Method() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatches) *GRPCRouteSpecRulesMatchesMethod { return v.Method }).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

type GRPCRouteSpecRulesMatchesArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatches)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutput() GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) ToGRPCRouteSpecRulesMatchesArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatches {
		return vs[0].([]GRPCRouteSpecRulesMatches)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request headers.
type GRPCRouteSpecRulesMatchesHeaders struct {
	// Name is the name of the gRPC Header to be matched.
	//  If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name string `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type *string `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value string `pulumi:"value"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeaders
func (val *GRPCRouteSpecRulesMatchesHeaders) Defaults() *GRPCRouteSpecRulesMatchesHeaders {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// GRPCRouteSpecRulesMatchesHeadersInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArgs and GRPCRouteSpecRulesMatchesHeadersOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArgs{...}
type GRPCRouteSpecRulesMatchesHeadersInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput
	ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersOutput
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request headers.
type GRPCRouteSpecRulesMatchesHeadersArgs struct {
	// Name is the name of the gRPC Header to be matched.
	//  If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
	Name pulumi.StringInput `pulumi:"name"`
	// Type specifies how to match against the value of the header.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Value is the value of the gRPC Header to be matched.
	Value pulumi.StringInput `pulumi:"value"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeadersArgs
func (val *GRPCRouteSpecRulesMatchesHeadersArgs) Defaults() *GRPCRouteSpecRulesMatchesHeadersArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (GRPCRouteSpecRulesMatchesHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArgs) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// GRPCRouteSpecRulesMatchesHeadersArrayInput is an input type that accepts GRPCRouteSpecRulesMatchesHeadersArray and GRPCRouteSpecRulesMatchesHeadersArrayOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesHeadersArrayInput` via:
//
//	GRPCRouteSpecRulesMatchesHeadersArray{ GRPCRouteSpecRulesMatchesHeadersArgs{...} }
type GRPCRouteSpecRulesMatchesHeadersArrayInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput
	ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput
}

type GRPCRouteSpecRulesMatchesHeadersArray []GRPCRouteSpecRulesMatchesHeadersInput

func (GRPCRouteSpecRulesMatchesHeadersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return i.ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesHeadersArray) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesHeadersArrayOutput)
}

// GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request headers.
type GRPCRouteSpecRulesMatchesHeadersOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutput() GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersOutput) ToGRPCRouteSpecRulesMatchesHeadersOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersOutput {
	return o
}

// Name is the name of the gRPC Header to be matched.
//
//	If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) string { return v.Name }).(pulumi.StringOutput)
}

// Type specifies how to match against the value of the header.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Value is the value of the gRPC Header to be matched.
func (o GRPCRouteSpecRulesMatchesHeadersOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesHeaders) string { return v.Value }).(pulumi.StringOutput)
}

type GRPCRouteSpecRulesMatchesHeadersArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesHeadersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteSpecRulesMatchesHeaders)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutput() GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) ToGRPCRouteSpecRulesMatchesHeadersArrayOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesHeadersArrayOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesHeadersArrayOutput) Index(i pulumi.IntInput) GRPCRouteSpecRulesMatchesHeadersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteSpecRulesMatchesHeaders {
		return vs[0].([]GRPCRouteSpecRulesMatchesHeaders)[vs[1].(int)]
	}).(GRPCRouteSpecRulesMatchesHeadersOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethod struct {
	// Value of the method to match against. If left empty or omitted, will match all services.
	//  At least one of Service and Method MUST be a non-empty string.
	Method *string `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will match any service.
	//  At least one of Service and Method MUST be a non-empty string.
	Service *string `pulumi:"service"`
	// Type specifies how to match against the service and/or method. Support: Core (Exact with service and method specified)
	//  Support: Implementation-specific (Exact with method specified but no service specified)
	//  Support: Implementation-specific (RegularExpression)
	Type *string `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethod
func (val *GRPCRouteSpecRulesMatchesMethod) Defaults() *GRPCRouteSpecRulesMatchesMethod {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		type_ := "Exact"
		tmp.Type = &type_
	}
	return &tmp
}

// GRPCRouteSpecRulesMatchesMethodInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs and GRPCRouteSpecRulesMatchesMethodOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodInput` via:
//
//	GRPCRouteSpecRulesMatchesMethodArgs{...}
type GRPCRouteSpecRulesMatchesMethodInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput
	ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodOutput
}

// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodArgs struct {
	// Value of the method to match against. If left empty or omitted, will match all services.
	//  At least one of Service and Method MUST be a non-empty string.
	Method pulumi.StringPtrInput `pulumi:"method"`
	// Value of the service to match against. If left empty or omitted, will match any service.
	//  At least one of Service and Method MUST be a non-empty string.
	Service pulumi.StringPtrInput `pulumi:"service"`
	// Type specifies how to match against the service and/or method. Support: Core (Exact with service and method specified)
	//  Support: Implementation-specific (Exact with method specified but no service specified)
	//  Support: Implementation-specific (RegularExpression)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

// Defaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethodArgs
func (val *GRPCRouteSpecRulesMatchesMethodArgs) Defaults() *GRPCRouteSpecRulesMatchesMethodArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Type == nil {
		tmp.Type = pulumi.StringPtr("Exact")
	}
	return &tmp
}
func (GRPCRouteSpecRulesMatchesMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput)
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i GRPCRouteSpecRulesMatchesMethodArgs) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodOutput).ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx)
}

// GRPCRouteSpecRulesMatchesMethodPtrInput is an input type that accepts GRPCRouteSpecRulesMatchesMethodArgs, GRPCRouteSpecRulesMatchesMethodPtr and GRPCRouteSpecRulesMatchesMethodPtrOutput values.
// You can construct a concrete instance of `GRPCRouteSpecRulesMatchesMethodPtrInput` via:
//
//	        GRPCRouteSpecRulesMatchesMethodArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteSpecRulesMatchesMethodPtrInput interface {
	pulumi.Input

	ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput
	ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput
}

type grpcrouteSpecRulesMatchesMethodPtrType GRPCRouteSpecRulesMatchesMethodArgs

func GRPCRouteSpecRulesMatchesMethodPtr(v *GRPCRouteSpecRulesMatchesMethodArgs) GRPCRouteSpecRulesMatchesMethodPtrInput {
	return (*grpcrouteSpecRulesMatchesMethodPtrType)(v)
}

func (*grpcrouteSpecRulesMatchesMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return i.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (i *grpcrouteSpecRulesMatchesMethodPtrType) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
type GRPCRouteSpecRulesMatchesMethodOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutput() GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(context.Background())
}

func (o GRPCRouteSpecRulesMatchesMethodOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteSpecRulesMatchesMethod) *GRPCRouteSpecRulesMatchesMethod {
		return &v
	}).(GRPCRouteSpecRulesMatchesMethodPtrOutput)
}

// Value of the method to match against. If left empty or omitted, will match all services.
//
//	At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Method }).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will match any service.
//
//	At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Service }).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method. Support: Core (Exact with service and method specified)
//
//	Support: Implementation-specific (Exact with method specified but no service specified)
//	Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteSpecRulesMatchesMethod) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type GRPCRouteSpecRulesMatchesMethodPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteSpecRulesMatchesMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteSpecRulesMatchesMethod)(nil)).Elem()
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutput() GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) ToGRPCRouteSpecRulesMatchesMethodPtrOutputWithContext(ctx context.Context) GRPCRouteSpecRulesMatchesMethodPtrOutput {
	return o
}

func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Elem() GRPCRouteSpecRulesMatchesMethodOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) GRPCRouteSpecRulesMatchesMethod {
		if v != nil {
			return *v
		}
		var ret GRPCRouteSpecRulesMatchesMethod
		return ret
	}).(GRPCRouteSpecRulesMatchesMethodOutput)
}

// Value of the method to match against. If left empty or omitted, will match all services.
//
//	At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Method() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.StringPtrOutput)
}

// Value of the service to match against. If left empty or omitted, will match any service.
//
//	At least one of Service and Method MUST be a non-empty string.
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Service
	}).(pulumi.StringPtrOutput)
}

// Type specifies how to match against the service and/or method. Support: Core (Exact with service and method specified)
//
//	Support: Implementation-specific (Exact with method specified but no service specified)
//	Support: Implementation-specific (RegularExpression)
func (o GRPCRouteSpecRulesMatchesMethodPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GRPCRouteSpecRulesMatchesMethod) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents []GRPCRouteStatusParents `pulumi:"parents"`
}

// GRPCRouteStatusInput is an input type that accepts GRPCRouteStatusArgs and GRPCRouteStatusOutput values.
// You can construct a concrete instance of `GRPCRouteStatusInput` via:
//
//	GRPCRouteStatusArgs{...}
type GRPCRouteStatusInput interface {
	pulumi.Input

	ToGRPCRouteStatusOutput() GRPCRouteStatusOutput
	ToGRPCRouteStatusOutputWithContext(context.Context) GRPCRouteStatusOutput
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents GRPCRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (GRPCRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return i.ToGRPCRouteStatusOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput)
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i GRPCRouteStatusArgs) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusOutput).ToGRPCRouteStatusPtrOutputWithContext(ctx)
}

// GRPCRouteStatusPtrInput is an input type that accepts GRPCRouteStatusArgs, GRPCRouteStatusPtr and GRPCRouteStatusPtrOutput values.
// You can construct a concrete instance of `GRPCRouteStatusPtrInput` via:
//
//	        GRPCRouteStatusArgs{...}
//
//	or:
//
//	        nil
type GRPCRouteStatusPtrInput interface {
	pulumi.Input

	ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput
	ToGRPCRouteStatusPtrOutputWithContext(context.Context) GRPCRouteStatusPtrOutput
}

type grpcrouteStatusPtrType GRPCRouteStatusArgs

func GRPCRouteStatusPtr(v *GRPCRouteStatusArgs) GRPCRouteStatusPtrInput {
	return (*grpcrouteStatusPtrType)(v)
}

func (*grpcrouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return i.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (i *grpcrouteStatusPtrType) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusPtrOutput)
}

// Status defines the current state of GRPCRoute.
type GRPCRouteStatusOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutput() GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusOutputWithContext(ctx context.Context) GRPCRouteStatusOutput {
	return o
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o.ToGRPCRouteStatusPtrOutputWithContext(context.Background())
}

func (o GRPCRouteStatusOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GRPCRouteStatus) *GRPCRouteStatus {
		return &v
	}).(GRPCRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o GRPCRouteStatusOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatus) []GRPCRouteStatusParents { return v.Parents }).(GRPCRouteStatusParentsArrayOutput)
}

type GRPCRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GRPCRouteStatus)(nil)).Elem()
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutput() GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) ToGRPCRouteStatusPtrOutputWithContext(ctx context.Context) GRPCRouteStatusPtrOutput {
	return o
}

func (o GRPCRouteStatusPtrOutput) Elem() GRPCRouteStatusOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) GRPCRouteStatus {
		if v != nil {
			return *v
		}
		var ret GRPCRouteStatus
		return ret
	}).(GRPCRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o GRPCRouteStatusPtrOutput) Parents() GRPCRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *GRPCRouteStatus) []GRPCRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type GRPCRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions []GRPCRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef GRPCRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParents
func (val *GRPCRouteStatusParents) Defaults() *GRPCRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// GRPCRouteStatusParentsInput is an input type that accepts GRPCRouteStatusParentsArgs and GRPCRouteStatusParentsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsInput` via:
//
//	GRPCRouteStatusParentsArgs{...}
type GRPCRouteStatusParentsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput
	ToGRPCRouteStatusParentsOutputWithContext(context.Context) GRPCRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type GRPCRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions GRPCRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef GRPCRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsArgs
func (val *GRPCRouteStatusParentsArgs) Defaults() *GRPCRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (GRPCRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return i.ToGRPCRouteStatusParentsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArgs) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsOutput)
}

// GRPCRouteStatusParentsArrayInput is an input type that accepts GRPCRouteStatusParentsArray and GRPCRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsArrayInput` via:
//
//	GRPCRouteStatusParentsArray{ GRPCRouteStatusParentsArgs{...} }
type GRPCRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput
	ToGRPCRouteStatusParentsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsArrayOutput
}

type GRPCRouteStatusParentsArray []GRPCRouteStatusParentsInput

func (GRPCRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return i.ToGRPCRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsArray) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type GRPCRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutput() GRPCRouteStatusParentsOutput {
	return o
}

func (o GRPCRouteStatusParentsOutput) ToGRPCRouteStatusParentsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
//
//	If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
//	A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
//	There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
//	* The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
func (o GRPCRouteStatusParentsOutput) Conditions() GRPCRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) []GRPCRouteStatusParentsConditions { return v.Conditions }).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
//
//	Example: "example.net/gateway-controller".
//	The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//	Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
func (o GRPCRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
func (o GRPCRouteStatusParentsOutput) ParentRef() GRPCRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v GRPCRouteStatusParents) GRPCRouteStatusParentsParentRef { return v.ParentRef }).(GRPCRouteStatusParentsParentRefOutput)
}

type GRPCRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParents)(nil)).Elem()
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutput() GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) ToGRPCRouteStatusParentsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParents {
		return vs[0].([]GRPCRouteStatusParents)[vs[1].(int)]
	}).(GRPCRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type GRPCRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// GRPCRouteStatusParentsConditionsInput is an input type that accepts GRPCRouteStatusParentsConditionsArgs and GRPCRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsInput` via:
//
//	GRPCRouteStatusParentsConditionsArgs{...}
type GRPCRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput
	ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type GRPCRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (GRPCRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return i.ToGRPCRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArgs) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsOutput)
}

// GRPCRouteStatusParentsConditionsArrayInput is an input type that accepts GRPCRouteStatusParentsConditionsArray and GRPCRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsConditionsArrayInput` via:
//
//	GRPCRouteStatusParentsConditionsArray{ GRPCRouteStatusParentsConditionsArgs{...} }
type GRPCRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput
	ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Context) GRPCRouteStatusParentsConditionsArrayOutput
}

type GRPCRouteStatusParentsConditionsArray []GRPCRouteStatusParentsConditionsInput

func (GRPCRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return i.ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsConditionsArray) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type GRPCRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutput() GRPCRouteStatusParentsConditionsOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsOutput) ToGRPCRouteStatusParentsConditionsOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o GRPCRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition. This may be an empty string.
func (o GRPCRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
func (o GRPCRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
func (o GRPCRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o GRPCRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o GRPCRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GRPCRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GRPCRouteStatusParentsConditions)(nil)).Elem()
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutput() GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) ToGRPCRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) GRPCRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o GRPCRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) GRPCRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GRPCRouteStatusParentsConditions {
		return vs[0].([]GRPCRouteStatusParentsConditions)[vs[1].(int)]
	}).(GRPCRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRef struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsParentRef
func (val *GRPCRouteStatusParentsParentRef) Defaults() *GRPCRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// GRPCRouteStatusParentsParentRefInput is an input type that accepts GRPCRouteStatusParentsParentRefArgs and GRPCRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `GRPCRouteStatusParentsParentRefInput` via:
//
//	GRPCRouteStatusParentsParentRefArgs{...}
type GRPCRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput
	ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Context) GRPCRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for GRPCRouteStatusParentsParentRefArgs
func (val *GRPCRouteStatusParentsParentRefArgs) Defaults() *GRPCRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (GRPCRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return i.ToGRPCRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i GRPCRouteStatusParentsParentRefArgs) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GRPCRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type GRPCRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (GRPCRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GRPCRouteStatusParentsParentRef)(nil)).Elem()
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutput() GRPCRouteStatusParentsParentRefOutput {
	return o
}

func (o GRPCRouteStatusParentsParentRefOutput) ToGRPCRouteStatusParentsParentRefOutputWithContext(ctx context.Context) GRPCRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o GRPCRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o GRPCRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o GRPCRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GRPCRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

// ReferenceGrant identifies kinds of resources in other namespaces that are trusted to reference the specified kinds of resources in the same namespace as the policy.
//
//	Each ReferenceGrant can be used to represent a unique trust relationship. Additional Reference Grants can be used to add to the set of trusted sources of inbound references for the namespace they are defined within.
//	A ReferenceGrant is required for all cross-namespace references in Gateway API (with the exception of cross-namespace Route-Gateway attachment, which is governed by the AllowedRoutes configuration on the Gateway, and cross-namespace Service ParentRefs on a "consumer" mesh Route, which defines routing rules applicable only to workloads in the Route namespace). ReferenceGrants allowing a reference from a Route to a Service are only applicable to BackendRefs.
//	ReferenceGrant is a form of runtime verification allowing users to assert which cross-namespace object references are permitted. Implementations that support ReferenceGrant MUST NOT permit cross-namespace references which have no grant, and MUST respond to the removal of a grant by revoking the access that the grant allowed.
type ReferenceGrantType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of ReferenceGrant.
	Spec *ReferenceGrantSpec `pulumi:"spec"`
}

type ReferenceGrantMetadata struct {
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpec struct {
	// From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR.
	//  Support: Core
	From []ReferenceGrantSpecFrom `pulumi:"from"`
	// To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR.
	//  Support: Core
	To []ReferenceGrantSpecTo `pulumi:"to"`
}

// ReferenceGrantSpecInput is an input type that accepts ReferenceGrantSpecArgs and ReferenceGrantSpecOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecInput` via:
//
//	ReferenceGrantSpecArgs{...}
type ReferenceGrantSpecInput interface {
	pulumi.Input

	ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput
	ToReferenceGrantSpecOutputWithContext(context.Context) ReferenceGrantSpecOutput
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecArgs struct {
	// From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR.
	//  Support: Core
	From ReferenceGrantSpecFromArrayInput `pulumi:"from"`
	// To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR.
	//  Support: Core
	To ReferenceGrantSpecToArrayInput `pulumi:"to"`
}

func (ReferenceGrantSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpec)(nil)).Elem()
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput {
	return i.ToReferenceGrantSpecOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecOutputWithContext(ctx context.Context) ReferenceGrantSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecOutput)
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return i.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecArgs) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecOutput).ToReferenceGrantSpecPtrOutputWithContext(ctx)
}

// ReferenceGrantSpecPtrInput is an input type that accepts ReferenceGrantSpecArgs, ReferenceGrantSpecPtr and ReferenceGrantSpecPtrOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecPtrInput` via:
//
//	        ReferenceGrantSpecArgs{...}
//
//	or:
//
//	        nil
type ReferenceGrantSpecPtrInput interface {
	pulumi.Input

	ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput
	ToReferenceGrantSpecPtrOutputWithContext(context.Context) ReferenceGrantSpecPtrOutput
}

type referenceGrantSpecPtrType ReferenceGrantSpecArgs

func ReferenceGrantSpecPtr(v *ReferenceGrantSpecArgs) ReferenceGrantSpecPtrInput {
	return (*referenceGrantSpecPtrType)(v)
}

func (*referenceGrantSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpec)(nil)).Elem()
}

func (i *referenceGrantSpecPtrType) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return i.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (i *referenceGrantSpecPtrType) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecPtrOutput)
}

// Spec defines the desired state of ReferenceGrant.
type ReferenceGrantSpecOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpec)(nil)).Elem()
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecOutput() ReferenceGrantSpecOutput {
	return o
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecOutputWithContext(ctx context.Context) ReferenceGrantSpecOutput {
	return o
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return o.ToReferenceGrantSpecPtrOutputWithContext(context.Background())
}

func (o ReferenceGrantSpecOutput) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ReferenceGrantSpec) *ReferenceGrantSpec {
		return &v
	}).(ReferenceGrantSpecPtrOutput)
}

// From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR.
//
//	Support: Core
func (o ReferenceGrantSpecOutput) From() ReferenceGrantSpecFromArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpec) []ReferenceGrantSpecFrom { return v.From }).(ReferenceGrantSpecFromArrayOutput)
}

// To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR.
//
//	Support: Core
func (o ReferenceGrantSpecOutput) To() ReferenceGrantSpecToArrayOutput {
	return o.ApplyT(func(v ReferenceGrantSpec) []ReferenceGrantSpecTo { return v.To }).(ReferenceGrantSpecToArrayOutput)
}

type ReferenceGrantSpecPtrOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReferenceGrantSpec)(nil)).Elem()
}

func (o ReferenceGrantSpecPtrOutput) ToReferenceGrantSpecPtrOutput() ReferenceGrantSpecPtrOutput {
	return o
}

func (o ReferenceGrantSpecPtrOutput) ToReferenceGrantSpecPtrOutputWithContext(ctx context.Context) ReferenceGrantSpecPtrOutput {
	return o
}

func (o ReferenceGrantSpecPtrOutput) Elem() ReferenceGrantSpecOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) ReferenceGrantSpec {
		if v != nil {
			return *v
		}
		var ret ReferenceGrantSpec
		return ret
	}).(ReferenceGrantSpecOutput)
}

// From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR.
//
//	Support: Core
func (o ReferenceGrantSpecPtrOutput) From() ReferenceGrantSpecFromArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) []ReferenceGrantSpecFrom {
		if v == nil {
			return nil
		}
		return v.From
	}).(ReferenceGrantSpecFromArrayOutput)
}

// To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR.
//
//	Support: Core
func (o ReferenceGrantSpecPtrOutput) To() ReferenceGrantSpecToArrayOutput {
	return o.ApplyT(func(v *ReferenceGrantSpec) []ReferenceGrantSpecTo {
		if v == nil {
			return nil
		}
		return v.To
	}).(ReferenceGrantSpecToArrayOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFrom struct {
	// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
	//  Support: Core
	Group string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field.
	//  When used to permit a SecretObjectReference:
	//  * Gateway
	//     When used to permit a BackendObjectReference:
	//  * GRPCRoute * HTTPRoute * TCPRoute * TLSRoute * UDPRoute
	Kind string `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//  Support: Core
	Namespace string `pulumi:"namespace"`
}

// ReferenceGrantSpecFromInput is an input type that accepts ReferenceGrantSpecFromArgs and ReferenceGrantSpecFromOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromInput` via:
//
//	ReferenceGrantSpecFromArgs{...}
type ReferenceGrantSpecFromInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput
	ToReferenceGrantSpecFromOutputWithContext(context.Context) ReferenceGrantSpecFromOutput
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromArgs struct {
	// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
	//  Support: Core
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field.
	//  When used to permit a SecretObjectReference:
	//  * Gateway
	//     When used to permit a BackendObjectReference:
	//  * GRPCRoute * HTTPRoute * TCPRoute * TLSRoute * UDPRoute
	Kind pulumi.StringInput `pulumi:"kind"`
	// Namespace is the namespace of the referent.
	//  Support: Core
	Namespace pulumi.StringInput `pulumi:"namespace"`
}

func (ReferenceGrantSpecFromArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFrom)(nil)).Elem()
}

func (i ReferenceGrantSpecFromArgs) ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput {
	return i.ToReferenceGrantSpecFromOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromArgs) ToReferenceGrantSpecFromOutputWithContext(ctx context.Context) ReferenceGrantSpecFromOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromOutput)
}

// ReferenceGrantSpecFromArrayInput is an input type that accepts ReferenceGrantSpecFromArray and ReferenceGrantSpecFromArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecFromArrayInput` via:
//
//	ReferenceGrantSpecFromArray{ ReferenceGrantSpecFromArgs{...} }
type ReferenceGrantSpecFromArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput
	ToReferenceGrantSpecFromArrayOutputWithContext(context.Context) ReferenceGrantSpecFromArrayOutput
}

type ReferenceGrantSpecFromArray []ReferenceGrantSpecFromInput

func (ReferenceGrantSpecFromArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFrom)(nil)).Elem()
}

func (i ReferenceGrantSpecFromArray) ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput {
	return i.ToReferenceGrantSpecFromArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecFromArray) ToReferenceGrantSpecFromArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecFromArrayOutput)
}

// ReferenceGrantFrom describes trusted namespaces and kinds.
type ReferenceGrantSpecFromOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecFrom)(nil)).Elem()
}

func (o ReferenceGrantSpecFromOutput) ToReferenceGrantSpecFromOutput() ReferenceGrantSpecFromOutput {
	return o
}

func (o ReferenceGrantSpecFromOutput) ToReferenceGrantSpecFromOutputWithContext(ctx context.Context) ReferenceGrantSpecFromOutput {
	return o
}

// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
//
//	Support: Core
func (o ReferenceGrantSpecFromOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field.
//
//	When used to permit a SecretObjectReference:
//	* Gateway
//	   When used to permit a BackendObjectReference:
//	* GRPCRoute * HTTPRoute * TCPRoute * TLSRoute * UDPRoute
func (o ReferenceGrantSpecFromOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) string { return v.Kind }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent.
//
//	Support: Core
func (o ReferenceGrantSpecFromOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v ReferenceGrantSpecFrom) string { return v.Namespace }).(pulumi.StringOutput)
}

type ReferenceGrantSpecFromArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecFromArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecFrom)(nil)).Elem()
}

func (o ReferenceGrantSpecFromArrayOutput) ToReferenceGrantSpecFromArrayOutput() ReferenceGrantSpecFromArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromArrayOutput) ToReferenceGrantSpecFromArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecFromArrayOutput {
	return o
}

func (o ReferenceGrantSpecFromArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecFromOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecFrom {
		return vs[0].([]ReferenceGrantSpecFrom)[vs[1].(int)]
	}).(ReferenceGrantSpecFromOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the references.
type ReferenceGrantSpecTo struct {
	// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
	//  Support: Core
	Group string `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field:
	//  * Secret when used to permit a SecretObjectReference * Service when used to permit a BackendObjectReference
	Kind string `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy refers to all resources of the specified Group and Kind in the local namespace.
	Name *string `pulumi:"name"`
}

// ReferenceGrantSpecToInput is an input type that accepts ReferenceGrantSpecToArgs and ReferenceGrantSpecToOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToInput` via:
//
//	ReferenceGrantSpecToArgs{...}
type ReferenceGrantSpecToInput interface {
	pulumi.Input

	ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput
	ToReferenceGrantSpecToOutputWithContext(context.Context) ReferenceGrantSpecToOutput
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the references.
type ReferenceGrantSpecToArgs struct {
	// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
	//  Support: Core
	Group pulumi.StringInput `pulumi:"group"`
	// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field:
	//  * Secret when used to permit a SecretObjectReference * Service when used to permit a BackendObjectReference
	Kind pulumi.StringInput `pulumi:"kind"`
	// Name is the name of the referent. When unspecified, this policy refers to all resources of the specified Group and Kind in the local namespace.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ReferenceGrantSpecToArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecTo)(nil)).Elem()
}

func (i ReferenceGrantSpecToArgs) ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput {
	return i.ToReferenceGrantSpecToOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToArgs) ToReferenceGrantSpecToOutputWithContext(ctx context.Context) ReferenceGrantSpecToOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToOutput)
}

// ReferenceGrantSpecToArrayInput is an input type that accepts ReferenceGrantSpecToArray and ReferenceGrantSpecToArrayOutput values.
// You can construct a concrete instance of `ReferenceGrantSpecToArrayInput` via:
//
//	ReferenceGrantSpecToArray{ ReferenceGrantSpecToArgs{...} }
type ReferenceGrantSpecToArrayInput interface {
	pulumi.Input

	ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput
	ToReferenceGrantSpecToArrayOutputWithContext(context.Context) ReferenceGrantSpecToArrayOutput
}

type ReferenceGrantSpecToArray []ReferenceGrantSpecToInput

func (ReferenceGrantSpecToArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecTo)(nil)).Elem()
}

func (i ReferenceGrantSpecToArray) ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput {
	return i.ToReferenceGrantSpecToArrayOutputWithContext(context.Background())
}

func (i ReferenceGrantSpecToArray) ToReferenceGrantSpecToArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReferenceGrantSpecToArrayOutput)
}

// ReferenceGrantTo describes what Kinds are allowed as targets of the references.
type ReferenceGrantSpecToOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReferenceGrantSpecTo)(nil)).Elem()
}

func (o ReferenceGrantSpecToOutput) ToReferenceGrantSpecToOutput() ReferenceGrantSpecToOutput {
	return o
}

func (o ReferenceGrantSpecToOutput) ToReferenceGrantSpecToOutputWithContext(ctx context.Context) ReferenceGrantSpecToOutput {
	return o
}

// Group is the group of the referent. When empty, the Kubernetes core API group is inferred.
//
//	Support: Core
func (o ReferenceGrantSpecToOutput) Group() pulumi.StringOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) string { return v.Group }).(pulumi.StringOutput)
}

// Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field:
//   - Secret when used to permit a SecretObjectReference * Service when used to permit a BackendObjectReference
func (o ReferenceGrantSpecToOutput) Kind() pulumi.StringOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) string { return v.Kind }).(pulumi.StringOutput)
}

// Name is the name of the referent. When unspecified, this policy refers to all resources of the specified Group and Kind in the local namespace.
func (o ReferenceGrantSpecToOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ReferenceGrantSpecTo) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ReferenceGrantSpecToArrayOutput struct{ *pulumi.OutputState }

func (ReferenceGrantSpecToArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReferenceGrantSpecTo)(nil)).Elem()
}

func (o ReferenceGrantSpecToArrayOutput) ToReferenceGrantSpecToArrayOutput() ReferenceGrantSpecToArrayOutput {
	return o
}

func (o ReferenceGrantSpecToArrayOutput) ToReferenceGrantSpecToArrayOutputWithContext(ctx context.Context) ReferenceGrantSpecToArrayOutput {
	return o
}

func (o ReferenceGrantSpecToArrayOutput) Index(i pulumi.IntInput) ReferenceGrantSpecToOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReferenceGrantSpecTo {
		return vs[0].([]ReferenceGrantSpecTo)[vs[1].(int)]
	}).(ReferenceGrantSpecToOutput)
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway listener, it can be used to forward connections on the port specified by the listener to a set of backends specified by the TCPRoute.
type TCPRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of TCPRoute.
	Spec TCPRouteSpec `pulumi:"spec"`
	// Status defines the current state of TCPRoute.
	Status *TCPRouteStatus `pulumi:"status"`
}

type TCPRouteMetadata struct {
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpec struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs []TCPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules []TCPRouteSpecRules `pulumi:"rules"`
}

// TCPRouteSpecInput is an input type that accepts TCPRouteSpecArgs and TCPRouteSpecOutput values.
// You can construct a concrete instance of `TCPRouteSpecInput` via:
//
//	TCPRouteSpecArgs{...}
type TCPRouteSpecInput interface {
	pulumi.Input

	ToTCPRouteSpecOutput() TCPRouteSpecOutput
	ToTCPRouteSpecOutputWithContext(context.Context) TCPRouteSpecOutput
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs TCPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules TCPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (TCPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpec)(nil)).Elem()
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecOutput() TCPRouteSpecOutput {
	return i.ToTCPRouteSpecOutputWithContext(context.Background())
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecOutputWithContext(ctx context.Context) TCPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecOutput)
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return i.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecOutput).ToTCPRouteSpecPtrOutputWithContext(ctx)
}

// TCPRouteSpecPtrInput is an input type that accepts TCPRouteSpecArgs, TCPRouteSpecPtr and TCPRouteSpecPtrOutput values.
// You can construct a concrete instance of `TCPRouteSpecPtrInput` via:
//
//	        TCPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type TCPRouteSpecPtrInput interface {
	pulumi.Input

	ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput
	ToTCPRouteSpecPtrOutputWithContext(context.Context) TCPRouteSpecPtrOutput
}

type tcprouteSpecPtrType TCPRouteSpecArgs

func TCPRouteSpecPtr(v *TCPRouteSpecArgs) TCPRouteSpecPtrInput {
	return (*tcprouteSpecPtrType)(v)
}

func (*tcprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpec)(nil)).Elem()
}

func (i *tcprouteSpecPtrType) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return i.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *tcprouteSpecPtrType) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecPtrOutput)
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpec)(nil)).Elem()
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecOutput() TCPRouteSpecOutput {
	return o
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecOutputWithContext(ctx context.Context) TCPRouteSpecOutput {
	return o
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return o.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteSpec) *TCPRouteSpec {
		return &v
	}).(TCPRouteSpecPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o TCPRouteSpecOutput) ParentRefs() TCPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v TCPRouteSpec) []TCPRouteSpecParentRefs { return v.ParentRefs }).(TCPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecOutput) Rules() TCPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v TCPRouteSpec) []TCPRouteSpecRules { return v.Rules }).(TCPRouteSpecRulesArrayOutput)
}

type TCPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpec)(nil)).Elem()
}

func (o TCPRouteSpecPtrOutput) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return o
}

func (o TCPRouteSpecPtrOutput) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return o
}

func (o TCPRouteSpecPtrOutput) Elem() TCPRouteSpecOutput {
	return o.ApplyT(func(v *TCPRouteSpec) TCPRouteSpec {
		if v != nil {
			return *v
		}
		var ret TCPRouteSpec
		return ret
	}).(TCPRouteSpecOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o TCPRouteSpecPtrOutput) ParentRefs() TCPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpec) []TCPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TCPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecPtrOutput) Rules() TCPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpec) []TCPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TCPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TCPRouteSpecParentRefs
func (val *TCPRouteSpecParentRefs) Defaults() *TCPRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// TCPRouteSpecParentRefsInput is an input type that accepts TCPRouteSpecParentRefsArgs and TCPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsInput` via:
//
//	TCPRouteSpecParentRefsArgs{...}
type TCPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput
	ToTCPRouteSpecParentRefsOutputWithContext(context.Context) TCPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TCPRouteSpecParentRefsArgs
func (val *TCPRouteSpecParentRefsArgs) Defaults() *TCPRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (TCPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefs)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsArgs) ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput {
	return i.ToTCPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsArgs) ToTCPRouteSpecParentRefsOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsOutput)
}

// TCPRouteSpecParentRefsArrayInput is an input type that accepts TCPRouteSpecParentRefsArray and TCPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsArrayInput` via:
//
//	TCPRouteSpecParentRefsArray{ TCPRouteSpecParentRefsArgs{...} }
type TCPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput
	ToTCPRouteSpecParentRefsArrayOutputWithContext(context.Context) TCPRouteSpecParentRefsArrayOutput
}

type TCPRouteSpecParentRefsArray []TCPRouteSpecParentRefsInput

func (TCPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefs)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsArray) ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput {
	return i.ToTCPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsArray) ToTCPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefs)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsOutput) ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput {
	return o
}

func (o TCPRouteSpecParentRefsOutput) ToTCPRouteSpecParentRefsOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o TCPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o TCPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o TCPRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o TCPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o TCPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o TCPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TCPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefs)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsArrayOutput) ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsArrayOutput) ToTCPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecParentRefs {
		return vs[0].([]TCPRouteSpecParentRefs)[vs[1].(int)]
	}).(TCPRouteSpecParentRefsOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Connection rejections must respect weight; if an invalid backend is requested to have 80% of connections, then 80% of connections must be rejected instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs []TCPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
}

// TCPRouteSpecRulesInput is an input type that accepts TCPRouteSpecRulesArgs and TCPRouteSpecRulesOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesInput` via:
//
//	TCPRouteSpecRulesArgs{...}
type TCPRouteSpecRulesInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput
	ToTCPRouteSpecRulesOutputWithContext(context.Context) TCPRouteSpecRulesOutput
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Connection rejections must respect weight; if an invalid backend is requested to have 80% of connections, then 80% of connections must be rejected instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs TCPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
}

func (TCPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRules)(nil)).Elem()
}

func (i TCPRouteSpecRulesArgs) ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput {
	return i.ToTCPRouteSpecRulesOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesArgs) ToTCPRouteSpecRulesOutputWithContext(ctx context.Context) TCPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesOutput)
}

// TCPRouteSpecRulesArrayInput is an input type that accepts TCPRouteSpecRulesArray and TCPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesArrayInput` via:
//
//	TCPRouteSpecRulesArray{ TCPRouteSpecRulesArgs{...} }
type TCPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput
	ToTCPRouteSpecRulesArrayOutputWithContext(context.Context) TCPRouteSpecRulesArrayOutput
}

type TCPRouteSpecRulesArray []TCPRouteSpecRulesInput

func (TCPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRules)(nil)).Elem()
}

func (i TCPRouteSpecRulesArray) ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput {
	return i.ToTCPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesArray) ToTCPRouteSpecRulesArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesArrayOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRules)(nil)).Elem()
}

func (o TCPRouteSpecRulesOutput) ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput {
	return o
}

func (o TCPRouteSpecRulesOutput) ToTCPRouteSpecRulesOutputWithContext(ctx context.Context) TCPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Connection rejections must respect weight; if an invalid backend is requested to have 80% of connections, then 80% of connections must be rejected instead.
//
//	Support: Core for Kubernetes Service
//	Support: Extended for Kubernetes ServiceImport
//	Support: Implementation-specific for any other resource
//	Support for weight: Extended
func (o TCPRouteSpecRulesOutput) BackendRefs() TCPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v TCPRouteSpecRules) []TCPRouteSpecRulesBackendRefs { return v.BackendRefs }).(TCPRouteSpecRulesBackendRefsArrayOutput)
}

type TCPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRules)(nil)).Elem()
}

func (o TCPRouteSpecRulesArrayOutput) ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput {
	return o
}

func (o TCPRouteSpecRulesArrayOutput) ToTCPRouteSpecRulesArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesArrayOutput {
	return o
}

func (o TCPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRules {
		return vs[0].([]TCPRouteSpecRules)[vs[1].(int)]
	}).(TCPRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for TCPRouteSpecRulesBackendRefs
func (val *TCPRouteSpecRulesBackendRefs) Defaults() *TCPRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// TCPRouteSpecRulesBackendRefsInput is an input type that accepts TCPRouteSpecRulesBackendRefsArgs and TCPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsInput` via:
//
//	TCPRouteSpecRulesBackendRefsArgs{...}
type TCPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput
	ToTCPRouteSpecRulesBackendRefsOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for TCPRouteSpecRulesBackendRefsArgs
func (val *TCPRouteSpecRulesBackendRefsArgs) Defaults() *TCPRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (TCPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsArgs) ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput {
	return i.ToTCPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsArgs) ToTCPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsOutput)
}

// TCPRouteSpecRulesBackendRefsArrayInput is an input type that accepts TCPRouteSpecRulesBackendRefsArray and TCPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsArrayInput` via:
//
//	TCPRouteSpecRulesBackendRefsArray{ TCPRouteSpecRulesBackendRefsArgs{...} }
type TCPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput
	ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsArrayOutput
}

type TCPRouteSpecRulesBackendRefsArray []TCPRouteSpecRulesBackendRefsInput

func (TCPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsArray) ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsArray) ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsOutput) ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsOutput) ToTCPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o TCPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o TCPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TCPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o TCPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o TCPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
//
//	If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
//	Support for this field varies based on the context where used.
func (o TCPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TCPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRulesBackendRefs {
		return vs[0].([]TCPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(TCPRouteSpecRulesBackendRefsOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents []TCPRouteStatusParents `pulumi:"parents"`
}

// TCPRouteStatusInput is an input type that accepts TCPRouteStatusArgs and TCPRouteStatusOutput values.
// You can construct a concrete instance of `TCPRouteStatusInput` via:
//
//	TCPRouteStatusArgs{...}
type TCPRouteStatusInput interface {
	pulumi.Input

	ToTCPRouteStatusOutput() TCPRouteStatusOutput
	ToTCPRouteStatusOutputWithContext(context.Context) TCPRouteStatusOutput
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents TCPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (TCPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatus)(nil)).Elem()
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusOutput() TCPRouteStatusOutput {
	return i.ToTCPRouteStatusOutputWithContext(context.Background())
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusOutputWithContext(ctx context.Context) TCPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusOutput)
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return i.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusOutput).ToTCPRouteStatusPtrOutputWithContext(ctx)
}

// TCPRouteStatusPtrInput is an input type that accepts TCPRouteStatusArgs, TCPRouteStatusPtr and TCPRouteStatusPtrOutput values.
// You can construct a concrete instance of `TCPRouteStatusPtrInput` via:
//
//	        TCPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type TCPRouteStatusPtrInput interface {
	pulumi.Input

	ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput
	ToTCPRouteStatusPtrOutputWithContext(context.Context) TCPRouteStatusPtrOutput
}

type tcprouteStatusPtrType TCPRouteStatusArgs

func TCPRouteStatusPtr(v *TCPRouteStatusArgs) TCPRouteStatusPtrInput {
	return (*tcprouteStatusPtrType)(v)
}

func (*tcprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatus)(nil)).Elem()
}

func (i *tcprouteStatusPtrType) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return i.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *tcprouteStatusPtrType) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusPtrOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatus)(nil)).Elem()
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusOutput() TCPRouteStatusOutput {
	return o
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusOutputWithContext(ctx context.Context) TCPRouteStatusOutput {
	return o
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return o.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteStatus) *TCPRouteStatus {
		return &v
	}).(TCPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o TCPRouteStatusOutput) Parents() TCPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v TCPRouteStatus) []TCPRouteStatusParents { return v.Parents }).(TCPRouteStatusParentsArrayOutput)
}

type TCPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatus)(nil)).Elem()
}

func (o TCPRouteStatusPtrOutput) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return o
}

func (o TCPRouteStatusPtrOutput) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return o
}

func (o TCPRouteStatusPtrOutput) Elem() TCPRouteStatusOutput {
	return o.ApplyT(func(v *TCPRouteStatus) TCPRouteStatus {
		if v != nil {
			return *v
		}
		var ret TCPRouteStatus
		return ret
	}).(TCPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o TCPRouteStatusPtrOutput) Parents() TCPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *TCPRouteStatus) []TCPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TCPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TCPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions []TCPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef TCPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for TCPRouteStatusParents
func (val *TCPRouteStatusParents) Defaults() *TCPRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// TCPRouteStatusParentsInput is an input type that accepts TCPRouteStatusParentsArgs and TCPRouteStatusParentsOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsInput` via:
//
//	TCPRouteStatusParentsArgs{...}
type TCPRouteStatusParentsInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput
	ToTCPRouteStatusParentsOutputWithContext(context.Context) TCPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TCPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions TCPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef TCPRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for TCPRouteStatusParentsArgs
func (val *TCPRouteStatusParentsArgs) Defaults() *TCPRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (TCPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParents)(nil)).Elem()
}

func (i TCPRouteStatusParentsArgs) ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput {
	return i.ToTCPRouteStatusParentsOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsArgs) ToTCPRouteStatusParentsOutputWithContext(ctx context.Context) TCPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsOutput)
}

// TCPRouteStatusParentsArrayInput is an input type that accepts TCPRouteStatusParentsArray and TCPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsArrayInput` via:
//
//	TCPRouteStatusParentsArray{ TCPRouteStatusParentsArgs{...} }
type TCPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput
	ToTCPRouteStatusParentsArrayOutputWithContext(context.Context) TCPRouteStatusParentsArrayOutput
}

type TCPRouteStatusParentsArray []TCPRouteStatusParentsInput

func (TCPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParents)(nil)).Elem()
}

func (i TCPRouteStatusParentsArray) ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput {
	return i.ToTCPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsArray) ToTCPRouteStatusParentsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TCPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParents)(nil)).Elem()
}

func (o TCPRouteStatusParentsOutput) ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput {
	return o
}

func (o TCPRouteStatusParentsOutput) ToTCPRouteStatusParentsOutputWithContext(ctx context.Context) TCPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
//
//	If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
//	A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
//	There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
//	* The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
func (o TCPRouteStatusParentsOutput) Conditions() TCPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) []TCPRouteStatusParentsConditions { return v.Conditions }).(TCPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
//
//	Example: "example.net/gateway-controller".
//	The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//	Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
func (o TCPRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
func (o TCPRouteStatusParentsOutput) ParentRef() TCPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) TCPRouteStatusParentsParentRef { return v.ParentRef }).(TCPRouteStatusParentsParentRefOutput)
}

type TCPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParents)(nil)).Elem()
}

func (o TCPRouteStatusParentsArrayOutput) ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsArrayOutput) ToTCPRouteStatusParentsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParents {
		return vs[0].([]TCPRouteStatusParents)[vs[1].(int)]
	}).(TCPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TCPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// TCPRouteStatusParentsConditionsInput is an input type that accepts TCPRouteStatusParentsConditionsArgs and TCPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsInput` via:
//
//	TCPRouteStatusParentsConditionsArgs{...}
type TCPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput
	ToTCPRouteStatusParentsConditionsOutputWithContext(context.Context) TCPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TCPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (TCPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsArgs) ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput {
	return i.ToTCPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsArgs) ToTCPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsOutput)
}

// TCPRouteStatusParentsConditionsArrayInput is an input type that accepts TCPRouteStatusParentsConditionsArray and TCPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsArrayInput` via:
//
//	TCPRouteStatusParentsConditionsArray{ TCPRouteStatusParentsConditionsArgs{...} }
type TCPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput
	ToTCPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) TCPRouteStatusParentsConditionsArrayOutput
}

type TCPRouteStatusParentsConditionsArray []TCPRouteStatusParentsConditionsInput

func (TCPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsArray) ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput {
	return i.ToTCPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsArray) ToTCPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TCPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsOutput) ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsOutput) ToTCPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TCPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition. This may be an empty string.
func (o TCPRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
func (o TCPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
func (o TCPRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TCPRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o TCPRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type TCPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsArrayOutput) ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsArrayOutput) ToTCPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParentsConditions {
		return vs[0].([]TCPRouteStatusParentsConditions)[vs[1].(int)]
	}).(TCPRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRef struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TCPRouteStatusParentsParentRef
func (val *TCPRouteStatusParentsParentRef) Defaults() *TCPRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// TCPRouteStatusParentsParentRefInput is an input type that accepts TCPRouteStatusParentsParentRefArgs and TCPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsParentRefInput` via:
//
//	TCPRouteStatusParentsParentRefArgs{...}
type TCPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput
	ToTCPRouteStatusParentsParentRefOutputWithContext(context.Context) TCPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TCPRouteStatusParentsParentRefArgs
func (val *TCPRouteStatusParentsParentRefArgs) Defaults() *TCPRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (TCPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput {
	return i.ToTCPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o TCPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o TCPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o TCPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

// The TLSRoute resource is similar to TCPRoute, but can be configured to match against TLS-specific metadata. This allows more flexibility in matching streams for a given TLS listener.
//
//	If you need to forward traffic to a single target for a TLS listener, you could choose to use a TCPRoute with a TLS listener.
type TLSRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of TLSRoute.
	Spec TLSRouteSpec `pulumi:"spec"`
	// Status defines the current state of TLSRoute.
	Status *TLSRouteStatus `pulumi:"status"`
}

type TLSRouteMetadata struct {
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpec struct {
	// Hostnames defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
	//  1. IPs are not allowed in SNI names per RFC 6066. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label must appear by itself as the first label.
	//      If a hostname is specified by both the Listener and TLSRoute, there must be at least one intersecting hostname for the TLSRoute to be attached to the Listener. For example:
	//  * A Listener with `test.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
	//     If both the Listener and TLSRoute have specified hostnames, any TLSRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the TLSRoute specified `test.example.com` and `test.example.net`, `test.example.net` must not be considered for a match.
	//     If both the Listener and TLSRoute have specified hostnames, and none match with the criteria above, then the TLSRoute is not accepted. The implementation must raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
	//     Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs []TLSRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules []TLSRouteSpecRules `pulumi:"rules"`
}

// TLSRouteSpecInput is an input type that accepts TLSRouteSpecArgs and TLSRouteSpecOutput values.
// You can construct a concrete instance of `TLSRouteSpecInput` via:
//
//	TLSRouteSpecArgs{...}
type TLSRouteSpecInput interface {
	pulumi.Input

	ToTLSRouteSpecOutput() TLSRouteSpecOutput
	ToTLSRouteSpecOutputWithContext(context.Context) TLSRouteSpecOutput
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecArgs struct {
	// Hostnames defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
	//  1. IPs are not allowed in SNI names per RFC 6066. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label must appear by itself as the first label.
	//      If a hostname is specified by both the Listener and TLSRoute, there must be at least one intersecting hostname for the TLSRoute to be attached to the Listener. For example:
	//  * A Listener with `test.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
	//     If both the Listener and TLSRoute have specified hostnames, any TLSRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the TLSRoute specified `test.example.com` and `test.example.net`, `test.example.net` must not be considered for a match.
	//     If both the Listener and TLSRoute have specified hostnames, and none match with the criteria above, then the TLSRoute is not accepted. The implementation must raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
	//     Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs TLSRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules TLSRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (TLSRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpec)(nil)).Elem()
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecOutput() TLSRouteSpecOutput {
	return i.ToTLSRouteSpecOutputWithContext(context.Background())
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecOutputWithContext(ctx context.Context) TLSRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecOutput)
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return i.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecOutput).ToTLSRouteSpecPtrOutputWithContext(ctx)
}

// TLSRouteSpecPtrInput is an input type that accepts TLSRouteSpecArgs, TLSRouteSpecPtr and TLSRouteSpecPtrOutput values.
// You can construct a concrete instance of `TLSRouteSpecPtrInput` via:
//
//	        TLSRouteSpecArgs{...}
//
//	or:
//
//	        nil
type TLSRouteSpecPtrInput interface {
	pulumi.Input

	ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput
	ToTLSRouteSpecPtrOutputWithContext(context.Context) TLSRouteSpecPtrOutput
}

type tlsrouteSpecPtrType TLSRouteSpecArgs

func TLSRouteSpecPtr(v *TLSRouteSpecArgs) TLSRouteSpecPtrInput {
	return (*tlsrouteSpecPtrType)(v)
}

func (*tlsrouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpec)(nil)).Elem()
}

func (i *tlsrouteSpecPtrType) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return i.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (i *tlsrouteSpecPtrType) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecPtrOutput)
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpec)(nil)).Elem()
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecOutput() TLSRouteSpecOutput {
	return o
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecOutputWithContext(ctx context.Context) TLSRouteSpecOutput {
	return o
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return o.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteSpec) *TLSRouteSpec {
		return &v
	}).(TLSRouteSpecPtrOutput)
}

// Hostnames defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
//  1. IPs are not allowed in SNI names per RFC 6066. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label must appear by itself as the first label.
//     If a hostname is specified by both the Listener and TLSRoute, there must be at least one intersecting hostname for the TLSRoute to be attached to the Listener. For example:
//     * A Listener with `test.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
//     If both the Listener and TLSRoute have specified hostnames, any TLSRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the TLSRoute specified `test.example.com` and `test.example.net`, `test.example.net` must not be considered for a match.
//     If both the Listener and TLSRoute have specified hostnames, and none match with the criteria above, then the TLSRoute is not accepted. The implementation must raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
//     Support: Core
func (o TLSRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o TLSRouteSpecOutput) ParentRefs() TLSRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []TLSRouteSpecParentRefs { return v.ParentRefs }).(TLSRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecOutput) Rules() TLSRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []TLSRouteSpecRules { return v.Rules }).(TLSRouteSpecRulesArrayOutput)
}

type TLSRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpec)(nil)).Elem()
}

func (o TLSRouteSpecPtrOutput) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return o
}

func (o TLSRouteSpecPtrOutput) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return o
}

func (o TLSRouteSpecPtrOutput) Elem() TLSRouteSpecOutput {
	return o.ApplyT(func(v *TLSRouteSpec) TLSRouteSpec {
		if v != nil {
			return *v
		}
		var ret TLSRouteSpec
		return ret
	}).(TLSRouteSpecOutput)
}

// Hostnames defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. This matches the RFC 1123 definition of a hostname with 2 notable exceptions:
//  1. IPs are not allowed in SNI names per RFC 6066. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label must appear by itself as the first label.
//     If a hostname is specified by both the Listener and TLSRoute, there must be at least one intersecting hostname for the TLSRoute to be attached to the Listener. For example:
//     * A Listener with `test.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match.
//     If both the Listener and TLSRoute have specified hostnames, any TLSRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the TLSRoute specified `test.example.com` and `test.example.net`, `test.example.net` must not be considered for a match.
//     If both the Listener and TLSRoute have specified hostnames, and none match with the criteria above, then the TLSRoute is not accepted. The implementation must raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus.
//     Support: Core
func (o TLSRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o TLSRouteSpecPtrOutput) ParentRefs() TLSRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []TLSRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TLSRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecPtrOutput) Rules() TLSRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []TLSRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TLSRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TLSRouteSpecParentRefs
func (val *TLSRouteSpecParentRefs) Defaults() *TLSRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// TLSRouteSpecParentRefsInput is an input type that accepts TLSRouteSpecParentRefsArgs and TLSRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsInput` via:
//
//	TLSRouteSpecParentRefsArgs{...}
type TLSRouteSpecParentRefsInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput
	ToTLSRouteSpecParentRefsOutputWithContext(context.Context) TLSRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TLSRouteSpecParentRefsArgs
func (val *TLSRouteSpecParentRefsArgs) Defaults() *TLSRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (TLSRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefs)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsArgs) ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput {
	return i.ToTLSRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsArgs) ToTLSRouteSpecParentRefsOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsOutput)
}

// TLSRouteSpecParentRefsArrayInput is an input type that accepts TLSRouteSpecParentRefsArray and TLSRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsArrayInput` via:
//
//	TLSRouteSpecParentRefsArray{ TLSRouteSpecParentRefsArgs{...} }
type TLSRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput
	ToTLSRouteSpecParentRefsArrayOutputWithContext(context.Context) TLSRouteSpecParentRefsArrayOutput
}

type TLSRouteSpecParentRefsArray []TLSRouteSpecParentRefsInput

func (TLSRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefs)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsArray) ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput {
	return i.ToTLSRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsArray) ToTLSRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefs)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsOutput) ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput {
	return o
}

func (o TLSRouteSpecParentRefsOutput) ToTLSRouteSpecParentRefsOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o TLSRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o TLSRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o TLSRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o TLSRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o TLSRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o TLSRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TLSRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefs)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsArrayOutput) ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsArrayOutput) ToTLSRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecParentRefs {
		return vs[0].([]TLSRouteSpecParentRefs)[vs[1].(int)]
	}).(TLSRouteSpecParentRefsOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the rule performs no forwarding; if no filters are specified that would result in a response being sent, the underlying implementation must actively reject request attempts to this backend, by rejecting the connection or returning a 500 status code. Request rejections must respect weight; if an invalid backend is requested to have 80% of requests, then 80% of requests must be rejected instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs []TLSRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
}

// TLSRouteSpecRulesInput is an input type that accepts TLSRouteSpecRulesArgs and TLSRouteSpecRulesOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesInput` via:
//
//	TLSRouteSpecRulesArgs{...}
type TLSRouteSpecRulesInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput
	ToTLSRouteSpecRulesOutputWithContext(context.Context) TLSRouteSpecRulesOutput
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the rule performs no forwarding; if no filters are specified that would result in a response being sent, the underlying implementation must actively reject request attempts to this backend, by rejecting the connection or returning a 500 status code. Request rejections must respect weight; if an invalid backend is requested to have 80% of requests, then 80% of requests must be rejected instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs TLSRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
}

func (TLSRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRules)(nil)).Elem()
}

func (i TLSRouteSpecRulesArgs) ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput {
	return i.ToTLSRouteSpecRulesOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesArgs) ToTLSRouteSpecRulesOutputWithContext(ctx context.Context) TLSRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesOutput)
}

// TLSRouteSpecRulesArrayInput is an input type that accepts TLSRouteSpecRulesArray and TLSRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesArrayInput` via:
//
//	TLSRouteSpecRulesArray{ TLSRouteSpecRulesArgs{...} }
type TLSRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput
	ToTLSRouteSpecRulesArrayOutputWithContext(context.Context) TLSRouteSpecRulesArrayOutput
}

type TLSRouteSpecRulesArray []TLSRouteSpecRulesInput

func (TLSRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRules)(nil)).Elem()
}

func (i TLSRouteSpecRulesArray) ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput {
	return i.ToTLSRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesArray) ToTLSRouteSpecRulesArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesArrayOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRules)(nil)).Elem()
}

func (o TLSRouteSpecRulesOutput) ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput {
	return o
}

func (o TLSRouteSpecRulesOutput) ToTLSRouteSpecRulesOutputWithContext(ctx context.Context) TLSRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the rule performs no forwarding; if no filters are specified that would result in a response being sent, the underlying implementation must actively reject request attempts to this backend, by rejecting the connection or returning a 500 status code. Request rejections must respect weight; if an invalid backend is requested to have 80% of requests, then 80% of requests must be rejected instead.
//
//	Support: Core for Kubernetes Service
//	Support: Extended for Kubernetes ServiceImport
//	Support: Implementation-specific for any other resource
//	Support for weight: Extended
func (o TLSRouteSpecRulesOutput) BackendRefs() TLSRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecRules) []TLSRouteSpecRulesBackendRefs { return v.BackendRefs }).(TLSRouteSpecRulesBackendRefsArrayOutput)
}

type TLSRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRules)(nil)).Elem()
}

func (o TLSRouteSpecRulesArrayOutput) ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput {
	return o
}

func (o TLSRouteSpecRulesArrayOutput) ToTLSRouteSpecRulesArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesArrayOutput {
	return o
}

func (o TLSRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRules {
		return vs[0].([]TLSRouteSpecRules)[vs[1].(int)]
	}).(TLSRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for TLSRouteSpecRulesBackendRefs
func (val *TLSRouteSpecRulesBackendRefs) Defaults() *TLSRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// TLSRouteSpecRulesBackendRefsInput is an input type that accepts TLSRouteSpecRulesBackendRefsArgs and TLSRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsInput` via:
//
//	TLSRouteSpecRulesBackendRefsArgs{...}
type TLSRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput
	ToTLSRouteSpecRulesBackendRefsOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for TLSRouteSpecRulesBackendRefsArgs
func (val *TLSRouteSpecRulesBackendRefsArgs) Defaults() *TLSRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (TLSRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsArgs) ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput {
	return i.ToTLSRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsArgs) ToTLSRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsOutput)
}

// TLSRouteSpecRulesBackendRefsArrayInput is an input type that accepts TLSRouteSpecRulesBackendRefsArray and TLSRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsArrayInput` via:
//
//	TLSRouteSpecRulesBackendRefsArray{ TLSRouteSpecRulesBackendRefsArgs{...} }
type TLSRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput
	ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsArrayOutput
}

type TLSRouteSpecRulesBackendRefsArray []TLSRouteSpecRulesBackendRefsInput

func (TLSRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsArray) ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput {
	return i.ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsArray) ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsOutput) ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsOutput) ToTLSRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o TLSRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o TLSRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TLSRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o TLSRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o TLSRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
//
//	If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
//	Support for this field varies based on the context where used.
func (o TLSRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TLSRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRulesBackendRefs {
		return vs[0].([]TLSRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(TLSRouteSpecRulesBackendRefsOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents []TLSRouteStatusParents `pulumi:"parents"`
}

// TLSRouteStatusInput is an input type that accepts TLSRouteStatusArgs and TLSRouteStatusOutput values.
// You can construct a concrete instance of `TLSRouteStatusInput` via:
//
//	TLSRouteStatusArgs{...}
type TLSRouteStatusInput interface {
	pulumi.Input

	ToTLSRouteStatusOutput() TLSRouteStatusOutput
	ToTLSRouteStatusOutputWithContext(context.Context) TLSRouteStatusOutput
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents TLSRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (TLSRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatus)(nil)).Elem()
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusOutput() TLSRouteStatusOutput {
	return i.ToTLSRouteStatusOutputWithContext(context.Background())
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusOutputWithContext(ctx context.Context) TLSRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusOutput)
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return i.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusOutput).ToTLSRouteStatusPtrOutputWithContext(ctx)
}

// TLSRouteStatusPtrInput is an input type that accepts TLSRouteStatusArgs, TLSRouteStatusPtr and TLSRouteStatusPtrOutput values.
// You can construct a concrete instance of `TLSRouteStatusPtrInput` via:
//
//	        TLSRouteStatusArgs{...}
//
//	or:
//
//	        nil
type TLSRouteStatusPtrInput interface {
	pulumi.Input

	ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput
	ToTLSRouteStatusPtrOutputWithContext(context.Context) TLSRouteStatusPtrOutput
}

type tlsrouteStatusPtrType TLSRouteStatusArgs

func TLSRouteStatusPtr(v *TLSRouteStatusArgs) TLSRouteStatusPtrInput {
	return (*tlsrouteStatusPtrType)(v)
}

func (*tlsrouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatus)(nil)).Elem()
}

func (i *tlsrouteStatusPtrType) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return i.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (i *tlsrouteStatusPtrType) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusPtrOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatus)(nil)).Elem()
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusOutput() TLSRouteStatusOutput {
	return o
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusOutputWithContext(ctx context.Context) TLSRouteStatusOutput {
	return o
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return o.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteStatus) *TLSRouteStatus {
		return &v
	}).(TLSRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o TLSRouteStatusOutput) Parents() TLSRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v TLSRouteStatus) []TLSRouteStatusParents { return v.Parents }).(TLSRouteStatusParentsArrayOutput)
}

type TLSRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatus)(nil)).Elem()
}

func (o TLSRouteStatusPtrOutput) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return o
}

func (o TLSRouteStatusPtrOutput) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return o
}

func (o TLSRouteStatusPtrOutput) Elem() TLSRouteStatusOutput {
	return o.ApplyT(func(v *TLSRouteStatus) TLSRouteStatus {
		if v != nil {
			return *v
		}
		var ret TLSRouteStatus
		return ret
	}).(TLSRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o TLSRouteStatusPtrOutput) Parents() TLSRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *TLSRouteStatus) []TLSRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TLSRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TLSRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions []TLSRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef TLSRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for TLSRouteStatusParents
func (val *TLSRouteStatusParents) Defaults() *TLSRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// TLSRouteStatusParentsInput is an input type that accepts TLSRouteStatusParentsArgs and TLSRouteStatusParentsOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsInput` via:
//
//	TLSRouteStatusParentsArgs{...}
type TLSRouteStatusParentsInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput
	ToTLSRouteStatusParentsOutputWithContext(context.Context) TLSRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TLSRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions TLSRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef TLSRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for TLSRouteStatusParentsArgs
func (val *TLSRouteStatusParentsArgs) Defaults() *TLSRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (TLSRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParents)(nil)).Elem()
}

func (i TLSRouteStatusParentsArgs) ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput {
	return i.ToTLSRouteStatusParentsOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsArgs) ToTLSRouteStatusParentsOutputWithContext(ctx context.Context) TLSRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsOutput)
}

// TLSRouteStatusParentsArrayInput is an input type that accepts TLSRouteStatusParentsArray and TLSRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsArrayInput` via:
//
//	TLSRouteStatusParentsArray{ TLSRouteStatusParentsArgs{...} }
type TLSRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput
	ToTLSRouteStatusParentsArrayOutputWithContext(context.Context) TLSRouteStatusParentsArrayOutput
}

type TLSRouteStatusParentsArray []TLSRouteStatusParentsInput

func (TLSRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParents)(nil)).Elem()
}

func (i TLSRouteStatusParentsArray) ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput {
	return i.ToTLSRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsArray) ToTLSRouteStatusParentsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type TLSRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParents)(nil)).Elem()
}

func (o TLSRouteStatusParentsOutput) ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput {
	return o
}

func (o TLSRouteStatusParentsOutput) ToTLSRouteStatusParentsOutputWithContext(ctx context.Context) TLSRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
//
//	If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
//	A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
//	There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
//	* The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
func (o TLSRouteStatusParentsOutput) Conditions() TLSRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) []TLSRouteStatusParentsConditions { return v.Conditions }).(TLSRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
//
//	Example: "example.net/gateway-controller".
//	The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//	Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
func (o TLSRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
func (o TLSRouteStatusParentsOutput) ParentRef() TLSRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) TLSRouteStatusParentsParentRef { return v.ParentRef }).(TLSRouteStatusParentsParentRefOutput)
}

type TLSRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParents)(nil)).Elem()
}

func (o TLSRouteStatusParentsArrayOutput) ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsArrayOutput) ToTLSRouteStatusParentsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParents {
		return vs[0].([]TLSRouteStatusParents)[vs[1].(int)]
	}).(TLSRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TLSRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// TLSRouteStatusParentsConditionsInput is an input type that accepts TLSRouteStatusParentsConditionsArgs and TLSRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsInput` via:
//
//	TLSRouteStatusParentsConditionsArgs{...}
type TLSRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput
	ToTLSRouteStatusParentsConditionsOutputWithContext(context.Context) TLSRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TLSRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (TLSRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsArgs) ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput {
	return i.ToTLSRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsArgs) ToTLSRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsOutput)
}

// TLSRouteStatusParentsConditionsArrayInput is an input type that accepts TLSRouteStatusParentsConditionsArray and TLSRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsArrayInput` via:
//
//	TLSRouteStatusParentsConditionsArray{ TLSRouteStatusParentsConditionsArgs{...} }
type TLSRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput
	ToTLSRouteStatusParentsConditionsArrayOutputWithContext(context.Context) TLSRouteStatusParentsConditionsArrayOutput
}

type TLSRouteStatusParentsConditionsArray []TLSRouteStatusParentsConditionsInput

func (TLSRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsArray) ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput {
	return i.ToTLSRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsArray) ToTLSRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type TLSRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsOutput) ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsOutput) ToTLSRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TLSRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition. This may be an empty string.
func (o TLSRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
func (o TLSRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
func (o TLSRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TLSRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o TLSRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type TLSRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsArrayOutput) ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsArrayOutput) ToTLSRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParentsConditions {
		return vs[0].([]TLSRouteStatusParentsConditions)[vs[1].(int)]
	}).(TLSRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRef struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TLSRouteStatusParentsParentRef
func (val *TLSRouteStatusParentsParentRef) Defaults() *TLSRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// TLSRouteStatusParentsParentRefInput is an input type that accepts TLSRouteStatusParentsParentRefArgs and TLSRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsParentRefInput` via:
//
//	TLSRouteStatusParentsParentRefArgs{...}
type TLSRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput
	ToTLSRouteStatusParentsParentRefOutputWithContext(context.Context) TLSRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for TLSRouteStatusParentsParentRefArgs
func (val *TLSRouteStatusParentsParentRefArgs) Defaults() *TLSRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (TLSRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput {
	return i.ToTLSRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o TLSRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o TLSRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o TLSRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway listener, it can be used to forward traffic on the port specified by the listener to a set of backends specified by the UDPRoute.
type UDPRouteType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Spec defines the desired state of UDPRoute.
	Spec UDPRouteSpec `pulumi:"spec"`
	// Status defines the current state of UDPRoute.
	Status *UDPRouteStatus `pulumi:"status"`
}

type UDPRouteMetadata struct {
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpec struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs []UDPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules []UDPRouteSpecRules `pulumi:"rules"`
}

// UDPRouteSpecInput is an input type that accepts UDPRouteSpecArgs and UDPRouteSpecOutput values.
// You can construct a concrete instance of `UDPRouteSpecInput` via:
//
//	UDPRouteSpecArgs{...}
type UDPRouteSpecInput interface {
	pulumi.Input

	ToUDPRouteSpecOutput() UDPRouteSpecOutput
	ToUDPRouteSpecOutputWithContext(context.Context) UDPRouteSpecOutput
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
	//     ParentRefs must be _distinct_. This means either that:
	//  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
	//     Some examples:
	//  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
	//     It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
	//     Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
	//      ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//     ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
	ParentRefs UDPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules UDPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (UDPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpec)(nil)).Elem()
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecOutput() UDPRouteSpecOutput {
	return i.ToUDPRouteSpecOutputWithContext(context.Background())
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecOutputWithContext(ctx context.Context) UDPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecOutput)
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return i.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecOutput).ToUDPRouteSpecPtrOutputWithContext(ctx)
}

// UDPRouteSpecPtrInput is an input type that accepts UDPRouteSpecArgs, UDPRouteSpecPtr and UDPRouteSpecPtrOutput values.
// You can construct a concrete instance of `UDPRouteSpecPtrInput` via:
//
//	        UDPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type UDPRouteSpecPtrInput interface {
	pulumi.Input

	ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput
	ToUDPRouteSpecPtrOutputWithContext(context.Context) UDPRouteSpecPtrOutput
}

type udprouteSpecPtrType UDPRouteSpecArgs

func UDPRouteSpecPtr(v *UDPRouteSpecArgs) UDPRouteSpecPtrInput {
	return (*udprouteSpecPtrType)(v)
}

func (*udprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpec)(nil)).Elem()
}

func (i *udprouteSpecPtrType) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return i.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *udprouteSpecPtrType) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecPtrOutput)
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpec)(nil)).Elem()
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecOutput() UDPRouteSpecOutput {
	return o
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecOutputWithContext(ctx context.Context) UDPRouteSpecOutput {
	return o
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return o.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteSpec) *UDPRouteSpec {
		return &v
	}).(UDPRouteSpecPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o UDPRouteSpecOutput) ParentRefs() UDPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v UDPRouteSpec) []UDPRouteSpecParentRefs { return v.ParentRefs }).(UDPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecOutput) Rules() UDPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v UDPRouteSpec) []UDPRouteSpecRules { return v.Rules }).(UDPRouteSpecRulesArrayOutput)
}

type UDPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpec)(nil)).Elem()
}

func (o UDPRouteSpecPtrOutput) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return o
}

func (o UDPRouteSpecPtrOutput) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return o
}

func (o UDPRouteSpecPtrOutput) Elem() UDPRouteSpecOutput {
	return o.ApplyT(func(v *UDPRouteSpec) UDPRouteSpec {
		if v != nil {
			return *v
		}
		var ret UDPRouteSpec
		return ret
	}).(UDPRouteSpecOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources.
//	   ParentRefs must be _distinct_. This means either that:
//	* They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination.
//	   Some examples:
//	* If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`.
//	   It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged.
//	   Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference.
//	    ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	   ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.
func (o UDPRouteSpecPtrOutput) ParentRefs() UDPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpec) []UDPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(UDPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecPtrOutput) Rules() UDPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpec) []UDPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(UDPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for UDPRouteSpecParentRefs
func (val *UDPRouteSpecParentRefs) Defaults() *UDPRouteSpecParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// UDPRouteSpecParentRefsInput is an input type that accepts UDPRouteSpecParentRefsArgs and UDPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsInput` via:
//
//	UDPRouteSpecParentRefsArgs{...}
type UDPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput
	ToUDPRouteSpecParentRefsOutputWithContext(context.Context) UDPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for UDPRouteSpecParentRefsArgs
func (val *UDPRouteSpecParentRefsArgs) Defaults() *UDPRouteSpecParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (UDPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefs)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsArgs) ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput {
	return i.ToUDPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsArgs) ToUDPRouteSpecParentRefsOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsOutput)
}

// UDPRouteSpecParentRefsArrayInput is an input type that accepts UDPRouteSpecParentRefsArray and UDPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsArrayInput` via:
//
//	UDPRouteSpecParentRefsArray{ UDPRouteSpecParentRefsArgs{...} }
type UDPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput
	ToUDPRouteSpecParentRefsArrayOutputWithContext(context.Context) UDPRouteSpecParentRefsArrayOutput
}

type UDPRouteSpecParentRefsArray []UDPRouteSpecParentRefsInput

func (UDPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefs)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsArray) ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput {
	return i.ToUDPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsArray) ToUDPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support:
//   - Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//     This API may be extended in the future to support additional kinds of parent resources.
//     The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefs)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsOutput) ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput {
	return o
}

func (o UDPRouteSpecParentRefsOutput) ToUDPRouteSpecParentRefsOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o UDPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o UDPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o UDPRouteSpecParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o UDPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o UDPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o UDPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type UDPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefs)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsArrayOutput) ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsArrayOutput) ToUDPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecParentRefs {
		return vs[0].([]UDPRouteSpecParentRefs)[vs[1].(int)]
	}).(UDPRouteSpecParentRefsOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Packet drops must respect weight; if an invalid backend is requested to have 80% of the packets, then 80% of packets must be dropped instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs []UDPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
}

// UDPRouteSpecRulesInput is an input type that accepts UDPRouteSpecRulesArgs and UDPRouteSpecRulesOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesInput` via:
//
//	UDPRouteSpecRulesArgs{...}
type UDPRouteSpecRulesInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput
	ToUDPRouteSpecRulesOutputWithContext(context.Context) UDPRouteSpecRulesOutput
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Packet drops must respect weight; if an invalid backend is requested to have 80% of the packets, then 80% of packets must be dropped instead.
	//  Support: Core for Kubernetes Service
	//  Support: Extended for Kubernetes ServiceImport
	//  Support: Implementation-specific for any other resource
	//  Support for weight: Extended
	BackendRefs UDPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
}

func (UDPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRules)(nil)).Elem()
}

func (i UDPRouteSpecRulesArgs) ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput {
	return i.ToUDPRouteSpecRulesOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesArgs) ToUDPRouteSpecRulesOutputWithContext(ctx context.Context) UDPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesOutput)
}

// UDPRouteSpecRulesArrayInput is an input type that accepts UDPRouteSpecRulesArray and UDPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesArrayInput` via:
//
//	UDPRouteSpecRulesArray{ UDPRouteSpecRulesArgs{...} }
type UDPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput
	ToUDPRouteSpecRulesArrayOutputWithContext(context.Context) UDPRouteSpecRulesArrayOutput
}

type UDPRouteSpecRulesArray []UDPRouteSpecRulesInput

func (UDPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRules)(nil)).Elem()
}

func (i UDPRouteSpecRulesArray) ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput {
	return i.ToUDPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesArray) ToUDPRouteSpecRulesArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesArrayOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRules)(nil)).Elem()
}

func (o UDPRouteSpecRulesOutput) ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput {
	return o
}

func (o UDPRouteSpecRulesOutput) ToUDPRouteSpecRulesOutputWithContext(ctx context.Context) UDPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Packet drops must respect weight; if an invalid backend is requested to have 80% of the packets, then 80% of packets must be dropped instead.
//
//	Support: Core for Kubernetes Service
//	Support: Extended for Kubernetes ServiceImport
//	Support: Implementation-specific for any other resource
//	Support for weight: Extended
func (o UDPRouteSpecRulesOutput) BackendRefs() UDPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v UDPRouteSpecRules) []UDPRouteSpecRulesBackendRefs { return v.BackendRefs }).(UDPRouteSpecRulesBackendRefsArrayOutput)
}

type UDPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRules)(nil)).Elem()
}

func (o UDPRouteSpecRulesArrayOutput) ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput {
	return o
}

func (o UDPRouteSpecRulesArrayOutput) ToUDPRouteSpecRulesArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesArrayOutput {
	return o
}

func (o UDPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRules {
		return vs[0].([]UDPRouteSpecRules)[vs[1].(int)]
	}).(UDPRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for UDPRouteSpecRulesBackendRefs
func (val *UDPRouteSpecRulesBackendRefs) Defaults() *UDPRouteSpecRulesBackendRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := ""
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Service"
		tmp.Kind = &kind_
	}
	if tmp.Weight == nil {
		weight_ := 1
		tmp.Weight = &weight_
	}
	return &tmp
}

// UDPRouteSpecRulesBackendRefsInput is an input type that accepts UDPRouteSpecRulesBackendRefsArgs and UDPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsInput` via:
//
//	UDPRouteSpecRulesBackendRefsArgs{...}
type UDPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput
	ToUDPRouteSpecRulesBackendRefsOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example "Service".
	//  Defaults to "Service" when not specified.
	//  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
	//  Support: Core (Services with a type other than ExternalName)
	//  Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
	//  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
	//  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
	//  Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

// Defaults sets the appropriate defaults for UDPRouteSpecRulesBackendRefsArgs
func (val *UDPRouteSpecRulesBackendRefsArgs) Defaults() *UDPRouteSpecRulesBackendRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Service")
	}
	if tmp.Weight == nil {
		tmp.Weight = pulumi.IntPtr(1)
	}
	return &tmp
}
func (UDPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsArgs) ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput {
	return i.ToUDPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsArgs) ToUDPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsOutput)
}

// UDPRouteSpecRulesBackendRefsArrayInput is an input type that accepts UDPRouteSpecRulesBackendRefsArray and UDPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsArrayInput` via:
//
//	UDPRouteSpecRulesBackendRefsArray{ UDPRouteSpecRulesBackendRefsArgs{...} }
type UDPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput
	ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsArrayOutput
}

type UDPRouteSpecRulesBackendRefsArray []UDPRouteSpecRulesBackendRefsInput

func (UDPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsArray) ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsArray) ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes resource.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	<gateway:experimental:description>
//	When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port.
//	Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726.
//	If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service.
//	If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//	</gateway:experimental:description>
//	Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsOutput) ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsOutput) ToUDPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
func (o UDPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example "Service".
//
//	Defaults to "Service" when not specified.
//	ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services.
//	Support: Core (Services with a type other than ExternalName)
//	Support: Implementation-specific (Services with type ExternalName)
func (o UDPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o UDPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local namespace is inferred.
//
//	Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
//	Support: Core
func (o UDPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
func (o UDPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100.
//
//	If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1.
//	Support for this field varies based on the context where used.
func (o UDPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type UDPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRulesBackendRefs {
		return vs[0].([]UDPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(UDPRouteSpecRulesBackendRefsOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents []UDPRouteStatusParents `pulumi:"parents"`
}

// UDPRouteStatusInput is an input type that accepts UDPRouteStatusArgs and UDPRouteStatusOutput values.
// You can construct a concrete instance of `UDPRouteStatusInput` via:
//
//	UDPRouteStatusArgs{...}
type UDPRouteStatusInput interface {
	pulumi.Input

	ToUDPRouteStatusOutput() UDPRouteStatusOutput
	ToUDPRouteStatusOutputWithContext(context.Context) UDPRouteStatusOutput
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
	//  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
	//  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
	Parents UDPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (UDPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatus)(nil)).Elem()
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusOutput() UDPRouteStatusOutput {
	return i.ToUDPRouteStatusOutputWithContext(context.Background())
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusOutputWithContext(ctx context.Context) UDPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusOutput)
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return i.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusOutput).ToUDPRouteStatusPtrOutputWithContext(ctx)
}

// UDPRouteStatusPtrInput is an input type that accepts UDPRouteStatusArgs, UDPRouteStatusPtr and UDPRouteStatusPtrOutput values.
// You can construct a concrete instance of `UDPRouteStatusPtrInput` via:
//
//	        UDPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type UDPRouteStatusPtrInput interface {
	pulumi.Input

	ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput
	ToUDPRouteStatusPtrOutputWithContext(context.Context) UDPRouteStatusPtrOutput
}

type udprouteStatusPtrType UDPRouteStatusArgs

func UDPRouteStatusPtr(v *UDPRouteStatusArgs) UDPRouteStatusPtrInput {
	return (*udprouteStatusPtrType)(v)
}

func (*udprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatus)(nil)).Elem()
}

func (i *udprouteStatusPtrType) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return i.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *udprouteStatusPtrType) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusPtrOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatus)(nil)).Elem()
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusOutput() UDPRouteStatusOutput {
	return o
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusOutputWithContext(ctx context.Context) UDPRouteStatusOutput {
	return o
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return o.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteStatus) *UDPRouteStatus {
		return &v
	}).(UDPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o UDPRouteStatusOutput) Parents() UDPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v UDPRouteStatus) []UDPRouteStatusParents { return v.Parents }).(UDPRouteStatusParentsArrayOutput)
}

type UDPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatus)(nil)).Elem()
}

func (o UDPRouteStatusPtrOutput) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return o
}

func (o UDPRouteStatusPtrOutput) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return o
}

func (o UDPRouteStatusPtrOutput) Elem() UDPRouteStatusOutput {
	return o.ApplyT(func(v *UDPRouteStatus) UDPRouteStatus {
		if v != nil {
			return *v
		}
		var ret UDPRouteStatus
		return ret
	}).(UDPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified.
//
//	Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for.
//	A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
func (o UDPRouteStatusPtrOutput) Parents() UDPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *UDPRouteStatus) []UDPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(UDPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type UDPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions []UDPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName string `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef UDPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for UDPRouteStatusParents
func (val *UDPRouteStatusParents) Defaults() *UDPRouteStatusParents {
	if val == nil {
		return nil
	}
	tmp := *val
	tmp.ParentRef = *tmp.ParentRef.Defaults()

	return &tmp
}

// UDPRouteStatusParentsInput is an input type that accepts UDPRouteStatusParentsArgs and UDPRouteStatusParentsOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsInput` via:
//
//	UDPRouteStatusParentsArgs{...}
type UDPRouteStatusParentsInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput
	ToUDPRouteStatusParentsOutputWithContext(context.Context) UDPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type UDPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
	//  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
	//  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
	//  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
	//  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
	Conditions UDPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
	//  Example: "example.net/gateway-controller".
	//  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
	ControllerName pulumi.StringInput `pulumi:"controllerName"`
	// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
	ParentRef UDPRouteStatusParentsParentRefInput `pulumi:"parentRef"`
}

// Defaults sets the appropriate defaults for UDPRouteStatusParentsArgs
func (val *UDPRouteStatusParentsArgs) Defaults() *UDPRouteStatusParentsArgs {
	if val == nil {
		return nil
	}
	tmp := *val

	return &tmp
}
func (UDPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParents)(nil)).Elem()
}

func (i UDPRouteStatusParentsArgs) ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput {
	return i.ToUDPRouteStatusParentsOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsArgs) ToUDPRouteStatusParentsOutputWithContext(ctx context.Context) UDPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsOutput)
}

// UDPRouteStatusParentsArrayInput is an input type that accepts UDPRouteStatusParentsArray and UDPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsArrayInput` via:
//
//	UDPRouteStatusParentsArray{ UDPRouteStatusParentsArgs{...} }
type UDPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput
	ToUDPRouteStatusParentsArrayOutputWithContext(context.Context) UDPRouteStatusParentsArrayOutput
}

type UDPRouteStatusParentsArray []UDPRouteStatusParentsInput

func (UDPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParents)(nil)).Elem()
}

func (i UDPRouteStatusParentsArray) ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput {
	return i.ToUDPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsArray) ToUDPRouteStatusParentsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an associated Parent.
type UDPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParents)(nil)).Elem()
}

func (o UDPRouteStatusParentsOutput) ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput {
	return o
}

func (o UDPRouteStatusParentsOutput) ToUDPRouteStatusParentsOutputWithContext(ctx context.Context) UDPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status.
//
//	If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why.
//	A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway.
//	There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when:
//	* The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
func (o UDPRouteStatusParentsOutput) Conditions() UDPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) []UDPRouteStatusParentsConditions { return v.Conditions }).(UDPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass.
//
//	Example: "example.net/gateway-controller".
//	The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//	Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
func (o UDPRouteStatusParentsOutput) ControllerName() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) string { return v.ControllerName }).(pulumi.StringOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
func (o UDPRouteStatusParentsOutput) ParentRef() UDPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) UDPRouteStatusParentsParentRef { return v.ParentRef }).(UDPRouteStatusParentsParentRefOutput)
}

type UDPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParents)(nil)).Elem()
}

func (o UDPRouteStatusParentsArrayOutput) ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsArrayOutput) ToUDPRouteStatusParentsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParents {
		return vs[0].([]UDPRouteStatusParents)[vs[1].(int)]
	}).(UDPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type UDPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type string `pulumi:"type"`
}

// UDPRouteStatusParentsConditionsInput is an input type that accepts UDPRouteStatusParentsConditionsArgs and UDPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsInput` via:
//
//	UDPRouteStatusParentsConditionsArgs{...}
type UDPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput
	ToUDPRouteStatusParentsConditionsOutputWithContext(context.Context) UDPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type UDPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition. This may be an empty string.
	Message pulumi.StringInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
	Reason pulumi.StringInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	Type pulumi.StringInput `pulumi:"type"`
}

func (UDPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsArgs) ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput {
	return i.ToUDPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsArgs) ToUDPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsOutput)
}

// UDPRouteStatusParentsConditionsArrayInput is an input type that accepts UDPRouteStatusParentsConditionsArray and UDPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsArrayInput` via:
//
//	UDPRouteStatusParentsConditionsArray{ UDPRouteStatusParentsConditionsArgs{...} }
type UDPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput
	ToUDPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) UDPRouteStatusParentsConditionsArrayOutput
}

type UDPRouteStatusParentsConditionsArray []UDPRouteStatusParentsConditionsInput

func (UDPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsArray) ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput {
	return i.ToUDPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsArray) ToUDPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//	// other fields }
type UDPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsOutput) ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsOutput) ToUDPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o UDPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) string { return v.LastTransitionTime }).(pulumi.StringOutput)
}

// message is a human readable message indicating details about the transition. This may be an empty string.
func (o UDPRouteStatusParentsConditionsOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) string { return v.Message }).(pulumi.StringOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
func (o UDPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
func (o UDPRouteStatusParentsConditionsOutput) Reason() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) string { return v.Reason }).(pulumi.StringOutput)
}

// status of the condition, one of True, False, Unknown.
func (o UDPRouteStatusParentsConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) string { return v.Status }).(pulumi.StringOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
func (o UDPRouteStatusParentsConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) string { return v.Type }).(pulumi.StringOutput)
}

type UDPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsArrayOutput) ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsArrayOutput) ToUDPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParentsConditions {
		return vs[0].([]UDPRouteStatusParentsConditions)[vs[1].(int)]
	}).(UDPRouteStatusParentsConditionsOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRef struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for UDPRouteStatusParentsParentRef
func (val *UDPRouteStatusParentsParentRef) Defaults() *UDPRouteStatusParentsParentRef {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// UDPRouteStatusParentsParentRefInput is an input type that accepts UDPRouteStatusParentsParentRefArgs and UDPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsParentRefInput` via:
//
//	UDPRouteStatusParentsParentRefArgs{...}
type UDPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput
	ToUDPRouteStatusParentsParentRefOutputWithContext(context.Context) UDPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
	//  Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//  There are two kinds of parent resources with "Core" support:
	//  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
	//     Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//  Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
	//  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
	//   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
	//  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
	//  Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
	//  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
	//   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
	//  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
	//  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//  Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
	//  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
	//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
	//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
	//     Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for UDPRouteStatusParentsParentRefArgs
func (val *UDPRouteStatusParentsParentRefArgs) Defaults() *UDPRouteStatusParentsParentRefArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (UDPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput {
	return i.ToUDPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefOutput {
	return o
}

// Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string).
//
//	Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
//	There are two kinds of parent resources with "Core" support:
//	* Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only)
//	   Support for other resources is Implementation-Specific.
func (o UDPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
//	Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route.
//
//	Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference.
//	 ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service.
//	ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.\
//	Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource.
//
//	When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values.
//	 When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.\
//	Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted.
//	For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//	Support: Extended
func (o UDPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following:
//   - Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose.
//     Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted.
//     When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway.
//     Support: Core
func (o UDPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecInput)(nil)).Elem(), BackendTLSPolicySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecPtrInput)(nil)).Elem(), BackendTLSPolicySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTargetRefInput)(nil)).Elem(), BackendTLSPolicySpecTargetRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTargetRefPtrInput)(nil)).Elem(), BackendTLSPolicySpecTargetRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTlsInput)(nil)).Elem(), BackendTLSPolicySpecTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTlsPtrInput)(nil)).Elem(), BackendTLSPolicySpecTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTlsCaCertRefsInput)(nil)).Elem(), BackendTLSPolicySpecTlsCaCertRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicySpecTlsCaCertRefsArrayInput)(nil)).Elem(), BackendTLSPolicySpecTlsCaCertRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusInput)(nil)).Elem(), BackendTLSPolicyStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusPtrInput)(nil)).Elem(), BackendTLSPolicyStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusAncestorsInput)(nil)).Elem(), BackendTLSPolicyStatusAncestorsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusAncestorsArrayInput)(nil)).Elem(), BackendTLSPolicyStatusAncestorsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusAncestorsAncestorRefInput)(nil)).Elem(), BackendTLSPolicyStatusAncestorsAncestorRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusAncestorsConditionsInput)(nil)).Elem(), BackendTLSPolicyStatusAncestorsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendTLSPolicyStatusAncestorsConditionsArrayInput)(nil)).Elem(), BackendTLSPolicyStatusAncestorsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecPtrInput)(nil)).Elem(), GRPCRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsInput)(nil)).Elem(), GRPCRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecParentRefsArrayInput)(nil)).Elem(), GRPCRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesInput)(nil)).Elem(), GRPCRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersExtensionRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersExtensionRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersRequestMirrorBackendRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayInput)(nil)).Elem(), GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesHeadersArrayInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesHeadersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteSpecRulesMatchesMethodPtrInput)(nil)).Elem(), GRPCRouteSpecRulesMatchesMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusPtrInput)(nil)).Elem(), GRPCRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsInput)(nil)).Elem(), GRPCRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsConditionsArrayInput)(nil)).Elem(), GRPCRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GRPCRouteStatusParentsParentRefInput)(nil)).Elem(), GRPCRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecInput)(nil)).Elem(), ReferenceGrantSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecPtrInput)(nil)).Elem(), ReferenceGrantSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromInput)(nil)).Elem(), ReferenceGrantSpecFromArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecFromArrayInput)(nil)).Elem(), ReferenceGrantSpecFromArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToInput)(nil)).Elem(), ReferenceGrantSpecToArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReferenceGrantSpecToArrayInput)(nil)).Elem(), ReferenceGrantSpecToArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecInput)(nil)).Elem(), TCPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecPtrInput)(nil)).Elem(), TCPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsInput)(nil)).Elem(), TCPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsArrayInput)(nil)).Elem(), TCPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesInput)(nil)).Elem(), TCPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesArrayInput)(nil)).Elem(), TCPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusInput)(nil)).Elem(), TCPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusPtrInput)(nil)).Elem(), TCPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsInput)(nil)).Elem(), TCPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsArrayInput)(nil)).Elem(), TCPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsInput)(nil)).Elem(), TCPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), TCPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsParentRefInput)(nil)).Elem(), TCPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecInput)(nil)).Elem(), TLSRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecPtrInput)(nil)).Elem(), TLSRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsInput)(nil)).Elem(), TLSRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsArrayInput)(nil)).Elem(), TLSRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesInput)(nil)).Elem(), TLSRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesArrayInput)(nil)).Elem(), TLSRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusInput)(nil)).Elem(), TLSRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusPtrInput)(nil)).Elem(), TLSRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsInput)(nil)).Elem(), TLSRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsArrayInput)(nil)).Elem(), TLSRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsInput)(nil)).Elem(), TLSRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsArrayInput)(nil)).Elem(), TLSRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsParentRefInput)(nil)).Elem(), TLSRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecInput)(nil)).Elem(), UDPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecPtrInput)(nil)).Elem(), UDPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsInput)(nil)).Elem(), UDPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsArrayInput)(nil)).Elem(), UDPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesInput)(nil)).Elem(), UDPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesArrayInput)(nil)).Elem(), UDPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusInput)(nil)).Elem(), UDPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusPtrInput)(nil)).Elem(), UDPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsInput)(nil)).Elem(), UDPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsArrayInput)(nil)).Elem(), UDPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsInput)(nil)).Elem(), UDPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), UDPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsParentRefInput)(nil)).Elem(), UDPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecPtrOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTargetRefOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTargetRefPtrOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTlsOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTlsPtrOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTlsCaCertRefsOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicySpecTlsCaCertRefsArrayOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusPtrOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusAncestorsOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusAncestorsArrayOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusAncestorsAncestorRefOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusAncestorsConditionsOutput{})
	pulumi.RegisterOutputType(BackendTLSPolicyStatusAncestorsConditionsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersExtensionRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersRequestMirrorBackendRefPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierAddArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesFiltersResponseHeaderModifierSetArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesHeadersArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodOutput{})
	pulumi.RegisterOutputType(GRPCRouteSpecRulesMatchesMethodPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(GRPCRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecPtrOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecFromArrayOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToOutput{})
	pulumi.RegisterOutputType(ReferenceGrantSpecToArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsParentRefOutput{})
}
