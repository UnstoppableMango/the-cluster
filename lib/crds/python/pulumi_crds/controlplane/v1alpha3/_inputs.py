# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities

__all__ = [
    'TalosControlPlaneSpecControlPlaneConfigControlplaneConfigPatchesArgs',
    'TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs',
    'TalosControlPlaneSpecControlPlaneConfigControlplaneArgs',
    'TalosControlPlaneSpecControlPlaneConfigInitConfigPatchesArgs',
    'TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs',
    'TalosControlPlaneSpecControlPlaneConfigInitArgs',
    'TalosControlPlaneSpecControlPlaneConfigArgs',
    'TalosControlPlaneSpecInfrastructureTemplateArgs',
    'TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs',
    'TalosControlPlaneSpecRolloutStrategyArgs',
    'TalosControlPlaneSpecArgs',
    'TalosControlPlaneStatusConditionsArgs',
    'TalosControlPlaneStatusArgs',
]

@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigControlplaneConfigPatchesArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 path: pulumi.Input[str],
                 value: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[str]] = None):
        """
        Set hostname in the machine configuration to some value.
        :param pulumi.Input[str] source: Source of the hostname. 
                Allowed values: "MachineName" (use linked Machine's Name).
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Source of the hostname. 
         Allowed values: "MachineName" (use linked Machine's Name).
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigControlplaneArgs:
    def __init__(__self__, *,
                 generate_type: pulumi.Input[str],
                 config_patches: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneConfigPatchesArgs']]]] = None,
                 data: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs']] = None,
                 talos_version: Optional[pulumi.Input[str]] = None):
        """
        TalosConfigSpec defines the desired state of TalosConfig
        :param pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs'] hostname: Set hostname in the machine configuration to some value.
        """
        pulumi.set(__self__, "generate_type", generate_type)
        if config_patches is not None:
            pulumi.set(__self__, "config_patches", config_patches)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if talos_version is not None:
            pulumi.set(__self__, "talos_version", talos_version)

    @property
    @pulumi.getter(name="generateType")
    def generate_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "generate_type")

    @generate_type.setter
    def generate_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "generate_type", value)

    @property
    @pulumi.getter(name="configPatches")
    def config_patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneConfigPatchesArgs']]]]:
        return pulumi.get(self, "config_patches")

    @config_patches.setter
    def config_patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneConfigPatchesArgs']]]]):
        pulumi.set(self, "config_patches", value)

    @property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs']]:
        """
        Set hostname in the machine configuration to some value.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="talosVersion")
    def talos_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "talos_version")

    @talos_version.setter
    def talos_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "talos_version", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigInitConfigPatchesArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 path: pulumi.Input[str],
                 value: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[str]] = None):
        """
        Set hostname in the machine configuration to some value.
        :param pulumi.Input[str] source: Source of the hostname. 
                Allowed values: "MachineName" (use linked Machine's Name).
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Source of the hostname. 
         Allowed values: "MachineName" (use linked Machine's Name).
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigInitArgs:
    def __init__(__self__, *,
                 generate_type: pulumi.Input[str],
                 config_patches: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitConfigPatchesArgs']]]] = None,
                 data: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs']] = None,
                 talos_version: Optional[pulumi.Input[str]] = None):
        """
        Deprecated: starting from cacppt v0.4.0 provider doesn't use init configs.
        :param pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs'] hostname: Set hostname in the machine configuration to some value.
        """
        pulumi.set(__self__, "generate_type", generate_type)
        if config_patches is not None:
            pulumi.set(__self__, "config_patches", config_patches)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if talos_version is not None:
            pulumi.set(__self__, "talos_version", talos_version)

    @property
    @pulumi.getter(name="generateType")
    def generate_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "generate_type")

    @generate_type.setter
    def generate_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "generate_type", value)

    @property
    @pulumi.getter(name="configPatches")
    def config_patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitConfigPatchesArgs']]]]:
        return pulumi.get(self, "config_patches")

    @config_patches.setter
    def config_patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitConfigPatchesArgs']]]]):
        pulumi.set(self, "config_patches", value)

    @property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs']]:
        """
        Set hostname in the machine configuration to some value.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="talosVersion")
    def talos_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "talos_version")

    @talos_version.setter
    def talos_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "talos_version", value)


@pulumi.input_type
class TalosControlPlaneSpecControlPlaneConfigArgs:
    def __init__(__self__, *,
                 controlplane: pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneArgs'],
                 init: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitArgs']] = None):
        """
        ControlPlaneConfig is a two TalosConfigSpecs to use for initializing and joining machines to the control plane.
        :param pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneArgs'] controlplane: TalosConfigSpec defines the desired state of TalosConfig
        :param pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitArgs'] init: Deprecated: starting from cacppt v0.4.0 provider doesn't use init configs.
        """
        pulumi.set(__self__, "controlplane", controlplane)
        if init is not None:
            pulumi.set(__self__, "init", init)

    @property
    @pulumi.getter
    def controlplane(self) -> pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneArgs']:
        """
        TalosConfigSpec defines the desired state of TalosConfig
        """
        return pulumi.get(self, "controlplane")

    @controlplane.setter
    def controlplane(self, value: pulumi.Input['TalosControlPlaneSpecControlPlaneConfigControlplaneArgs']):
        pulumi.set(self, "controlplane", value)

    @property
    @pulumi.getter
    def init(self) -> Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitArgs']]:
        """
        Deprecated: starting from cacppt v0.4.0 provider doesn't use init configs.
        """
        return pulumi.get(self, "init")

    @init.setter
    def init(self, value: Optional[pulumi.Input['TalosControlPlaneSpecControlPlaneConfigInitArgs']]):
        pulumi.set(self, "init", value)


@pulumi.input_type
class TalosControlPlaneSpecInfrastructureTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureTemplate is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[Union[int, str]]] = None):
        """
        Rolling update config params. Present only if RolloutStrategyType = RollingUpdate.
        :param pulumi.Input[Union[int, str]] max_surge: The maximum number of control planes that can be scheduled above or under the desired number of control planes. Value can be an absolute number 1 or 0. Defaults to 1. Example: when this is set to 1, the control plane can be scaled up immediately when the rolling update starts.
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of control planes that can be scheduled above or under the desired number of control planes. Value can be an absolute number 1 or 0. Defaults to 1. Example: when this is set to 1, the control plane can be scaled up immediately when the rolling update starts.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_surge", value)


@pulumi.input_type
class TalosControlPlaneSpecRolloutStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        The RolloutStrategy to use to replace control plane machines with new ones.
        :param pulumi.Input['TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs'] rolling_update: Rolling update config params. Present only if RolloutStrategyType = RollingUpdate.
        :param pulumi.Input[str] type: Change rollout strategy. 
                Supported strategies: * "RollingUpdate". * "OnDelete" 
                Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs']]:
        """
        Rolling update config params. Present only if RolloutStrategyType = RollingUpdate.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Change rollout strategy. 
         Supported strategies: * "RollingUpdate". * "OnDelete" 
         Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TalosControlPlaneSpecArgs:
    def __init__(__self__, *,
                 control_plane_config: pulumi.Input['TalosControlPlaneSpecControlPlaneConfigArgs'],
                 infrastructure_template: pulumi.Input['TalosControlPlaneSpecInfrastructureTemplateArgs'],
                 version: pulumi.Input[str],
                 replicas: Optional[pulumi.Input[int]] = None,
                 rollout_strategy: Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyArgs']] = None):
        """
        TalosControlPlaneSpec defines the desired state of TalosControlPlane
        :param pulumi.Input['TalosControlPlaneSpecControlPlaneConfigArgs'] control_plane_config: ControlPlaneConfig is a two TalosConfigSpecs to use for initializing and joining machines to the control plane.
        :param pulumi.Input['TalosControlPlaneSpecInfrastructureTemplateArgs'] infrastructure_template: InfrastructureTemplate is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] version: Version defines the desired Kubernetes version.
        :param pulumi.Input[int] replicas: Number of desired machines. Defaults to 1. When stacked etcd is used only odd numbers are permitted, as per [etcd best practice](https://etcd.io/docs/v3.3.12/faq/#why-an-odd-number-of-cluster-members). This is a pointer to distinguish between explicit zero and not specified.
        :param pulumi.Input['TalosControlPlaneSpecRolloutStrategyArgs'] rollout_strategy: The RolloutStrategy to use to replace control plane machines with new ones.
        """
        pulumi.set(__self__, "control_plane_config", control_plane_config)
        pulumi.set(__self__, "infrastructure_template", infrastructure_template)
        pulumi.set(__self__, "version", version)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if rollout_strategy is not None:
            pulumi.set(__self__, "rollout_strategy", rollout_strategy)

    @property
    @pulumi.getter(name="controlPlaneConfig")
    def control_plane_config(self) -> pulumi.Input['TalosControlPlaneSpecControlPlaneConfigArgs']:
        """
        ControlPlaneConfig is a two TalosConfigSpecs to use for initializing and joining machines to the control plane.
        """
        return pulumi.get(self, "control_plane_config")

    @control_plane_config.setter
    def control_plane_config(self, value: pulumi.Input['TalosControlPlaneSpecControlPlaneConfigArgs']):
        pulumi.set(self, "control_plane_config", value)

    @property
    @pulumi.getter(name="infrastructureTemplate")
    def infrastructure_template(self) -> pulumi.Input['TalosControlPlaneSpecInfrastructureTemplateArgs']:
        """
        InfrastructureTemplate is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_template")

    @infrastructure_template.setter
    def infrastructure_template(self, value: pulumi.Input['TalosControlPlaneSpecInfrastructureTemplateArgs']):
        pulumi.set(self, "infrastructure_template", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version defines the desired Kubernetes version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Number of desired machines. Defaults to 1. When stacked etcd is used only odd numbers are permitted, as per [etcd best practice](https://etcd.io/docs/v3.3.12/faq/#why-an-odd-number-of-cluster-members). This is a pointer to distinguish between explicit zero and not specified.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="rolloutStrategy")
    def rollout_strategy(self) -> Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyArgs']]:
        """
        The RolloutStrategy to use to replace control plane machines with new ones.
        """
        return pulumi.get(self, "rollout_strategy")

    @rollout_strategy.setter
    def rollout_strategy(self, value: Optional[pulumi.Input['TalosControlPlaneSpecRolloutStrategyArgs']]):
        pulumi.set(self, "rollout_strategy", value)


@pulumi.input_type
class TalosControlPlaneStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class TalosControlPlaneStatusArgs:
    def __init__(__self__, *,
                 bootstrapped: Optional[pulumi.Input[bool]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneStatusConditionsArgs']]]] = None,
                 failure_message: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 initialized: Optional[pulumi.Input[bool]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 ready: Optional[pulumi.Input[bool]] = None,
                 ready_replicas: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 unavailable_replicas: Optional[pulumi.Input[int]] = None):
        """
        TalosControlPlaneStatus defines the observed state of TalosControlPlane
        :param pulumi.Input[bool] bootstrapped: Bootstrapped denotes whether any nodes received bootstrap request which is required to start etcd and Kubernetes components in Talos.
        :param pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneStatusConditionsArgs']]] conditions: Conditions defines current service state of the KubeadmControlPlane.
        :param pulumi.Input[str] failure_message: ErrorMessage indicates that there is a terminal problem reconciling the state, and will be set to a descriptive error message.
        :param pulumi.Input[str] failure_reason: FailureReason indicates that there is a terminal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        :param pulumi.Input[bool] initialized: Initialized denotes whether or not the control plane has the uploaded talos-config configmap.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[bool] ready: Ready denotes that the TalosControlPlane API Server is ready to receive requests.
        :param pulumi.Input[int] ready_replicas: Total number of fully running and ready control plane machines.
        :param pulumi.Input[int] replicas: Total number of non-terminated machines targeted by this control plane (their labels match the selector).
        :param pulumi.Input[str] selector: Selector is the label selector in string format to avoid introspection by clients, and is used to provide the CRD-based integration for the scale subresource and additional integrations for things like kubectl describe.. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        :param pulumi.Input[int] unavailable_replicas: Total number of unavailable machines targeted by this control plane. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet ready or machines that still have not been created.
        """
        if bootstrapped is not None:
            pulumi.set(__self__, "bootstrapped", bootstrapped)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if initialized is not None:
            pulumi.set(__self__, "initialized", initialized)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unavailable_replicas is not None:
            pulumi.set(__self__, "unavailable_replicas", unavailable_replicas)

    @property
    @pulumi.getter
    def bootstrapped(self) -> Optional[pulumi.Input[bool]]:
        """
        Bootstrapped denotes whether any nodes received bootstrap request which is required to start etcd and Kubernetes components in Talos.
        """
        return pulumi.get(self, "bootstrapped")

    @bootstrapped.setter
    def bootstrapped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bootstrapped", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the KubeadmControlPlane.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TalosControlPlaneStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[pulumi.Input[str]]:
        """
        ErrorMessage indicates that there is a terminal problem reconciling the state, and will be set to a descriptive error message.
        """
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        FailureReason indicates that there is a terminal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter
    def initialized(self) -> Optional[pulumi.Input[bool]]:
        """
        Initialized denotes whether or not the control plane has the uploaded talos-config configmap.
        """
        return pulumi.get(self, "initialized")

    @initialized.setter
    def initialized(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "initialized", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def ready(self) -> Optional[pulumi.Input[bool]]:
        """
        Ready denotes that the TalosControlPlane API Server is ready to receive requests.
        """
        return pulumi.get(self, "ready")

    @ready.setter
    def ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ready", value)

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of fully running and ready control plane machines.
        """
        return pulumi.get(self, "ready_replicas")

    @ready_replicas.setter
    def ready_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ready_replicas", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of non-terminated machines targeted by this control plane (their labels match the selector).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Selector is the label selector in string format to avoid introspection by clients, and is used to provide the CRD-based integration for the scale subresource and additional integrations for things like kubectl describe.. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="unavailableReplicas")
    def unavailable_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of unavailable machines targeted by this control plane. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet ready or machines that still have not been created.
        """
        return pulumi.get(self, "unavailable_replicas")

    @unavailable_replicas.setter
    def unavailable_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unavailable_replicas", value)


