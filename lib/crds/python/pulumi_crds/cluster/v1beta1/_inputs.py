# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities

__all__ = [
    'ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs',
    'ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs',
    'ClusterClassSpecControlPlaneMachineHealthCheckArgs',
    'ClusterClassSpecControlPlaneMachineInfrastructureRefArgs',
    'ClusterClassSpecControlPlaneMachineInfrastructureArgs',
    'ClusterClassSpecControlPlaneMetadataArgs',
    'ClusterClassSpecControlPlaneNamingStrategyArgs',
    'ClusterClassSpecControlPlaneRefArgs',
    'ClusterClassSpecControlPlaneArgs',
    'ClusterClassSpecInfrastructureRefArgs',
    'ClusterClassSpecInfrastructureArgs',
    'ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs',
    'ClusterClassSpecPatchesDefinitionsJsonPatchesArgs',
    'ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs',
    'ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs',
    'ClusterClassSpecPatchesDefinitionsSelectorArgs',
    'ClusterClassSpecPatchesDefinitionsArgs',
    'ClusterClassSpecPatchesExternalArgs',
    'ClusterClassSpecPatchesArgs',
    'ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs',
    'ClusterClassSpecVariablesSchemaArgs',
    'ClusterClassSpecVariablesArgs',
    'ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs',
    'ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs',
    'ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs',
    'ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs',
    'ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs',
    'ClusterClassSpecWorkersMachineDeploymentsStrategyArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateArgs',
    'ClusterClassSpecWorkersMachineDeploymentsArgs',
    'ClusterClassSpecWorkersArgs',
    'ClusterClassSpecArgs',
    'ClusterClassStatusConditionsArgs',
    'ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs',
    'ClusterClassStatusVariablesDefinitionsSchemaArgs',
    'ClusterClassStatusVariablesDefinitionsArgs',
    'ClusterClassStatusVariablesArgs',
    'ClusterClassStatusArgs',
    'ClusterSpecClusterNetworkPodsArgs',
    'ClusterSpecClusterNetworkServicesArgs',
    'ClusterSpecClusterNetworkArgs',
    'ClusterSpecControlPlaneEndpointArgs',
    'ClusterSpecControlPlaneRefArgs',
    'ClusterSpecInfrastructureRefArgs',
    'ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs',
    'ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs',
    'ClusterSpecTopologyControlPlaneMachineHealthCheckArgs',
    'ClusterSpecTopologyControlPlaneMetadataArgs',
    'ClusterSpecTopologyControlPlaneArgs',
    'ClusterSpecTopologyVariablesArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs',
    'ClusterSpecTopologyWorkersMachineDeploymentsArgs',
    'ClusterSpecTopologyWorkersArgs',
    'ClusterSpecTopologyArgs',
    'ClusterSpecArgs',
    'ClusterStatusConditionsArgs',
    'ClusterStatusFailureDomainsArgs',
    'ClusterStatusArgs',
    'MachineDeploymentSpecSelectorMatchExpressionsArgs',
    'MachineDeploymentSpecSelectorArgs',
    'MachineDeploymentSpecStrategyRollingUpdateArgs',
    'MachineDeploymentSpecStrategyArgs',
    'MachineDeploymentSpecTemplateMetadataArgs',
    'MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs',
    'MachineDeploymentSpecTemplateSpecBootstrapArgs',
    'MachineDeploymentSpecTemplateSpecInfrastructureRefArgs',
    'MachineDeploymentSpecTemplateSpecArgs',
    'MachineDeploymentSpecTemplateArgs',
    'MachineDeploymentSpecArgs',
    'MachineDeploymentStatusConditionsArgs',
    'MachineDeploymentStatusArgs',
    'MachineHealthCheckSpecRemediationTemplateArgs',
    'MachineHealthCheckSpecSelectorMatchExpressionsArgs',
    'MachineHealthCheckSpecSelectorArgs',
    'MachineHealthCheckSpecUnhealthyConditionsArgs',
    'MachineHealthCheckSpecArgs',
    'MachineHealthCheckStatusConditionsArgs',
    'MachineHealthCheckStatusArgs',
    'MachinePoolSpecTemplateMetadataArgs',
    'MachinePoolSpecTemplateSpecBootstrapConfigRefArgs',
    'MachinePoolSpecTemplateSpecBootstrapArgs',
    'MachinePoolSpecTemplateSpecInfrastructureRefArgs',
    'MachinePoolSpecTemplateSpecArgs',
    'MachinePoolSpecTemplateArgs',
    'MachinePoolSpecArgs',
    'MachinePoolStatusConditionsArgs',
    'MachinePoolStatusNodeRefsArgs',
    'MachinePoolStatusArgs',
    'MachineSetSpecSelectorMatchExpressionsArgs',
    'MachineSetSpecSelectorArgs',
    'MachineSetSpecTemplateMetadataArgs',
    'MachineSetSpecTemplateSpecBootstrapConfigRefArgs',
    'MachineSetSpecTemplateSpecBootstrapArgs',
    'MachineSetSpecTemplateSpecInfrastructureRefArgs',
    'MachineSetSpecTemplateSpecArgs',
    'MachineSetSpecTemplateArgs',
    'MachineSetSpecArgs',
    'MachineSetStatusConditionsArgs',
    'MachineSetStatusArgs',
    'MachineSpecBootstrapConfigRefArgs',
    'MachineSpecBootstrapArgs',
    'MachineSpecInfrastructureRefArgs',
    'MachineSpecArgs',
    'MachineStatusAddressesArgs',
    'MachineStatusConditionsArgs',
    'MachineStatusNodeInfoArgs',
    'MachineStatusNodeRefArgs',
    'MachineStatusArgs',
]

@pulumi.input_type
class ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneMachineHealthCheckArgs:
    def __init__(__self__, *,
                 max_unhealthy: Optional[pulumi.Input[Union[int, str]]] = None,
                 node_startup_timeout: Optional[pulumi.Input[str]] = None,
                 remediation_template: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs']] = None,
                 unhealthy_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None):
        """
        MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass. This field is supported if and only if the ControlPlane provider template referenced above is Machine based and supports setting replicas.
        :param pulumi.Input[Union[int, str]] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param pulumi.Input[str] node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        :param pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs'] remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param pulumi.Input[str] unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_conditions is not None:
            pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @node_startup_timeout.setter
    def node_startup_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_startup_timeout", value)

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs']]:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @remediation_template.setter
    def remediation_template(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplateArgs']]):
        pulumi.set(self, "remediation_template", value)

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]]:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @unhealthy_conditions.setter
    def unhealthy_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]]):
        pulumi.set(self, "unhealthy_conditions", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneMachineInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneMachineInfrastructureArgs:
    def __init__(__self__, *,
                 ref: pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureRefArgs']):
        """
        MachineInfrastructure defines the metadata and infrastructure information for control plane machines. 
         This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        :param pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureRefArgs'] ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureRefArgs']:
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureRefArgs']):
        pulumi.set(self, "ref", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         This field is supported if and only if the control plane provider template referenced is Machine based.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneNamingStrategyArgs:
    def __init__(__self__, *,
                 template: Optional[pulumi.Input[str]] = None):
        """
        NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
        :param pulumi.Input[str] template: Template defines the template to use for generating the name of the ControlPlane object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        Template defines the template to use for generating the name of the ControlPlane object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecControlPlaneArgs:
    def __init__(__self__, *,
                 ref: pulumi.Input['ClusterClassSpecControlPlaneRefArgs'],
                 machine_health_check: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckArgs']] = None,
                 machine_infrastructure: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureArgs']] = None,
                 metadata: Optional[pulumi.Input['ClusterClassSpecControlPlaneMetadataArgs']] = None,
                 naming_strategy: Optional[pulumi.Input['ClusterClassSpecControlPlaneNamingStrategyArgs']] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None):
        """
        ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        :param pulumi.Input['ClusterClassSpecControlPlaneRefArgs'] ref: Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckArgs'] machine_health_check: MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass. This field is supported if and only if the ControlPlane provider template referenced above is Machine based and supports setting replicas.
        :param pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureArgs'] machine_infrastructure: MachineInfrastructure defines the metadata and infrastructure information for control plane machines. 
                This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        :param pulumi.Input['ClusterClassSpecControlPlaneMetadataArgs'] metadata: Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
                This field is supported if and only if the control plane provider template referenced is Machine based.
        :param pulumi.Input['ClusterClassSpecControlPlaneNamingStrategyArgs'] naming_strategy: NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology.
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology.
        """
        pulumi.set(__self__, "ref", ref)
        if machine_health_check is not None:
            pulumi.set(__self__, "machine_health_check", machine_health_check)
        if machine_infrastructure is not None:
            pulumi.set(__self__, "machine_infrastructure", machine_infrastructure)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if naming_strategy is not None:
            pulumi.set(__self__, "naming_strategy", naming_strategy)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input['ClusterClassSpecControlPlaneRefArgs']:
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input['ClusterClassSpecControlPlaneRefArgs']):
        pulumi.set(self, "ref", value)

    @property
    @pulumi.getter(name="machineHealthCheck")
    def machine_health_check(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckArgs']]:
        """
        MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass. This field is supported if and only if the ControlPlane provider template referenced above is Machine based and supports setting replicas.
        """
        return pulumi.get(self, "machine_health_check")

    @machine_health_check.setter
    def machine_health_check(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineHealthCheckArgs']]):
        pulumi.set(self, "machine_health_check", value)

    @property
    @pulumi.getter(name="machineInfrastructure")
    def machine_infrastructure(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureArgs']]:
        """
        MachineInfrastructure defines the metadata and infrastructure information for control plane machines. 
         This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        """
        return pulumi.get(self, "machine_infrastructure")

    @machine_infrastructure.setter
    def machine_infrastructure(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneMachineInfrastructureArgs']]):
        pulumi.set(self, "machine_infrastructure", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneMetadataArgs']]:
        """
        Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         This field is supported if and only if the control plane provider template referenced is Machine based.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="namingStrategy")
    def naming_strategy(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneNamingStrategyArgs']]:
        """
        NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
        """
        return pulumi.get(self, "naming_strategy")

    @naming_strategy.setter
    def naming_strategy(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneNamingStrategyArgs']]):
        pulumi.set(self, "naming_strategy", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology.
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)


@pulumi.input_type
class ClusterClassSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecInfrastructureArgs:
    def __init__(__self__, *,
                 ref: pulumi.Input['ClusterClassSpecInfrastructureRefArgs']):
        """
        Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        :param pulumi.Input['ClusterClassSpecInfrastructureRefArgs'] ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input['ClusterClassSpecInfrastructureRefArgs']:
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input['ClusterClassSpecInfrastructureRefArgs']):
        pulumi.set(self, "ref", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs:
    def __init__(__self__, *,
                 template: Optional[pulumi.Input[str]] = None,
                 variable: Optional[pulumi.Input[str]] = None):
        """
        ValueFrom defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time.
        :param pulumi.Input[str] template: Template is the Go template to be used to calculate the value. A template can reference variables defined in .spec.variables and builtin variables. Note: The template must evaluate to a valid YAML or JSON value.
        :param pulumi.Input[str] variable: Variable is the variable to be used as value. Variable can be one of the variables defined in .spec.variables or a builtin variable.
        """
        if template is not None:
            pulumi.set(__self__, "template", template)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        Template is the Go template to be used to calculate the value. A template can reference variables defined in .spec.variables and builtin variables. Note: The template must evaluate to a valid YAML or JSON value.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def variable(self) -> Optional[pulumi.Input[str]]:
        """
        Variable is the variable to be used as value. Variable can be one of the variables defined in .spec.variables or a builtin variable.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variable", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsJsonPatchesArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 path: pulumi.Input[str],
                 value: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 value_from: Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs']] = None):
        """
        JSONPatch defines a JSON patch.
        :param pulumi.Input[str] op: Op defines the operation of the patch. Note: Only `add`, `replace` and `remove` are supported.
        :param pulumi.Input[str] path: Path defines the path of the patch. Note: Only the spec of a template can be patched, thus the path has to start with /spec/. Note: For now the only allowed array modifications are `append` and `prepend`, i.e.: * for op: `add`: only index 0 (prepend) and - (append) are allowed * for op: `replace` or `remove`: no indexes are allowed
        :param pulumi.Input[Mapping[str, Any]] value: Value defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time. Note: We have to use apiextensionsv1.JSON instead of our JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type (unset type field). Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        :param pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs'] value_from: ValueFrom defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        Op defines the operation of the patch. Note: Only `add`, `replace` and `remove` are supported.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path defines the path of the patch. Note: Only the spec of a template can be patched, thus the path has to start with /spec/. Note: For now the only allowed array modifications are `append` and `prepend`, i.e.: * for op: `add`: only index 0 (prepend) and - (append) are allowed * for op: `replace` or `remove`: no indexes are allowed
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Value defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time. Note: We have to use apiextensionsv1.JSON instead of our JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type (unset type field). Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs']]:
        """
        ValueFrom defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesValueFromArgs']]):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs:
    def __init__(__self__, *,
                 names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: Names selects templates by class names.
        """
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Names selects templates by class names.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs:
    def __init__(__self__, *,
                 control_plane: Optional[pulumi.Input[bool]] = None,
                 infrastructure_cluster: Optional[pulumi.Input[bool]] = None,
                 machine_deployment_class: Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs']] = None):
        """
        MatchResources selects templates based on where they are referenced.
        :param pulumi.Input[bool] control_plane: ControlPlane selects templates referenced in .spec.ControlPlane. Note: this will match the controlPlane and also the controlPlane machineInfrastructure (depending on the kind and apiVersion).
        :param pulumi.Input[bool] infrastructure_cluster: InfrastructureCluster selects templates referenced in .spec.infrastructure.
        :param pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs'] machine_deployment_class: MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if infrastructure_cluster is not None:
            pulumi.set(__self__, "infrastructure_cluster", infrastructure_cluster)
        if machine_deployment_class is not None:
            pulumi.set(__self__, "machine_deployment_class", machine_deployment_class)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input[bool]]:
        """
        ControlPlane selects templates referenced in .spec.ControlPlane. Note: this will match the controlPlane and also the controlPlane machineInfrastructure (depending on the kind and apiVersion).
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter(name="infrastructureCluster")
    def infrastructure_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        InfrastructureCluster selects templates referenced in .spec.infrastructure.
        """
        return pulumi.get(self, "infrastructure_cluster")

    @infrastructure_cluster.setter
    def infrastructure_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infrastructure_cluster", value)

    @property
    @pulumi.getter(name="machineDeploymentClass")
    def machine_deployment_class(self) -> Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs']]:
        """
        MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
        """
        return pulumi.get(self, "machine_deployment_class")

    @machine_deployment_class.setter
    def machine_deployment_class(self, value: Optional[pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClassArgs']]):
        pulumi.set(self, "machine_deployment_class", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsSelectorArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 match_resources: pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs']):
        """
        Selector defines on which templates the patch should be applied.
        :param pulumi.Input[str] api_version: APIVersion filters templates by apiVersion.
        :param pulumi.Input[str] kind: Kind filters templates by kind.
        :param pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs'] match_resources: MatchResources selects templates based on where they are referenced.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "match_resources", match_resources)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[str]:
        """
        APIVersion filters templates by apiVersion.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind filters templates by kind.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="matchResources")
    def match_resources(self) -> pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs']:
        """
        MatchResources selects templates based on where they are referenced.
        """
        return pulumi.get(self, "match_resources")

    @match_resources.setter
    def match_resources(self, value: pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesArgs']):
        pulumi.set(self, "match_resources", value)


@pulumi.input_type
class ClusterClassSpecPatchesDefinitionsArgs:
    def __init__(__self__, *,
                 json_patches: pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesArgs']]],
                 selector: pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorArgs']):
        """
        PatchDefinition defines a patch which is applied to customize the referenced templates.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesArgs']]] json_patches: JSONPatches defines the patches which should be applied on the templates matching the selector. Note: Patches will be applied in the order of the array.
        :param pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorArgs'] selector: Selector defines on which templates the patch should be applied.
        """
        pulumi.set(__self__, "json_patches", json_patches)
        pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="jsonPatches")
    def json_patches(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesArgs']]]:
        """
        JSONPatches defines the patches which should be applied on the templates matching the selector. Note: Patches will be applied in the order of the array.
        """
        return pulumi.get(self, "json_patches")

    @json_patches.setter
    def json_patches(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsJsonPatchesArgs']]]):
        pulumi.set(self, "json_patches", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorArgs']:
        """
        Selector defines on which templates the patch should be applied.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input['ClusterClassSpecPatchesDefinitionsSelectorArgs']):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class ClusterClassSpecPatchesExternalArgs:
    def __init__(__self__, *,
                 discover_variables_extension: Optional[pulumi.Input[str]] = None,
                 generate_extension: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 validate_extension: Optional[pulumi.Input[str]] = None):
        """
        External defines an external patch. Note: Exactly one of Definitions or External must be set.
        :param pulumi.Input[str] discover_variables_extension: DiscoverVariablesExtension references an extension which is called to discover variables.
        :param pulumi.Input[str] generate_extension: GenerateExtension references an extension which is called to generate patches.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] settings: Settings defines key value pairs to be passed to the extensions. Values defined here take precedence over the values defined in the corresponding ExtensionConfig.
        :param pulumi.Input[str] validate_extension: ValidateExtension references an extension which is called to validate the topology.
        """
        if discover_variables_extension is not None:
            pulumi.set(__self__, "discover_variables_extension", discover_variables_extension)
        if generate_extension is not None:
            pulumi.set(__self__, "generate_extension", generate_extension)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if validate_extension is not None:
            pulumi.set(__self__, "validate_extension", validate_extension)

    @property
    @pulumi.getter(name="discoverVariablesExtension")
    def discover_variables_extension(self) -> Optional[pulumi.Input[str]]:
        """
        DiscoverVariablesExtension references an extension which is called to discover variables.
        """
        return pulumi.get(self, "discover_variables_extension")

    @discover_variables_extension.setter
    def discover_variables_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discover_variables_extension", value)

    @property
    @pulumi.getter(name="generateExtension")
    def generate_extension(self) -> Optional[pulumi.Input[str]]:
        """
        GenerateExtension references an extension which is called to generate patches.
        """
        return pulumi.get(self, "generate_extension")

    @generate_extension.setter
    def generate_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "generate_extension", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Settings defines key value pairs to be passed to the extensions. Values defined here take precedence over the values defined in the corresponding ExtensionConfig.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter(name="validateExtension")
    def validate_extension(self) -> Optional[pulumi.Input[str]]:
        """
        ValidateExtension references an extension which is called to validate the topology.
        """
        return pulumi.get(self, "validate_extension")

    @validate_extension.setter
    def validate_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validate_extension", value)


@pulumi.input_type
class ClusterClassSpecPatchesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 definitions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled_if: Optional[pulumi.Input[str]] = None,
                 external: Optional[pulumi.Input['ClusterClassSpecPatchesExternalArgs']] = None):
        """
        ClusterClassPatch defines a patch which is applied to customize the referenced templates.
        :param pulumi.Input[str] name: Name of the patch.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsArgs']]] definitions: Definitions define inline patches. Note: Patches will be applied in the order of the array. Note: Exactly one of Definitions or External must be set.
        :param pulumi.Input[str] description: Description is a human-readable description of this patch.
        :param pulumi.Input[str] enabled_if: EnabledIf is a Go template to be used to calculate if a patch should be enabled. It can reference variables defined in .spec.variables and builtin variables. The patch will be enabled if the template evaluates to `true`, otherwise it will be disabled. If EnabledIf is not set, the patch will be enabled per default.
        :param pulumi.Input['ClusterClassSpecPatchesExternalArgs'] external: External defines an external patch. Note: Exactly one of Definitions or External must be set.
        """
        pulumi.set(__self__, "name", name)
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled_if is not None:
            pulumi.set(__self__, "enabled_if", enabled_if)
        if external is not None:
            pulumi.set(__self__, "external", external)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the patch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsArgs']]]]:
        """
        Definitions define inline patches. Note: Patches will be applied in the order of the array. Note: Exactly one of Definitions or External must be set.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesDefinitionsArgs']]]]):
        pulumi.set(self, "definitions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is a human-readable description of this patch.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enabledIf")
    def enabled_if(self) -> Optional[pulumi.Input[str]]:
        """
        EnabledIf is a Go template to be used to calculate if a patch should be enabled. It can reference variables defined in .spec.variables and builtin variables. The patch will be enabled if the template evaluates to `true`, otherwise it will be disabled. If EnabledIf is not set, the patch will be enabled per default.
        """
        return pulumi.get(self, "enabled_if")

    @enabled_if.setter
    def enabled_if(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_if", value)

    @property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['ClusterClassSpecPatchesExternalArgs']]:
        """
        External defines an external patch. Note: Exactly one of Definitions or External must be set.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['ClusterClassSpecPatchesExternalArgs']]):
        pulumi.set(self, "external", value)


@pulumi.input_type
class ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enum: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 example: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 exclusive_maximum: Optional[pulumi.Input[bool]] = None,
                 exclusive_minimum: Optional[pulumi.Input[bool]] = None,
                 format: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 max_items: Optional[pulumi.Input[int]] = None,
                 max_length: Optional[pulumi.Input[int]] = None,
                 maximum: Optional[pulumi.Input[int]] = None,
                 min_items: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 required: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 unique_items: Optional[pulumi.Input[bool]] = None,
                 x_kubernetes_preserve_unknown_fields: Optional[pulumi.Input[bool]] = None):
        """
        OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        :param pulumi.Input[str] type: Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
        :param pulumi.Input[Mapping[str, Any]] additional_properties: AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[str] description: Description is a human-readable description of this variable.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] enum: Enum is the list of valid values of the variable. NOTE: Can be set for all types.
        :param pulumi.Input[Mapping[str, Any]] example: Example is an example for this variable.
        :param pulumi.Input[bool] exclusive_maximum: ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[bool] exclusive_minimum: ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[str] format: Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
        :param pulumi.Input[Mapping[str, Any]] items: Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[int] max_items: MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
        :param pulumi.Input[int] max_length: MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
        :param pulumi.Input[int] maximum: Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[int] min_items: MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
        :param pulumi.Input[int] min_length: MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
        :param pulumi.Input[int] minimum: Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[str] pattern: Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
        :param pulumi.Input[Mapping[str, Any]] properties: Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required: Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
        :param pulumi.Input[bool] unique_items: UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
        :param pulumi.Input[bool] x_kubernetes_preserve_unknown_fields: XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if exclusive_maximum is not None:
            pulumi.set(__self__, "exclusive_maximum", exclusive_maximum)
        if exclusive_minimum is not None:
            pulumi.set(__self__, "exclusive_minimum", exclusive_minimum)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)
        if x_kubernetes_preserve_unknown_fields is not None:
            pulumi.set(__self__, "x_kubernetes_preserve_unknown_fields", x_kubernetes_preserve_unknown_fields)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is a human-readable description of this variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enum(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        Enum is the list of valid values of the variable. NOTE: Can be set for all types.
        """
        return pulumi.get(self, "enum")

    @enum.setter
    def enum(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "enum", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Example is an example for this variable.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter(name="exclusiveMaximum")
    def exclusive_maximum(self) -> Optional[pulumi.Input[bool]]:
        """
        ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "exclusive_maximum")

    @exclusive_maximum.setter
    def exclusive_maximum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclusive_maximum", value)

    @property
    @pulumi.getter(name="exclusiveMinimum")
    def exclusive_minimum(self) -> Optional[pulumi.Input[bool]]:
        """
        ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "exclusive_minimum")

    @exclusive_minimum.setter
    def exclusive_minimum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclusive_minimum", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[pulumi.Input[int]]:
        """
        MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "max_items")

    @max_items.setter
    def max_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_items", value)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[int]]:
        """
        MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[pulumi.Input[int]]:
        """
        MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "min_items")

    @min_items.setter
    def min_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_items", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[bool]]:
        """
        UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unique_items", value)

    @property
    @pulumi.getter(name="x-kubernetes-preserve-unknown-fields")
    def x_kubernetes_preserve_unknown_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
        """
        return pulumi.get(self, "x_kubernetes_preserve_unknown_fields")

    @x_kubernetes_preserve_unknown_fields.setter
    def x_kubernetes_preserve_unknown_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_kubernetes_preserve_unknown_fields", value)


@pulumi.input_type
class ClusterClassSpecVariablesSchemaArgs:
    def __init__(__self__, *,
                 open_apiv3_schema: pulumi.Input['ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs']):
        """
        Schema defines the schema of the variable.
        :param pulumi.Input['ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs'] open_apiv3_schema: OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        """
        pulumi.set(__self__, "open_apiv3_schema", open_apiv3_schema)

    @property
    @pulumi.getter(name="openAPIV3Schema")
    def open_apiv3_schema(self) -> pulumi.Input['ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs']:
        """
        OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        """
        return pulumi.get(self, "open_apiv3_schema")

    @open_apiv3_schema.setter
    def open_apiv3_schema(self, value: pulumi.Input['ClusterClassSpecVariablesSchemaOpenApiv3SchemaArgs']):
        pulumi.set(self, "open_apiv3_schema", value)


@pulumi.input_type
class ClusterClassSpecVariablesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 required: pulumi.Input[bool],
                 schema: pulumi.Input['ClusterClassSpecVariablesSchemaArgs']):
        """
        ClusterClassVariable defines a variable which can be configured in the Cluster topology and used in patches.
        :param pulumi.Input[str] name: Name of the variable.
        :param pulumi.Input[bool] required: Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
        :param pulumi.Input['ClusterClassSpecVariablesSchemaArgs'] schema: Schema defines the schema of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> pulumi.Input[bool]:
        """
        Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[bool]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input['ClusterClassSpecVariablesSchemaArgs']:
        """
        Schema defines the schema of the variable.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['ClusterClassSpecVariablesSchemaArgs']):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs:
    def __init__(__self__, *,
                 max_unhealthy: Optional[pulumi.Input[Union[int, str]]] = None,
                 node_startup_timeout: Optional[pulumi.Input[str]] = None,
                 remediation_template: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']] = None,
                 unhealthy_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None):
        """
        MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
        :param pulumi.Input[Union[int, str]] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param pulumi.Input[str] node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs'] remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param pulumi.Input[str] unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_conditions is not None:
            pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @node_startup_timeout.setter
    def node_startup_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_startup_timeout", value)

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']]:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @remediation_template.setter
    def remediation_template(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']]):
        pulumi.set(self, "remediation_template", value)

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]]:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @unhealthy_conditions.setter
    def unhealthy_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]]):
        pulumi.set(self, "unhealthy_conditions", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs:
    def __init__(__self__, *,
                 template: Optional[pulumi.Input[str]] = None):
        """
        NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
        :param pulumi.Input[str] template: Template defines the template to use for generating the name of the MachineDeployment object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .machineDeployment.topologyName }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5. * `.machineDeployment.topologyName`: The name of the MachineDeployment topology (Cluster.spec.topology.workers.machineDeployments[].name).
        """
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        Template defines the template to use for generating the name of the MachineDeployment object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .machineDeployment.topologyName }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5. * `.machineDeployment.topologyName`: The name of the MachineDeployment topology (Cluster.spec.topology.workers.machineDeployments[].name).
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 delete_policy: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input[Union[int, str]]] = None,
                 max_unavailable: Optional[pulumi.Input[Union[int, str]]] = None):
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] delete_policy: DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        :param pulumi.Input[Union[int, str]] max_surge: The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        :param pulumi.Input[Union[int, str]] max_unavailable: The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[pulumi.Input[str]]:
        """
        DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        """
        return pulumi.get(self, "delete_policy")

    @delete_policy.setter
    def delete_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_policy", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        The deployment strategy to use to replace existing machines with new ones. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs'] rolling_update: Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] type: Type of deployment. Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs']]:
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deployment. Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs:
    def __init__(__self__, *,
                 ref: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs']):
        """
        Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs'] ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs']:
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs']):
        pulumi.set(self, "ref", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs:
    def __init__(__self__, *,
                 ref: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs']):
        """
        Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs'] ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs']:
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs']):
        pulumi.set(self, "ref", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateArgs:
    def __init__(__self__, *,
                 bootstrap: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs'],
                 infrastructure: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs'],
                 metadata: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs']] = None):
        """
        Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs'] bootstrap: Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs'] infrastructure: Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs'] metadata: Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "infrastructure", infrastructure)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def bootstrap(self) -> pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs']:
        """
        Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs']):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter
    def infrastructure(self) -> pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs']:
        """
        Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        """
        return pulumi.get(self, "infrastructure")

    @infrastructure.setter
    def infrastructure(self, value: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs']):
        pulumi.set(self, "infrastructure", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs']]:
        """
        Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class ClusterClassSpecWorkersMachineDeploymentsArgs:
    def __init__(__self__, *,
                 class_: pulumi.Input[str],
                 template: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateArgs'],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 machine_health_check: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs']] = None,
                 min_ready_seconds: Optional[pulumi.Input[int]] = None,
                 naming_strategy: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs']] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 strategy: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyArgs']] = None):
        """
        MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster provisioned using the `ClusterClass`.
        :param pulumi.Input[str] class_: Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateArgs'] template: Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs'] machine_health_check: MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
        :param pulumi.Input[int] min_ready_seconds: Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready) NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs'] naming_strategy: NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        :param pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyArgs'] strategy: The deployment strategy to use to replace existing machines with new ones. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "template", template)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if machine_health_check is not None:
            pulumi.set(__self__, "machine_health_check", machine_health_check)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if naming_strategy is not None:
            pulumi.set(__self__, "naming_strategy", naming_strategy)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> pulumi.Input[str]:
        """
        Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: pulumi.Input[str]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateArgs']:
        """
        Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsTemplateArgs']):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="machineHealthCheck")
    def machine_health_check(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs']]:
        """
        MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
        """
        return pulumi.get(self, "machine_health_check")

    @machine_health_check.setter
    def machine_health_check(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckArgs']]):
        pulumi.set(self, "machine_health_check", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready) NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter(name="namingStrategy")
    def naming_strategy(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs']]:
        """
        NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
        """
        return pulumi.get(self, "naming_strategy")

    @naming_strategy.setter
    def naming_strategy(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsNamingStrategyArgs']]):
        pulumi.set(self, "naming_strategy", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyArgs']]:
        """
        The deployment strategy to use to replace existing machines with new ones. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsStrategyArgs']]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class ClusterClassSpecWorkersArgs:
    def __init__(__self__, *,
                 machine_deployments: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsArgs']]]] = None):
        """
        Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsArgs']]] machine_deployments: MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
        """
        if machine_deployments is not None:
            pulumi.set(__self__, "machine_deployments", machine_deployments)

    @property
    @pulumi.getter(name="machineDeployments")
    def machine_deployments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsArgs']]]]:
        """
        MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
        """
        return pulumi.get(self, "machine_deployments")

    @machine_deployments.setter
    def machine_deployments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecWorkersMachineDeploymentsArgs']]]]):
        pulumi.set(self, "machine_deployments", value)


@pulumi.input_type
class ClusterClassSpecArgs:
    def __init__(__self__, *,
                 control_plane: Optional[pulumi.Input['ClusterClassSpecControlPlaneArgs']] = None,
                 infrastructure: Optional[pulumi.Input['ClusterClassSpecInfrastructureArgs']] = None,
                 patches: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesArgs']]]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecVariablesArgs']]]] = None,
                 workers: Optional[pulumi.Input['ClusterClassSpecWorkersArgs']] = None):
        """
        ClusterClassSpec describes the desired state of the ClusterClass.
        :param pulumi.Input['ClusterClassSpecControlPlaneArgs'] control_plane: ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        :param pulumi.Input['ClusterClassSpecInfrastructureArgs'] infrastructure: Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesArgs']]] patches: Patches defines the patches which are applied to customize referenced templates of a ClusterClass. Note: Patches will be applied in the order of the array.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecVariablesArgs']]] variables: Variables defines the variables which can be configured in the Cluster topology and are then used in patches.
        :param pulumi.Input['ClusterClassSpecWorkersArgs'] workers: Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if patches is not None:
            pulumi.set(__self__, "patches", patches)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input['ClusterClassSpecControlPlaneArgs']]:
        """
        ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input['ClusterClassSpecControlPlaneArgs']]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional[pulumi.Input['ClusterClassSpecInfrastructureArgs']]:
        """
        Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        """
        return pulumi.get(self, "infrastructure")

    @infrastructure.setter
    def infrastructure(self, value: Optional[pulumi.Input['ClusterClassSpecInfrastructureArgs']]):
        pulumi.set(self, "infrastructure", value)

    @property
    @pulumi.getter
    def patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesArgs']]]]:
        """
        Patches defines the patches which are applied to customize referenced templates of a ClusterClass. Note: Patches will be applied in the order of the array.
        """
        return pulumi.get(self, "patches")

    @patches.setter
    def patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecPatchesArgs']]]]):
        pulumi.set(self, "patches", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecVariablesArgs']]]]:
        """
        Variables defines the variables which can be configured in the Cluster topology and are then used in patches.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassSpecVariablesArgs']]]]):
        pulumi.set(self, "variables", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input['ClusterClassSpecWorkersArgs']]:
        """
        Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input['ClusterClassSpecWorkersArgs']]):
        pulumi.set(self, "workers", value)


@pulumi.input_type
class ClusterClassStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enum: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 example: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 exclusive_maximum: Optional[pulumi.Input[bool]] = None,
                 exclusive_minimum: Optional[pulumi.Input[bool]] = None,
                 format: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 max_items: Optional[pulumi.Input[int]] = None,
                 max_length: Optional[pulumi.Input[int]] = None,
                 maximum: Optional[pulumi.Input[int]] = None,
                 min_items: Optional[pulumi.Input[int]] = None,
                 min_length: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 required: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 unique_items: Optional[pulumi.Input[bool]] = None,
                 x_kubernetes_preserve_unknown_fields: Optional[pulumi.Input[bool]] = None):
        """
        OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        :param pulumi.Input[str] type: Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
        :param pulumi.Input[Mapping[str, Any]] additional_properties: AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[str] description: Description is a human-readable description of this variable.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]] enum: Enum is the list of valid values of the variable. NOTE: Can be set for all types.
        :param pulumi.Input[Mapping[str, Any]] example: Example is an example for this variable.
        :param pulumi.Input[bool] exclusive_maximum: ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[bool] exclusive_minimum: ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[str] format: Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
        :param pulumi.Input[Mapping[str, Any]] items: Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[int] max_items: MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
        :param pulumi.Input[int] max_length: MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
        :param pulumi.Input[int] maximum: Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[int] min_items: MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
        :param pulumi.Input[int] min_length: MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
        :param pulumi.Input[int] minimum: Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
        :param pulumi.Input[str] pattern: Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
        :param pulumi.Input[Mapping[str, Any]] properties: Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required: Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
        :param pulumi.Input[bool] unique_items: UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
        :param pulumi.Input[bool] x_kubernetes_preserve_unknown_fields: XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if exclusive_maximum is not None:
            pulumi.set(__self__, "exclusive_maximum", exclusive_maximum)
        if exclusive_minimum is not None:
            pulumi.set(__self__, "exclusive_minimum", exclusive_minimum)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)
        if x_kubernetes_preserve_unknown_fields is not None:
            pulumi.set(__self__, "x_kubernetes_preserve_unknown_fields", x_kubernetes_preserve_unknown_fields)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is a human-readable description of this variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enum(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        """
        Enum is the list of valid values of the variable. NOTE: Can be set for all types.
        """
        return pulumi.get(self, "enum")

    @enum.setter
    def enum(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "enum", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Example is an example for this variable.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter(name="exclusiveMaximum")
    def exclusive_maximum(self) -> Optional[pulumi.Input[bool]]:
        """
        ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "exclusive_maximum")

    @exclusive_maximum.setter
    def exclusive_maximum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclusive_maximum", value)

    @property
    @pulumi.getter(name="exclusiveMinimum")
    def exclusive_minimum(self) -> Optional[pulumi.Input[bool]]:
        """
        ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "exclusive_minimum")

    @exclusive_minimum.setter
    def exclusive_minimum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclusive_minimum", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[pulumi.Input[int]]:
        """
        MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "max_items")

    @max_items.setter
    def max_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_items", value)

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[int]]:
        """
        MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_length", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[pulumi.Input[int]]:
        """
        MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "min_items")

    @min_items.setter
    def min_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_items", value)

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[int]]:
        """
        MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_length", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[bool]]:
        """
        UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unique_items", value)

    @property
    @pulumi.getter(name="x-kubernetes-preserve-unknown-fields")
    def x_kubernetes_preserve_unknown_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
        """
        return pulumi.get(self, "x_kubernetes_preserve_unknown_fields")

    @x_kubernetes_preserve_unknown_fields.setter
    def x_kubernetes_preserve_unknown_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "x_kubernetes_preserve_unknown_fields", value)


@pulumi.input_type
class ClusterClassStatusVariablesDefinitionsSchemaArgs:
    def __init__(__self__, *,
                 open_apiv3_schema: pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs']):
        """
        Schema defines the schema of the variable.
        :param pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs'] open_apiv3_schema: OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        """
        pulumi.set(__self__, "open_apiv3_schema", open_apiv3_schema)

    @property
    @pulumi.getter(name="openAPIV3Schema")
    def open_apiv3_schema(self) -> pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs']:
        """
        OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
        """
        return pulumi.get(self, "open_apiv3_schema")

    @open_apiv3_schema.setter
    def open_apiv3_schema(self, value: pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaOpenApiv3SchemaArgs']):
        pulumi.set(self, "open_apiv3_schema", value)


@pulumi.input_type
class ClusterClassStatusVariablesDefinitionsArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 required: pulumi.Input[bool],
                 schema: pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaArgs']):
        """
        ClusterClassStatusVariableDefinition defines a variable which appears in the status of a ClusterClass.
        :param pulumi.Input[str] from_: From specifies the origin of the variable definition. This will be `inline` for variables defined in the ClusterClass or the name of a patch defined in the ClusterClass for variables discovered from a DiscoverVariables runtime extensions.
        :param pulumi.Input[bool] required: Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
        :param pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaArgs'] schema: Schema defines the schema of the variable.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        From specifies the origin of the variable definition. This will be `inline` for variables defined in the ClusterClass or the name of a patch defined in the ClusterClass for variables discovered from a DiscoverVariables runtime extensions.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def required(self) -> pulumi.Input[bool]:
        """
        Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[bool]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaArgs']:
        """
        Schema defines the schema of the variable.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['ClusterClassStatusVariablesDefinitionsSchemaArgs']):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class ClusterClassStatusVariablesArgs:
    def __init__(__self__, *,
                 definitions: pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesDefinitionsArgs']]],
                 name: pulumi.Input[str],
                 definitions_conflict: Optional[pulumi.Input[bool]] = None):
        """
        ClusterClassStatusVariable defines a variable which appears in the status of a ClusterClass.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesDefinitionsArgs']]] definitions: Definitions is a list of definitions for a variable.
        :param pulumi.Input[str] name: Name is the name of the variable.
        :param pulumi.Input[bool] definitions_conflict: DefinitionsConflict specifies whether or not there are conflicting definitions for a single variable name.
        """
        pulumi.set(__self__, "definitions", definitions)
        pulumi.set(__self__, "name", name)
        if definitions_conflict is not None:
            pulumi.set(__self__, "definitions_conflict", definitions_conflict)

    @property
    @pulumi.getter
    def definitions(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesDefinitionsArgs']]]:
        """
        Definitions is a list of definitions for a variable.
        """
        return pulumi.get(self, "definitions")

    @definitions.setter
    def definitions(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesDefinitionsArgs']]]):
        pulumi.set(self, "definitions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="definitionsConflict")
    def definitions_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        DefinitionsConflict specifies whether or not there are conflicting definitions for a single variable name.
        """
        return pulumi.get(self, "definitions_conflict")

    @definitions_conflict.setter
    def definitions_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "definitions_conflict", value)


@pulumi.input_type
class ClusterClassStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesArgs']]]] = None):
        """
        ClusterClassStatus defines the observed state of the ClusterClass.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusConditionsArgs']]] conditions: Conditions defines current observed state of the ClusterClass.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesArgs']]] variables: Variables is a list of ClusterClassStatusVariable that are defined for the ClusterClass.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusConditionsArgs']]]]:
        """
        Conditions defines current observed state of the ClusterClass.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesArgs']]]]:
        """
        Variables is a list of ClusterClassStatusVariable that are defined for the ClusterClass.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClassStatusVariablesArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class ClusterSpecClusterNetworkPodsArgs:
    def __init__(__self__, *,
                 cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        The network ranges from which Pod networks are allocated.
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cidr_blocks", value)


@pulumi.input_type
class ClusterSpecClusterNetworkServicesArgs:
    def __init__(__self__, *,
                 cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        The network ranges from which service VIPs are allocated.
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cidr_blocks", value)


@pulumi.input_type
class ClusterSpecClusterNetworkArgs:
    def __init__(__self__, *,
                 api_server_port: Optional[pulumi.Input[int]] = None,
                 pods: Optional[pulumi.Input['ClusterSpecClusterNetworkPodsArgs']] = None,
                 service_domain: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input['ClusterSpecClusterNetworkServicesArgs']] = None):
        """
        Cluster network configuration.
        :param pulumi.Input[int] api_server_port: APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
        :param pulumi.Input['ClusterSpecClusterNetworkPodsArgs'] pods: The network ranges from which Pod networks are allocated.
        :param pulumi.Input[str] service_domain: Domain name for services.
        :param pulumi.Input['ClusterSpecClusterNetworkServicesArgs'] services: The network ranges from which service VIPs are allocated.
        """
        if api_server_port is not None:
            pulumi.set(__self__, "api_server_port", api_server_port)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if service_domain is not None:
            pulumi.set(__self__, "service_domain", service_domain)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="apiServerPort")
    def api_server_port(self) -> Optional[pulumi.Input[int]]:
        """
        APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
        """
        return pulumi.get(self, "api_server_port")

    @api_server_port.setter
    def api_server_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "api_server_port", value)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input['ClusterSpecClusterNetworkPodsArgs']]:
        """
        The network ranges from which Pod networks are allocated.
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input['ClusterSpecClusterNetworkPodsArgs']]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name for services.
        """
        return pulumi.get(self, "service_domain")

    @service_domain.setter
    def service_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_domain", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input['ClusterSpecClusterNetworkServicesArgs']]:
        """
        The network ranges from which service VIPs are allocated.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input['ClusterSpecClusterNetworkServicesArgs']]):
        pulumi.set(self, "services", value)


@pulumi.input_type
class ClusterSpecControlPlaneEndpointArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 port: pulumi.Input[int]):
        """
        ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        :param pulumi.Input[str] host: The hostname on which the API server is serving.
        :param pulumi.Input[int] port: The port on which the API server is serving.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The hostname on which the API server is serving.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port on which the API server is serving.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class ClusterSpecControlPlaneRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterSpecTopologyControlPlaneMachineHealthCheckArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 max_unhealthy: Optional[pulumi.Input[Union[int, str]]] = None,
                 node_startup_timeout: Optional[pulumi.Input[str]] = None,
                 remediation_template: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs']] = None,
                 unhealthy_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None):
        """
        MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this control plane.
        :param pulumi.Input[bool] enable: Enable controls if a MachineHealthCheck should be created for the target machines. 
                If false: No MachineHealthCheck will be created. 
                If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
                If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
        :param pulumi.Input[Union[int, str]] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param pulumi.Input[str] node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        :param pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs'] remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param pulumi.Input[str] unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_conditions is not None:
            pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable controls if a MachineHealthCheck should be created for the target machines. 
         If false: No MachineHealthCheck will be created. 
         If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
         If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @node_startup_timeout.setter
    def node_startup_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_startup_timeout", value)

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs']]:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @remediation_template.setter
    def remediation_template(self, value: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplateArgs']]):
        pulumi.set(self, "remediation_template", value)

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]]:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @unhealthy_conditions.setter
    def unhealthy_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditionsArgs']]]]):
        pulumi.set(self, "unhealthy_conditions", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)


@pulumi.input_type
class ClusterSpecTopologyControlPlaneMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class ClusterSpecTopologyControlPlaneArgs:
    def __init__(__self__, *,
                 machine_health_check: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckArgs']] = None,
                 metadata: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMetadataArgs']] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        ControlPlane describes the cluster control plane.
        :param pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckArgs'] machine_health_check: MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this control plane.
        :param pulumi.Input['ClusterSpecTopologyControlPlaneMetadataArgs'] metadata: Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[int] replicas: Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
        """
        if machine_health_check is not None:
            pulumi.set(__self__, "machine_health_check", machine_health_check)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="machineHealthCheck")
    def machine_health_check(self) -> Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckArgs']]:
        """
        MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this control plane.
        """
        return pulumi.get(self, "machine_health_check")

    @machine_health_check.setter
    def machine_health_check(self, value: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMachineHealthCheckArgs']]):
        pulumi.set(self, "machine_health_check", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMetadataArgs']]:
        """
        Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


@pulumi.input_type
class ClusterSpecTopologyVariablesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[Mapping[str, Any]],
                 definition_from: Optional[pulumi.Input[str]] = None):
        """
        ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a Variable definition in the ClusterClass `status` variables.
        :param pulumi.Input[str] name: Name of the variable.
        :param pulumi.Input[Mapping[str, Any]] value: Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        :param pulumi.Input[str] definition_from: DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if definition_from is not None:
            pulumi.set(__self__, "definition_from", definition_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Mapping[str, Any]]:
        """
        Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="definitionFrom")
    def definition_from(self) -> Optional[pulumi.Input[str]]:
        """
        DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
        """
        return pulumi.get(self, "definition_from")

    @definition_from.setter
    def definition_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition_from", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 max_unhealthy: Optional[pulumi.Input[Union[int, str]]] = None,
                 node_startup_timeout: Optional[pulumi.Input[str]] = None,
                 remediation_template: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']] = None,
                 unhealthy_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None):
        """
        MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
        :param pulumi.Input[bool] enable: Enable controls if a MachineHealthCheck should be created for the target machines. 
                If false: No MachineHealthCheck will be created. 
                If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
                If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
        :param pulumi.Input[Union[int, str]] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param pulumi.Input[str] node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs'] remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param pulumi.Input[str] unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_conditions is not None:
            pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable controls if a MachineHealthCheck should be created for the target machines. 
         If false: No MachineHealthCheck will be created. 
         If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
         If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @node_startup_timeout.setter
    def node_startup_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_startup_timeout", value)

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']]:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @remediation_template.setter
    def remediation_template(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplateArgs']]):
        pulumi.set(self, "remediation_template", value)

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]]:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @unhealthy_conditions.setter
    def unhealthy_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditionsArgs']]]]):
        pulumi.set(self, "unhealthy_conditions", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 delete_policy: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input[Union[int, str]]] = None,
                 max_unavailable: Optional[pulumi.Input[Union[int, str]]] = None):
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] delete_policy: DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        :param pulumi.Input[Union[int, str]] max_surge: The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        :param pulumi.Input[Union[int, str]] max_unavailable: The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[pulumi.Input[str]]:
        """
        DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        """
        return pulumi.get(self, "delete_policy")

    @delete_policy.setter
    def delete_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_policy", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        The deployment strategy to use to replace existing machines with new ones.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs'] rolling_update: Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] type: Type of deployment. Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs']]:
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deployment. Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[Mapping[str, Any]],
                 definition_from: Optional[pulumi.Input[str]] = None):
        """
        ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a Variable definition in the ClusterClass `status` variables.
        :param pulumi.Input[str] name: Name of the variable.
        :param pulumi.Input[Mapping[str, Any]] value: Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        :param pulumi.Input[str] definition_from: DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if definition_from is not None:
            pulumi.set(__self__, "definition_from", definition_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Mapping[str, Any]]:
        """
        Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="definitionFrom")
    def definition_from(self) -> Optional[pulumi.Input[str]]:
        """
        DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
        """
        return pulumi.get(self, "definition_from")

    @definition_from.setter
    def definition_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "definition_from", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs:
    def __init__(__self__, *,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs']]]] = None):
        """
        Variables can be used to customize the MachineDeployment through patches.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs']]] overrides: Overrides can be used to override Cluster level variables.
        """
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs']]]]:
        """
        Overrides can be used to override Cluster level variables.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersMachineDeploymentsArgs:
    def __init__(__self__, *,
                 class_: pulumi.Input[str],
                 name: pulumi.Input[str],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 machine_health_check: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs']] = None,
                 metadata: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs']] = None,
                 min_ready_seconds: Optional[pulumi.Input[int]] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 strategy: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs']] = None,
                 variables: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs']] = None):
        """
        MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology. This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
        :param pulumi.Input[str] class_: Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
        :param pulumi.Input[str] name: Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs'] machine_health_check: MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs'] metadata: Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param pulumi.Input[int] min_ready_seconds: Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[int] replicas: Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs'] strategy: The deployment strategy to use to replace existing machines with new ones.
        :param pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs'] variables: Variables can be used to customize the MachineDeployment through patches.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "name", name)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if machine_health_check is not None:
            pulumi.set(__self__, "machine_health_check", machine_health_check)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> pulumi.Input[str]:
        """
        Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: pulumi.Input[str]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="machineHealthCheck")
    def machine_health_check(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs']]:
        """
        MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
        """
        return pulumi.get(self, "machine_health_check")

    @machine_health_check.setter
    def machine_health_check(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckArgs']]):
        pulumi.set(self, "machine_health_check", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs']]:
        """
        Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs']]:
        """
        The deployment strategy to use to replace existing machines with new ones.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsStrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs']]:
        """
        Variables can be used to customize the MachineDeployment through patches.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsVariablesArgs']]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class ClusterSpecTopologyWorkersArgs:
    def __init__(__self__, *,
                 machine_deployments: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsArgs']]]] = None):
        """
        Workers encapsulates the different constructs that form the worker nodes for the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsArgs']]] machine_deployments: MachineDeployments is a list of machine deployments in the cluster.
        """
        if machine_deployments is not None:
            pulumi.set(__self__, "machine_deployments", machine_deployments)

    @property
    @pulumi.getter(name="machineDeployments")
    def machine_deployments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsArgs']]]]:
        """
        MachineDeployments is a list of machine deployments in the cluster.
        """
        return pulumi.get(self, "machine_deployments")

    @machine_deployments.setter
    def machine_deployments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyWorkersMachineDeploymentsArgs']]]]):
        pulumi.set(self, "machine_deployments", value)


@pulumi.input_type
class ClusterSpecTopologyArgs:
    def __init__(__self__, *,
                 class_: pulumi.Input[str],
                 version: pulumi.Input[str],
                 control_plane: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneArgs']] = None,
                 rollout_after: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyVariablesArgs']]]] = None,
                 workers: Optional[pulumi.Input['ClusterSpecTopologyWorkersArgs']] = None):
        """
        This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        :param pulumi.Input[str] class_: The name of the ClusterClass object to create the topology.
        :param pulumi.Input[str] version: The Kubernetes version of the cluster.
        :param pulumi.Input['ClusterSpecTopologyControlPlaneArgs'] control_plane: ControlPlane describes the cluster control plane.
        :param pulumi.Input[str] rollout_after: RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments. 
                Deprecated: This field has no function and is going to be removed in the next apiVersion.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyVariablesArgs']]] variables: Variables can be used to customize the Cluster through patches. They must comply to the corresponding VariableClasses defined in the ClusterClass.
        :param pulumi.Input['ClusterSpecTopologyWorkersArgs'] workers: Workers encapsulates the different constructs that form the worker nodes for the cluster.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "version", version)
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if rollout_after is not None:
            pulumi.set(__self__, "rollout_after", rollout_after)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> pulumi.Input[str]:
        """
        The name of the ClusterClass object to create the topology.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: pulumi.Input[str]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The Kubernetes version of the cluster.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input['ClusterSpecTopologyControlPlaneArgs']]:
        """
        ControlPlane describes the cluster control plane.
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input['ClusterSpecTopologyControlPlaneArgs']]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter(name="rolloutAfter")
    def rollout_after(self) -> Optional[pulumi.Input[str]]:
        """
        RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments. 
         Deprecated: This field has no function and is going to be removed in the next apiVersion.
        """
        return pulumi.get(self, "rollout_after")

    @rollout_after.setter
    def rollout_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rollout_after", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyVariablesArgs']]]]:
        """
        Variables can be used to customize the Cluster through patches. They must comply to the corresponding VariableClasses defined in the ClusterClass.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSpecTopologyVariablesArgs']]]]):
        pulumi.set(self, "variables", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input['ClusterSpecTopologyWorkersArgs']]:
        """
        Workers encapsulates the different constructs that form the worker nodes for the cluster.
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input['ClusterSpecTopologyWorkersArgs']]):
        pulumi.set(self, "workers", value)


@pulumi.input_type
class ClusterSpecArgs:
    def __init__(__self__, *,
                 cluster_network: Optional[pulumi.Input['ClusterSpecClusterNetworkArgs']] = None,
                 control_plane_endpoint: Optional[pulumi.Input['ClusterSpecControlPlaneEndpointArgs']] = None,
                 control_plane_ref: Optional[pulumi.Input['ClusterSpecControlPlaneRefArgs']] = None,
                 infrastructure_ref: Optional[pulumi.Input['ClusterSpecInfrastructureRefArgs']] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 topology: Optional[pulumi.Input['ClusterSpecTopologyArgs']] = None):
        """
        ClusterSpec defines the desired state of Cluster.
        :param pulumi.Input['ClusterSpecClusterNetworkArgs'] cluster_network: Cluster network configuration.
        :param pulumi.Input['ClusterSpecControlPlaneEndpointArgs'] control_plane_endpoint: ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        :param pulumi.Input['ClusterSpecControlPlaneRefArgs'] control_plane_ref: ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        :param pulumi.Input['ClusterSpecInfrastructureRefArgs'] infrastructure_ref: InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        :param pulumi.Input[bool] paused: Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
        :param pulumi.Input['ClusterSpecTopologyArgs'] topology: This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        """
        if cluster_network is not None:
            pulumi.set(__self__, "cluster_network", cluster_network)
        if control_plane_endpoint is not None:
            pulumi.set(__self__, "control_plane_endpoint", control_plane_endpoint)
        if control_plane_ref is not None:
            pulumi.set(__self__, "control_plane_ref", control_plane_ref)
        if infrastructure_ref is not None:
            pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if topology is not None:
            pulumi.set(__self__, "topology", topology)

    @property
    @pulumi.getter(name="clusterNetwork")
    def cluster_network(self) -> Optional[pulumi.Input['ClusterSpecClusterNetworkArgs']]:
        """
        Cluster network configuration.
        """
        return pulumi.get(self, "cluster_network")

    @cluster_network.setter
    def cluster_network(self, value: Optional[pulumi.Input['ClusterSpecClusterNetworkArgs']]):
        pulumi.set(self, "cluster_network", value)

    @property
    @pulumi.getter(name="controlPlaneEndpoint")
    def control_plane_endpoint(self) -> Optional[pulumi.Input['ClusterSpecControlPlaneEndpointArgs']]:
        """
        ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        """
        return pulumi.get(self, "control_plane_endpoint")

    @control_plane_endpoint.setter
    def control_plane_endpoint(self, value: Optional[pulumi.Input['ClusterSpecControlPlaneEndpointArgs']]):
        pulumi.set(self, "control_plane_endpoint", value)

    @property
    @pulumi.getter(name="controlPlaneRef")
    def control_plane_ref(self) -> Optional[pulumi.Input['ClusterSpecControlPlaneRefArgs']]:
        """
        ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        """
        return pulumi.get(self, "control_plane_ref")

    @control_plane_ref.setter
    def control_plane_ref(self, value: Optional[pulumi.Input['ClusterSpecControlPlaneRefArgs']]):
        pulumi.set(self, "control_plane_ref", value)

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> Optional[pulumi.Input['ClusterSpecInfrastructureRefArgs']]:
        """
        InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @infrastructure_ref.setter
    def infrastructure_ref(self, value: Optional[pulumi.Input['ClusterSpecInfrastructureRefArgs']]):
        pulumi.set(self, "infrastructure_ref", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def topology(self) -> Optional[pulumi.Input['ClusterSpecTopologyArgs']]:
        """
        This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        """
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: Optional[pulumi.Input['ClusterSpecTopologyArgs']]):
        pulumi.set(self, "topology", value)


@pulumi.input_type
class ClusterStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class ClusterStatusFailureDomainsArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 control_plane: Optional[pulumi.Input[bool]] = None):
        """
        FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: Attributes is a free form map of attributes an infrastructure provider might use or require.
        :param pulumi.Input[bool] control_plane: ControlPlane determines if this failure domain is suitable for use by control plane machines.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Attributes is a free form map of attributes an infrastructure provider might use or require.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input[bool]]:
        """
        ControlPlane determines if this failure domain is suitable for use by control plane machines.
        """
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane", value)


@pulumi.input_type
class ClusterStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterStatusConditionsArgs']]]] = None,
                 control_plane_ready: Optional[pulumi.Input[bool]] = None,
                 failure_domains: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClusterStatusFailureDomainsArgs']]]] = None,
                 failure_message: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 infrastructure_ready: Optional[pulumi.Input[bool]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        ClusterStatus defines the observed state of Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterStatusConditionsArgs']]] conditions: Conditions defines current service state of the cluster.
        :param pulumi.Input[bool] control_plane_ready: ControlPlaneReady defines if the control plane is ready.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClusterStatusFailureDomainsArgs']]] failure_domains: FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
        :param pulumi.Input[str] failure_message: FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
        :param pulumi.Input[str] failure_reason: FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        :param pulumi.Input[bool] infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[str] phase: Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if control_plane_ready is not None:
            pulumi.set(__self__, "control_plane_ready", control_plane_ready)
        if failure_domains is not None:
            pulumi.set(__self__, "failure_domains", failure_domains)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the cluster.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="controlPlaneReady")
    def control_plane_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        ControlPlaneReady defines if the control plane is ready.
        """
        return pulumi.get(self, "control_plane_ready")

    @control_plane_ready.setter
    def control_plane_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane_ready", value)

    @property
    @pulumi.getter(name="failureDomains")
    def failure_domains(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClusterStatusFailureDomainsArgs']]]]:
        """
        FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
        """
        return pulumi.get(self, "failure_domains")

    @failure_domains.setter
    def failure_domains(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClusterStatusFailureDomainsArgs']]]]):
        pulumi.set(self, "failure_domains", value)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[pulumi.Input[str]]:
        """
        FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
        """
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @infrastructure_ready.setter
    def infrastructure_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infrastructure_ready", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


@pulumi.input_type
class MachineDeploymentSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class MachineDeploymentSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        :param pulumi.Input[Sequence[pulumi.Input['MachineDeploymentSpecSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentSpecSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class MachineDeploymentSpecStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 delete_policy: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input[Union[int, str]]] = None,
                 max_unavailable: Optional[pulumi.Input[Union[int, str]]] = None):
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] delete_policy: DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        :param pulumi.Input[Union[int, str]] max_surge: The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        :param pulumi.Input[Union[int, str]] max_unavailable: The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[pulumi.Input[str]]:
        """
        DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        """
        return pulumi.get(self, "delete_policy")

    @delete_policy.setter
    def delete_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_policy", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class MachineDeploymentSpecStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['MachineDeploymentSpecStrategyRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        The deployment strategy to use to replace existing machines with new ones.
        :param pulumi.Input['MachineDeploymentSpecStrategyRollingUpdateArgs'] rolling_update: Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param pulumi.Input[str] type: Type of deployment. Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['MachineDeploymentSpecStrategyRollingUpdateArgs']]:
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['MachineDeploymentSpecStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deployment. Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateSpecBootstrapArgs:
    def __init__(__self__, *,
                 config_ref: Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs']] = None,
                 data_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs'] config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs']]:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @config_ref.setter
    def config_ref(self, value: Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs']]):
        pulumi.set(self, "config_ref", value)

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")

    @data_secret_name.setter
    def data_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_secret_name", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateSpecArgs:
    def __init__(__self__, *,
                 bootstrap: pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapArgs'],
                 cluster_name: pulumi.Input[str],
                 infrastructure_ref: pulumi.Input['MachineDeploymentSpecTemplateSpecInfrastructureRefArgs'],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 provider_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapArgs'] bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineDeploymentSpecTemplateSpecInfrastructureRefArgs'] infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[str] provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param pulumi.Input[str] version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapArgs']:
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: pulumi.Input['MachineDeploymentSpecTemplateSpecBootstrapArgs']):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> pulumi.Input['MachineDeploymentSpecTemplateSpecInfrastructureRefArgs']:
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @infrastructure_ref.setter
    def infrastructure_ref(self, value: pulumi.Input['MachineDeploymentSpecTemplateSpecInfrastructureRefArgs']):
        pulumi.set(self, "infrastructure_ref", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MachineDeploymentSpecTemplateArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['MachineDeploymentSpecTemplateMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecArgs']] = None):
        """
        Template describes the machines that will be created.
        :param pulumi.Input['MachineDeploymentSpecTemplateMetadataArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input['MachineDeploymentSpecTemplateSpecArgs'] spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['MachineDeploymentSpecTemplateMetadataArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['MachineDeploymentSpecTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecArgs']]:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['MachineDeploymentSpecTemplateSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class MachineDeploymentSpecArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 selector: pulumi.Input['MachineDeploymentSpecSelectorArgs'],
                 template: pulumi.Input['MachineDeploymentSpecTemplateArgs'],
                 min_ready_seconds: Optional[pulumi.Input[int]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 progress_deadline_seconds: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 revision_history_limit: Optional[pulumi.Input[int]] = None,
                 rollout_after: Optional[pulumi.Input[str]] = None,
                 strategy: Optional[pulumi.Input['MachineDeploymentSpecStrategyArgs']] = None):
        """
        MachineDeploymentSpec defines the desired state of MachineDeployment.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineDeploymentSpecSelectorArgs'] selector: Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        :param pulumi.Input['MachineDeploymentSpecTemplateArgs'] template: Template describes the machines that will be created.
        :param pulumi.Input[int] min_ready_seconds: MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
        :param pulumi.Input[bool] paused: Indicates that the deployment is paused.
        :param pulumi.Input[int] progress_deadline_seconds: The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
        :param pulumi.Input[int] replicas: Number of desired machines. This is a pointer to distinguish between explicit zero and not specified. 
                Defaults to: * if the Kubernetes autoscaler min size and max size annotations are set: - if it's a new MachineDeployment, use min size - if the replicas field of the old MachineDeployment is < min size, use min size - if the replicas field of the old MachineDeployment is > max size, use max size - if the replicas field of the old MachineDeployment is in the (min size, max size) range, keep the value from the oldMD * otherwise use 1 Note: Defaulting will be run whenever the replicas field is not set: * A new MachineDeployment is created with replicas not set. * On an existing MachineDeployment the replicas field was first set and is now unset. Those cases are especially relevant for the following Kubernetes autoscaler use cases: * A new MachineDeployment is created and replicas should be managed by the autoscaler * An existing MachineDeployment which initially wasn't controlled by the autoscaler should be later controlled by the autoscaler
        :param pulumi.Input[int] revision_history_limit: The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        :param pulumi.Input[str] rollout_after: RolloutAfter is a field to indicate a rollout should be performed after the specified time even if no changes have been made to the MachineDeployment. Example: In the YAML the time can be specified in the RFC3339 format. To specify the rolloutAfter target as March 9, 2023, at 9 am UTC use "2023-03-09T09:00:00Z".
        :param pulumi.Input['MachineDeploymentSpecStrategyArgs'] strategy: The deployment strategy to use to replace existing machines with new ones.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "template", template)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if progress_deadline_seconds is not None:
            pulumi.set(__self__, "progress_deadline_seconds", progress_deadline_seconds)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if revision_history_limit is not None:
            pulumi.set(__self__, "revision_history_limit", revision_history_limit)
        if rollout_after is not None:
            pulumi.set(__self__, "rollout_after", rollout_after)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input['MachineDeploymentSpecSelectorArgs']:
        """
        Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input['MachineDeploymentSpecSelectorArgs']):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input['MachineDeploymentSpecTemplateArgs']:
        """
        Template describes the machines that will be created.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input['MachineDeploymentSpecTemplateArgs']):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the deployment is paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter(name="progressDeadlineSeconds")
    def progress_deadline_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
        """
        return pulumi.get(self, "progress_deadline_seconds")

    @progress_deadline_seconds.setter
    def progress_deadline_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "progress_deadline_seconds", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Number of desired machines. This is a pointer to distinguish between explicit zero and not specified. 
         Defaults to: * if the Kubernetes autoscaler min size and max size annotations are set: - if it's a new MachineDeployment, use min size - if the replicas field of the old MachineDeployment is < min size, use min size - if the replicas field of the old MachineDeployment is > max size, use max size - if the replicas field of the old MachineDeployment is in the (min size, max size) range, keep the value from the oldMD * otherwise use 1 Note: Defaulting will be run whenever the replicas field is not set: * A new MachineDeployment is created with replicas not set. * On an existing MachineDeployment the replicas field was first set and is now unset. Those cases are especially relevant for the following Kubernetes autoscaler use cases: * A new MachineDeployment is created and replicas should be managed by the autoscaler * An existing MachineDeployment which initially wasn't controlled by the autoscaler should be later controlled by the autoscaler
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="revisionHistoryLimit")
    def revision_history_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        """
        return pulumi.get(self, "revision_history_limit")

    @revision_history_limit.setter
    def revision_history_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision_history_limit", value)

    @property
    @pulumi.getter(name="rolloutAfter")
    def rollout_after(self) -> Optional[pulumi.Input[str]]:
        """
        RolloutAfter is a field to indicate a rollout should be performed after the specified time even if no changes have been made to the MachineDeployment. Example: In the YAML the time can be specified in the RFC3339 format. To specify the rolloutAfter target as March 9, 2023, at 9 am UTC use "2023-03-09T09:00:00Z".
        """
        return pulumi.get(self, "rollout_after")

    @rollout_after.setter
    def rollout_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rollout_after", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['MachineDeploymentSpecStrategyArgs']]:
        """
        The deployment strategy to use to replace existing machines with new ones.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['MachineDeploymentSpecStrategyArgs']]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class MachineDeploymentStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class MachineDeploymentStatusArgs:
    def __init__(__self__, *,
                 available_replicas: Optional[pulumi.Input[int]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 ready_replicas: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 unavailable_replicas: Optional[pulumi.Input[int]] = None,
                 updated_replicas: Optional[pulumi.Input[int]] = None):
        """
        MachineDeploymentStatus defines the observed state of MachineDeployment.
        :param pulumi.Input[int] available_replicas: Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
        :param pulumi.Input[Sequence[pulumi.Input['MachineDeploymentStatusConditionsArgs']]] conditions: Conditions defines current service state of the MachineDeployment.
        :param pulumi.Input[int] observed_generation: The generation observed by the deployment controller.
        :param pulumi.Input[str] phase: Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
        :param pulumi.Input[int] ready_replicas: Total number of ready machines targeted by this deployment.
        :param pulumi.Input[int] replicas: Total number of non-terminated machines targeted by this deployment (their labels match the selector).
        :param pulumi.Input[str] selector: Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        :param pulumi.Input[int] unavailable_replicas: Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
        :param pulumi.Input[int] updated_replicas: Total number of non-terminated machines targeted by this deployment that have the desired template spec.
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unavailable_replicas is not None:
            pulumi.set(__self__, "unavailable_replicas", unavailable_replicas)
        if updated_replicas is not None:
            pulumi.set(__self__, "updated_replicas", updated_replicas)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
        """
        return pulumi.get(self, "available_replicas")

    @available_replicas.setter
    def available_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_replicas", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the MachineDeployment.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineDeploymentStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation observed by the deployment controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of ready machines targeted by this deployment.
        """
        return pulumi.get(self, "ready_replicas")

    @ready_replicas.setter
    def ready_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ready_replicas", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of non-terminated machines targeted by this deployment (their labels match the selector).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="unavailableReplicas")
    def unavailable_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
        """
        return pulumi.get(self, "unavailable_replicas")

    @unavailable_replicas.setter
    def unavailable_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unavailable_replicas", value)

    @property
    @pulumi.getter(name="updatedReplicas")
    def updated_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of non-terminated machines targeted by this deployment that have the desired template spec.
        """
        return pulumi.get(self, "updated_replicas")

    @updated_replicas.setter
    def updated_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_replicas", value)


@pulumi.input_type
class MachineHealthCheckSpecRemediationTemplateArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineHealthCheckSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class MachineHealthCheckSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Label selector to match machines whose health will be exercised
        :param pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class MachineHealthCheckSpecUnhealthyConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MachineHealthCheckSpecArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 selector: pulumi.Input['MachineHealthCheckSpecSelectorArgs'],
                 unhealthy_conditions: pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecUnhealthyConditionsArgs']]],
                 max_unhealthy: Optional[pulumi.Input[Union[int, str]]] = None,
                 node_startup_timeout: Optional[pulumi.Input[str]] = None,
                 remediation_template: Optional[pulumi.Input['MachineHealthCheckSpecRemediationTemplateArgs']] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None):
        """
        Specification of machine health check policy
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineHealthCheckSpecSelectorArgs'] selector: Label selector to match machines whose health will be exercised
        :param pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecUnhealthyConditionsArgs']]] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param pulumi.Input[Union[int, str]] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param pulumi.Input[str] node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
        :param pulumi.Input['MachineHealthCheckSpecRemediationTemplateArgs'] remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param pulumi.Input[str] unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input['MachineHealthCheckSpecSelectorArgs']:
        """
        Label selector to match machines whose health will be exercised
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input['MachineHealthCheckSpecSelectorArgs']):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecUnhealthyConditionsArgs']]]:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @unhealthy_conditions.setter
    def unhealthy_conditions(self, value: pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckSpecUnhealthyConditionsArgs']]]):
        pulumi.set(self, "unhealthy_conditions", value)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[Union[int, str]]]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[Union[int, str]]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @node_startup_timeout.setter
    def node_startup_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_startup_timeout", value)

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional[pulumi.Input['MachineHealthCheckSpecRemediationTemplateArgs']]:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @remediation_template.setter
    def remediation_template(self, value: Optional[pulumi.Input['MachineHealthCheckSpecRemediationTemplateArgs']]):
        pulumi.set(self, "remediation_template", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)


@pulumi.input_type
class MachineHealthCheckStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class MachineHealthCheckStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckStatusConditionsArgs']]]] = None,
                 current_healthy: Optional[pulumi.Input[int]] = None,
                 expected_machines: Optional[pulumi.Input[int]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 remediations_allowed: Optional[pulumi.Input[int]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Most recently observed status of MachineHealthCheck resource
        :param pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckStatusConditionsArgs']]] conditions: Conditions defines current service state of the MachineHealthCheck.
        :param pulumi.Input[int] current_healthy: total number of healthy machines counted by this machine health check
        :param pulumi.Input[int] expected_machines: total number of machines counted by this machine health check
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[int] remediations_allowed: RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: Targets shows the current list of machines the machine health check is watching
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if current_healthy is not None:
            pulumi.set(__self__, "current_healthy", current_healthy)
        if expected_machines is not None:
            pulumi.set(__self__, "expected_machines", expected_machines)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if remediations_allowed is not None:
            pulumi.set(__self__, "remediations_allowed", remediations_allowed)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the MachineHealthCheck.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineHealthCheckStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="currentHealthy")
    def current_healthy(self) -> Optional[pulumi.Input[int]]:
        """
        total number of healthy machines counted by this machine health check
        """
        return pulumi.get(self, "current_healthy")

    @current_healthy.setter
    def current_healthy(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_healthy", value)

    @property
    @pulumi.getter(name="expectedMachines")
    def expected_machines(self) -> Optional[pulumi.Input[int]]:
        """
        total number of machines counted by this machine health check
        """
        return pulumi.get(self, "expected_machines")

    @expected_machines.setter
    def expected_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expected_machines", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter(name="remediationsAllowed")
    def remediations_allowed(self) -> Optional[pulumi.Input[int]]:
        """
        RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
        """
        return pulumi.get(self, "remediations_allowed")

    @remediations_allowed.setter
    def remediations_allowed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remediations_allowed", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Targets shows the current list of machines the machine health check is watching
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class MachinePoolSpecTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class MachinePoolSpecTemplateSpecBootstrapConfigRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachinePoolSpecTemplateSpecBootstrapArgs:
    def __init__(__self__, *,
                 config_ref: Optional[pulumi.Input['MachinePoolSpecTemplateSpecBootstrapConfigRefArgs']] = None,
                 data_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input['MachinePoolSpecTemplateSpecBootstrapConfigRefArgs'] config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional[pulumi.Input['MachinePoolSpecTemplateSpecBootstrapConfigRefArgs']]:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @config_ref.setter
    def config_ref(self, value: Optional[pulumi.Input['MachinePoolSpecTemplateSpecBootstrapConfigRefArgs']]):
        pulumi.set(self, "config_ref", value)

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")

    @data_secret_name.setter
    def data_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_secret_name", value)


@pulumi.input_type
class MachinePoolSpecTemplateSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachinePoolSpecTemplateSpecArgs:
    def __init__(__self__, *,
                 bootstrap: pulumi.Input['MachinePoolSpecTemplateSpecBootstrapArgs'],
                 cluster_name: pulumi.Input[str],
                 infrastructure_ref: pulumi.Input['MachinePoolSpecTemplateSpecInfrastructureRefArgs'],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 provider_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param pulumi.Input['MachinePoolSpecTemplateSpecBootstrapArgs'] bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachinePoolSpecTemplateSpecInfrastructureRefArgs'] infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[str] provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param pulumi.Input[str] version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> pulumi.Input['MachinePoolSpecTemplateSpecBootstrapArgs']:
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: pulumi.Input['MachinePoolSpecTemplateSpecBootstrapArgs']):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> pulumi.Input['MachinePoolSpecTemplateSpecInfrastructureRefArgs']:
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @infrastructure_ref.setter
    def infrastructure_ref(self, value: pulumi.Input['MachinePoolSpecTemplateSpecInfrastructureRefArgs']):
        pulumi.set(self, "infrastructure_ref", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MachinePoolSpecTemplateArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['MachinePoolSpecTemplateMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['MachinePoolSpecTemplateSpecArgs']] = None):
        """
        Template describes the machines that will be created.
        :param pulumi.Input['MachinePoolSpecTemplateMetadataArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input['MachinePoolSpecTemplateSpecArgs'] spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['MachinePoolSpecTemplateMetadataArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['MachinePoolSpecTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['MachinePoolSpecTemplateSpecArgs']]:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['MachinePoolSpecTemplateSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class MachinePoolSpecArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 template: pulumi.Input['MachinePoolSpecTemplateArgs'],
                 failure_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 min_ready_seconds: Optional[pulumi.Input[int]] = None,
                 provider_id_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        MachinePoolSpec defines the desired state of MachinePool.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachinePoolSpecTemplateArgs'] template: Template describes the machines that will be created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failure_domains: FailureDomains is the list of failure domains this MachinePool should be attached to.
        :param pulumi.Input[int] min_ready_seconds: Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready) NOTE: No logic is implemented for this field and it currently has no behaviour.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] provider_id_list: ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        :param pulumi.Input[int] replicas: Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "template", template)
        if failure_domains is not None:
            pulumi.set(__self__, "failure_domains", failure_domains)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if provider_id_list is not None:
            pulumi.set(__self__, "provider_id_list", provider_id_list)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input['MachinePoolSpecTemplateArgs']:
        """
        Template describes the machines that will be created.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input['MachinePoolSpecTemplateArgs']):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="failureDomains")
    def failure_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        FailureDomains is the list of failure domains this MachinePool should be attached to.
        """
        return pulumi.get(self, "failure_domains")

    @failure_domains.setter
    def failure_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "failure_domains", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready) NOTE: No logic is implemented for this field and it currently has no behaviour.
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter(name="providerIDList")
    def provider_id_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        """
        return pulumi.get(self, "provider_id_list")

    @provider_id_list.setter
    def provider_id_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "provider_id_list", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


@pulumi.input_type
class MachinePoolStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class MachinePoolStatusNodeRefsArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachinePoolStatusArgs:
    def __init__(__self__, *,
                 available_replicas: Optional[pulumi.Input[int]] = None,
                 bootstrap_ready: Optional[pulumi.Input[bool]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusConditionsArgs']]]] = None,
                 failure_message: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 infrastructure_ready: Optional[pulumi.Input[bool]] = None,
                 node_refs: Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusNodeRefsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 ready_replicas: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 unavailable_replicas: Optional[pulumi.Input[int]] = None):
        """
        MachinePoolStatus defines the observed state of MachinePool.
        :param pulumi.Input[int] available_replicas: The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
        :param pulumi.Input[bool] bootstrap_ready: BootstrapReady is the state of the bootstrap provider.
        :param pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusConditionsArgs']]] conditions: Conditions define the current service state of the MachinePool.
        :param pulumi.Input[str] failure_message: FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
        :param pulumi.Input[str] failure_reason: FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        :param pulumi.Input[bool] infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusNodeRefsArgs']]] node_refs: NodeRefs will point to the corresponding Nodes if it they exist.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[str] phase: Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        :param pulumi.Input[int] ready_replicas: The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
        :param pulumi.Input[int] replicas: Replicas is the most recently observed number of replicas.
        :param pulumi.Input[int] unavailable_replicas: Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if bootstrap_ready is not None:
            pulumi.set(__self__, "bootstrap_ready", bootstrap_ready)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if node_refs is not None:
            pulumi.set(__self__, "node_refs", node_refs)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if unavailable_replicas is not None:
            pulumi.set(__self__, "unavailable_replicas", unavailable_replicas)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
        """
        return pulumi.get(self, "available_replicas")

    @available_replicas.setter
    def available_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_replicas", value)

    @property
    @pulumi.getter(name="bootstrapReady")
    def bootstrap_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        BootstrapReady is the state of the bootstrap provider.
        """
        return pulumi.get(self, "bootstrap_ready")

    @bootstrap_ready.setter
    def bootstrap_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bootstrap_ready", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusConditionsArgs']]]]:
        """
        Conditions define the current service state of the MachinePool.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[pulumi.Input[str]]:
        """
        FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
        """
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @infrastructure_ready.setter
    def infrastructure_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infrastructure_ready", value)

    @property
    @pulumi.getter(name="nodeRefs")
    def node_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusNodeRefsArgs']]]]:
        """
        NodeRefs will point to the corresponding Nodes if it they exist.
        """
        return pulumi.get(self, "node_refs")

    @node_refs.setter
    def node_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachinePoolStatusNodeRefsArgs']]]]):
        pulumi.set(self, "node_refs", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
        """
        return pulumi.get(self, "ready_replicas")

    @ready_replicas.setter
    def ready_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ready_replicas", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Replicas is the most recently observed number of replicas.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="unavailableReplicas")
    def unavailable_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
        """
        return pulumi.get(self, "unavailable_replicas")

    @unavailable_replicas.setter
    def unavailable_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unavailable_replicas", value)


@pulumi.input_type
class MachineSetSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class MachineSetSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        :param pulumi.Input[Sequence[pulumi.Input['MachineSetSpecSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetSpecSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class MachineSetSpecTemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class MachineSetSpecTemplateSpecBootstrapConfigRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineSetSpecTemplateSpecBootstrapArgs:
    def __init__(__self__, *,
                 config_ref: Optional[pulumi.Input['MachineSetSpecTemplateSpecBootstrapConfigRefArgs']] = None,
                 data_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input['MachineSetSpecTemplateSpecBootstrapConfigRefArgs'] config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional[pulumi.Input['MachineSetSpecTemplateSpecBootstrapConfigRefArgs']]:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @config_ref.setter
    def config_ref(self, value: Optional[pulumi.Input['MachineSetSpecTemplateSpecBootstrapConfigRefArgs']]):
        pulumi.set(self, "config_ref", value)

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")

    @data_secret_name.setter
    def data_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_secret_name", value)


@pulumi.input_type
class MachineSetSpecTemplateSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineSetSpecTemplateSpecArgs:
    def __init__(__self__, *,
                 bootstrap: pulumi.Input['MachineSetSpecTemplateSpecBootstrapArgs'],
                 cluster_name: pulumi.Input[str],
                 infrastructure_ref: pulumi.Input['MachineSetSpecTemplateSpecInfrastructureRefArgs'],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 provider_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param pulumi.Input['MachineSetSpecTemplateSpecBootstrapArgs'] bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineSetSpecTemplateSpecInfrastructureRefArgs'] infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[str] provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param pulumi.Input[str] version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> pulumi.Input['MachineSetSpecTemplateSpecBootstrapArgs']:
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: pulumi.Input['MachineSetSpecTemplateSpecBootstrapArgs']):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> pulumi.Input['MachineSetSpecTemplateSpecInfrastructureRefArgs']:
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @infrastructure_ref.setter
    def infrastructure_ref(self, value: pulumi.Input['MachineSetSpecTemplateSpecInfrastructureRefArgs']):
        pulumi.set(self, "infrastructure_ref", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MachineSetSpecTemplateArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['MachineSetSpecTemplateMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['MachineSetSpecTemplateSpecArgs']] = None):
        """
        Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        :param pulumi.Input['MachineSetSpecTemplateMetadataArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param pulumi.Input['MachineSetSpecTemplateSpecArgs'] spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['MachineSetSpecTemplateMetadataArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['MachineSetSpecTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['MachineSetSpecTemplateSpecArgs']]:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['MachineSetSpecTemplateSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class MachineSetSpecArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 selector: pulumi.Input['MachineSetSpecSelectorArgs'],
                 delete_policy: Optional[pulumi.Input[str]] = None,
                 min_ready_seconds: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 template: Optional[pulumi.Input['MachineSetSpecTemplateArgs']] = None):
        """
        MachineSetSpec defines the desired state of MachineSet.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineSetSpecSelectorArgs'] selector: Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        :param pulumi.Input[str] delete_policy: DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
        :param pulumi.Input[int] min_ready_seconds: MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
        :param pulumi.Input[int] replicas: Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
        :param pulumi.Input['MachineSetSpecTemplateArgs'] template: Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if replicas is None:
            replicas = 1
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input['MachineSetSpecSelectorArgs']:
        """
        Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input['MachineSetSpecSelectorArgs']):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[pulumi.Input[str]]:
        """
        DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
        """
        return pulumi.get(self, "delete_policy")

    @delete_policy.setter
    def delete_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_policy", value)

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['MachineSetSpecTemplateArgs']]:
        """
        Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['MachineSetSpecTemplateArgs']]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class MachineSetStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class MachineSetStatusArgs:
    def __init__(__self__, *,
                 available_replicas: Optional[pulumi.Input[int]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetStatusConditionsArgs']]]] = None,
                 failure_message: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 fully_labeled_replicas: Optional[pulumi.Input[int]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 ready_replicas: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 selector: Optional[pulumi.Input[str]] = None):
        """
        MachineSetStatus defines the observed state of MachineSet.
        :param pulumi.Input[int] available_replicas: The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
        :param pulumi.Input[Sequence[pulumi.Input['MachineSetStatusConditionsArgs']]] conditions: Conditions defines current service state of the MachineSet.
        :param pulumi.Input[str] failure_reason: In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
                These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
        :param pulumi.Input[int] fully_labeled_replicas: The number of replicas that have labels matching the labels of the machine template of the MachineSet.
        :param pulumi.Input[int] observed_generation: ObservedGeneration reflects the generation of the most recently observed MachineSet.
        :param pulumi.Input[int] ready_replicas: The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
        :param pulumi.Input[int] replicas: Replicas is the most recently observed number of replicas.
        :param pulumi.Input[str] selector: Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fully_labeled_replicas is not None:
            pulumi.set(__self__, "fully_labeled_replicas", fully_labeled_replicas)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
        """
        return pulumi.get(self, "available_replicas")

    @available_replicas.setter
    def available_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_replicas", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the MachineSet.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineSetStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
         These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="fullyLabeledReplicas")
    def fully_labeled_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of replicas that have labels matching the labels of the machine template of the MachineSet.
        """
        return pulumi.get(self, "fully_labeled_replicas")

    @fully_labeled_replicas.setter
    def fully_labeled_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fully_labeled_replicas", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration reflects the generation of the most recently observed MachineSet.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
        """
        return pulumi.get(self, "ready_replicas")

    @ready_replicas.setter
    def ready_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ready_replicas", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Replicas is the most recently observed number of replicas.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class MachineSpecBootstrapConfigRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineSpecBootstrapArgs:
    def __init__(__self__, *,
                 config_ref: Optional[pulumi.Input['MachineSpecBootstrapConfigRefArgs']] = None,
                 data_secret_name: Optional[pulumi.Input[str]] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input['MachineSpecBootstrapConfigRefArgs'] config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param pulumi.Input[str] data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional[pulumi.Input['MachineSpecBootstrapConfigRefArgs']]:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @config_ref.setter
    def config_ref(self, value: Optional[pulumi.Input['MachineSpecBootstrapConfigRefArgs']]):
        pulumi.set(self, "config_ref", value)

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")

    @data_secret_name.setter
    def data_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_secret_name", value)


@pulumi.input_type
class MachineSpecInfrastructureRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineSpecArgs:
    def __init__(__self__, *,
                 bootstrap: pulumi.Input['MachineSpecBootstrapArgs'],
                 cluster_name: pulumi.Input[str],
                 infrastructure_ref: pulumi.Input['MachineSpecInfrastructureRefArgs'],
                 failure_domain: Optional[pulumi.Input[str]] = None,
                 node_deletion_timeout: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[str]] = None,
                 node_volume_detach_timeout: Optional[pulumi.Input[str]] = None,
                 provider_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        MachineSpec defines the desired state of Machine.
        :param pulumi.Input['MachineSpecBootstrapArgs'] bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param pulumi.Input['MachineSpecInfrastructureRefArgs'] infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param pulumi.Input[str] failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param pulumi.Input[str] node_deletion_timeout: NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        :param pulumi.Input[str] node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param pulumi.Input[str] node_volume_detach_timeout: NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        :param pulumi.Input[str] provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param pulumi.Input[str] version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_deletion_timeout is not None:
            pulumi.set(__self__, "node_deletion_timeout", node_deletion_timeout)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_volume_detach_timeout is not None:
            pulumi.set(__self__, "node_volume_detach_timeout", node_volume_detach_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> pulumi.Input['MachineSpecBootstrapArgs']:
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: pulumi.Input['MachineSpecBootstrapArgs']):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> pulumi.Input['MachineSpecInfrastructureRefArgs']:
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @infrastructure_ref.setter
    def infrastructure_ref(self, value: pulumi.Input['MachineSpecInfrastructureRefArgs']):
        pulumi.set(self, "infrastructure_ref", value)

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[pulumi.Input[str]]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @failure_domain.setter
    def failure_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_domain", value)

    @property
    @pulumi.getter(name="nodeDeletionTimeout")
    def node_deletion_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
        """
        return pulumi.get(self, "node_deletion_timeout")

    @node_deletion_timeout.setter
    def node_deletion_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_deletion_timeout", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeVolumeDetachTimeout")
    def node_volume_detach_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
        """
        return pulumi.get(self, "node_volume_detach_timeout")

    @node_volume_detach_timeout.setter
    def node_volume_detach_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_volume_detach_timeout", value)

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MachineStatusAddressesArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        MachineAddress contains information for the node's address.
        :param pulumi.Input[str] address: The machine address.
        :param pulumi.Input[str] type: Machine address type, one of Hostname, ExternalIP, InternalIP, ExternalDNS or InternalDNS.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The machine address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Machine address type, one of Hostname, ExternalIP, InternalIP, ExternalDNS or InternalDNS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MachineStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition. This field may be empty.
        :param pulumi.Input[str] reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param pulumi.Input[str] severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class MachineStatusNodeInfoArgs:
    def __init__(__self__, *,
                 architecture: pulumi.Input[str],
                 boot_id: pulumi.Input[str],
                 container_runtime_version: pulumi.Input[str],
                 kernel_version: pulumi.Input[str],
                 kube_proxy_version: pulumi.Input[str],
                 kubelet_version: pulumi.Input[str],
                 machine_id: pulumi.Input[str],
                 operating_system: pulumi.Input[str],
                 os_image: pulumi.Input[str],
                 system_uuid: pulumi.Input[str]):
        """
        NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        :param pulumi.Input[str] architecture: The Architecture reported by the node
        :param pulumi.Input[str] boot_id: Boot ID reported by the node.
        :param pulumi.Input[str] container_runtime_version: ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
        :param pulumi.Input[str] kernel_version: Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        :param pulumi.Input[str] kube_proxy_version: KubeProxy Version reported by the node.
        :param pulumi.Input[str] kubelet_version: Kubelet Version reported by the node.
        :param pulumi.Input[str] machine_id: MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
        :param pulumi.Input[str] operating_system: The Operating System reported by the node
        :param pulumi.Input[str] os_image: OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        :param pulumi.Input[str] system_uuid: SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "boot_id", boot_id)
        pulumi.set(__self__, "container_runtime_version", container_runtime_version)
        pulumi.set(__self__, "kernel_version", kernel_version)
        pulumi.set(__self__, "kube_proxy_version", kube_proxy_version)
        pulumi.set(__self__, "kubelet_version", kubelet_version)
        pulumi.set(__self__, "machine_id", machine_id)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "os_image", os_image)
        pulumi.set(__self__, "system_uuid", system_uuid)

    @property
    @pulumi.getter
    def architecture(self) -> pulumi.Input[str]:
        """
        The Architecture reported by the node
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: pulumi.Input[str]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter(name="bootID")
    def boot_id(self) -> pulumi.Input[str]:
        """
        Boot ID reported by the node.
        """
        return pulumi.get(self, "boot_id")

    @boot_id.setter
    def boot_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "boot_id", value)

    @property
    @pulumi.getter(name="containerRuntimeVersion")
    def container_runtime_version(self) -> pulumi.Input[str]:
        """
        ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
        """
        return pulumi.get(self, "container_runtime_version")

    @container_runtime_version.setter
    def container_runtime_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "container_runtime_version", value)

    @property
    @pulumi.getter(name="kernelVersion")
    def kernel_version(self) -> pulumi.Input[str]:
        """
        Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        """
        return pulumi.get(self, "kernel_version")

    @kernel_version.setter
    def kernel_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kernel_version", value)

    @property
    @pulumi.getter(name="kubeProxyVersion")
    def kube_proxy_version(self) -> pulumi.Input[str]:
        """
        KubeProxy Version reported by the node.
        """
        return pulumi.get(self, "kube_proxy_version")

    @kube_proxy_version.setter
    def kube_proxy_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_proxy_version", value)

    @property
    @pulumi.getter(name="kubeletVersion")
    def kubelet_version(self) -> pulumi.Input[str]:
        """
        Kubelet Version reported by the node.
        """
        return pulumi.get(self, "kubelet_version")

    @kubelet_version.setter
    def kubelet_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kubelet_version", value)

    @property
    @pulumi.getter(name="machineID")
    def machine_id(self) -> pulumi.Input[str]:
        """
        MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
        """
        return pulumi.get(self, "machine_id")

    @machine_id.setter
    def machine_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "machine_id", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> pulumi.Input[str]:
        """
        The Operating System reported by the node
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: pulumi.Input[str]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="osImage")
    def os_image(self) -> pulumi.Input[str]:
        """
        OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        """
        return pulumi.get(self, "os_image")

    @os_image.setter
    def os_image(self, value: pulumi.Input[str]):
        pulumi.set(self, "os_image", value)

    @property
    @pulumi.getter(name="systemUUID")
    def system_uuid(self) -> pulumi.Input[str]:
        """
        SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
        """
        return pulumi.get(self, "system_uuid")

    @system_uuid.setter
    def system_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_uuid", value)


@pulumi.input_type
class MachineStatusNodeRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        NodeRef will point to the corresponding Node if it exists.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class MachineStatusArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusAddressesArgs']]]] = None,
                 bootstrap_ready: Optional[pulumi.Input[bool]] = None,
                 certificates_expiry_date: Optional[pulumi.Input[str]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusConditionsArgs']]]] = None,
                 failure_message: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 infrastructure_ready: Optional[pulumi.Input[bool]] = None,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 node_info: Optional[pulumi.Input['MachineStatusNodeInfoArgs']] = None,
                 node_ref: Optional[pulumi.Input['MachineStatusNodeRefArgs']] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        MachineStatus defines the observed state of Machine.
        :param pulumi.Input[Sequence[pulumi.Input['MachineStatusAddressesArgs']]] addresses: Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
        :param pulumi.Input[bool] bootstrap_ready: BootstrapReady is the state of the bootstrap provider.
        :param pulumi.Input[str] certificates_expiry_date: CertificatesExpiryDate is the expiry date of the machine certificates. This value is only set for control plane machines.
        :param pulumi.Input[Sequence[pulumi.Input['MachineStatusConditionsArgs']]] conditions: Conditions defines current service state of the Machine.
        :param pulumi.Input[str] failure_message: FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
                This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        :param pulumi.Input[str] failure_reason: FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
                This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        :param pulumi.Input[bool] infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param pulumi.Input[str] last_updated: LastUpdated identifies when the phase of the Machine last transitioned.
        :param pulumi.Input['MachineStatusNodeInfoArgs'] node_info: NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        :param pulumi.Input['MachineStatusNodeRefArgs'] node_ref: NodeRef will point to the corresponding Node if it exists.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param pulumi.Input[str] phase: Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if bootstrap_ready is not None:
            pulumi.set(__self__, "bootstrap_ready", bootstrap_ready)
        if certificates_expiry_date is not None:
            pulumi.set(__self__, "certificates_expiry_date", certificates_expiry_date)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if node_info is not None:
            pulumi.set(__self__, "node_info", node_info)
        if node_ref is not None:
            pulumi.set(__self__, "node_ref", node_ref)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusAddressesArgs']]]]:
        """
        Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusAddressesArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="bootstrapReady")
    def bootstrap_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        BootstrapReady is the state of the bootstrap provider.
        """
        return pulumi.get(self, "bootstrap_ready")

    @bootstrap_ready.setter
    def bootstrap_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bootstrap_ready", value)

    @property
    @pulumi.getter(name="certificatesExpiryDate")
    def certificates_expiry_date(self) -> Optional[pulumi.Input[str]]:
        """
        CertificatesExpiryDate is the expiry date of the machine certificates. This value is only set for control plane machines.
        """
        return pulumi.get(self, "certificates_expiry_date")

    @certificates_expiry_date.setter
    def certificates_expiry_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificates_expiry_date", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusConditionsArgs']]]]:
        """
        Conditions defines current service state of the Machine.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MachineStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[pulumi.Input[str]]:
        """
        FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
         This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
         This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @infrastructure_ready.setter
    def infrastructure_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infrastructure_ready", value)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        """
        LastUpdated identifies when the phase of the Machine last transitioned.
        """
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter(name="nodeInfo")
    def node_info(self) -> Optional[pulumi.Input['MachineStatusNodeInfoArgs']]:
        """
        NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        """
        return pulumi.get(self, "node_info")

    @node_info.setter
    def node_info(self, value: Optional[pulumi.Input['MachineStatusNodeInfoArgs']]):
        pulumi.set(self, "node_info", value)

    @property
    @pulumi.getter(name="nodeRef")
    def node_ref(self) -> Optional[pulumi.Input['MachineStatusNodeRefArgs']]:
        """
        NodeRef will point to the corresponding Node if it exists.
        """
        return pulumi.get(self, "node_ref")

    @node_ref.setter
    def node_ref(self, value: Optional[pulumi.Input['MachineStatusNodeRefArgs']]):
        pulumi.set(self, "node_ref", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


