# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'ClusterClassSpec',
    'ClusterClassSpecControlPlane',
    'ClusterClassSpecControlPlaneMachineInfrastructure',
    'ClusterClassSpecControlPlaneMachineInfrastructureRef',
    'ClusterClassSpecControlPlaneMetadata',
    'ClusterClassSpecControlPlaneRef',
    'ClusterClassSpecInfrastructure',
    'ClusterClassSpecInfrastructureRef',
    'ClusterClassSpecWorkers',
    'ClusterClassSpecWorkersMachineDeployments',
    'ClusterClassSpecWorkersMachineDeploymentsTemplate',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef',
    'ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata',
    'ClusterSpec',
    'ClusterSpecClusterNetwork',
    'ClusterSpecClusterNetworkPods',
    'ClusterSpecClusterNetworkServices',
    'ClusterSpecControlPlaneEndpoint',
    'ClusterSpecControlPlaneRef',
    'ClusterSpecInfrastructureRef',
    'ClusterSpecTopology',
    'ClusterSpecTopologyControlPlane',
    'ClusterSpecTopologyControlPlaneMetadata',
    'ClusterSpecTopologyWorkers',
    'ClusterSpecTopologyWorkersMachineDeployments',
    'ClusterSpecTopologyWorkersMachineDeploymentsMetadata',
    'ClusterStatus',
    'ClusterStatusConditions',
    'ClusterStatusFailureDomains',
    'MachineDeploymentSpec',
    'MachineDeploymentSpecSelector',
    'MachineDeploymentSpecSelectorMatchExpressions',
    'MachineDeploymentSpecStrategy',
    'MachineDeploymentSpecStrategyRollingUpdate',
    'MachineDeploymentSpecTemplate',
    'MachineDeploymentSpecTemplateMetadata',
    'MachineDeploymentSpecTemplateSpec',
    'MachineDeploymentSpecTemplateSpecBootstrap',
    'MachineDeploymentSpecTemplateSpecBootstrapConfigRef',
    'MachineDeploymentSpecTemplateSpecInfrastructureRef',
    'MachineDeploymentStatus',
    'MachineDeploymentStatusConditions',
    'MachineHealthCheckSpec',
    'MachineHealthCheckSpecRemediationTemplate',
    'MachineHealthCheckSpecSelector',
    'MachineHealthCheckSpecSelectorMatchExpressions',
    'MachineHealthCheckSpecUnhealthyConditions',
    'MachineHealthCheckStatus',
    'MachineHealthCheckStatusConditions',
    'MachinePoolSpec',
    'MachinePoolSpecTemplate',
    'MachinePoolSpecTemplateMetadata',
    'MachinePoolSpecTemplateSpec',
    'MachinePoolSpecTemplateSpecBootstrap',
    'MachinePoolSpecTemplateSpecBootstrapConfigRef',
    'MachinePoolSpecTemplateSpecInfrastructureRef',
    'MachinePoolStatus',
    'MachinePoolStatusConditions',
    'MachinePoolStatusNodeRefs',
    'MachineSetSpec',
    'MachineSetSpecSelector',
    'MachineSetSpecSelectorMatchExpressions',
    'MachineSetSpecTemplate',
    'MachineSetSpecTemplateMetadata',
    'MachineSetSpecTemplateSpec',
    'MachineSetSpecTemplateSpecBootstrap',
    'MachineSetSpecTemplateSpecBootstrapConfigRef',
    'MachineSetSpecTemplateSpecInfrastructureRef',
    'MachineSetStatus',
    'MachineSetStatusConditions',
    'MachineSpec',
    'MachineSpecBootstrap',
    'MachineSpecBootstrapConfigRef',
    'MachineSpecInfrastructureRef',
    'MachineStatus',
    'MachineStatusAddresses',
    'MachineStatusConditions',
    'MachineStatusNodeInfo',
    'MachineStatusNodeRef',
]

@pulumi.output_type
class ClusterClassSpec(dict):
    """
    ClusterClassSpec describes the desired state of the ClusterClass.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane: Optional['outputs.ClusterClassSpecControlPlane'] = None,
                 infrastructure: Optional['outputs.ClusterClassSpecInfrastructure'] = None,
                 workers: Optional['outputs.ClusterClassSpecWorkers'] = None):
        """
        ClusterClassSpec describes the desired state of the ClusterClass.
        :param 'ClusterClassSpecControlPlaneArgs' control_plane: ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        :param 'ClusterClassSpecInfrastructureArgs' infrastructure: Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        :param 'ClusterClassSpecWorkersArgs' workers: Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional['outputs.ClusterClassSpecControlPlane']:
        """
        ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional['outputs.ClusterClassSpecInfrastructure']:
        """
        Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        """
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter
    def workers(self) -> Optional['outputs.ClusterClassSpecWorkers']:
        """
        Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class ClusterClassSpecControlPlane(dict):
    """
    ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineInfrastructure":
            suggest = "machine_infrastructure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ref: 'outputs.ClusterClassSpecControlPlaneRef',
                 machine_infrastructure: Optional['outputs.ClusterClassSpecControlPlaneMachineInfrastructure'] = None,
                 metadata: Optional['outputs.ClusterClassSpecControlPlaneMetadata'] = None):
        """
        ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
        :param 'ClusterClassSpecControlPlaneRefArgs' ref: Ref is a required reference to a custom resource offered by a provider.
        :param 'ClusterClassSpecControlPlaneMachineInfrastructureArgs' machine_infrastructure: MachineTemplate defines the metadata and infrastructure information for control plane machines. 
                This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        :param 'ClusterClassSpecControlPlaneMetadataArgs' metadata: Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
                This field is supported if and only if the control plane provider template referenced is Machine based.
        """
        pulumi.set(__self__, "ref", ref)
        if machine_infrastructure is not None:
            pulumi.set(__self__, "machine_infrastructure", machine_infrastructure)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def ref(self) -> 'outputs.ClusterClassSpecControlPlaneRef':
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter(name="machineInfrastructure")
    def machine_infrastructure(self) -> Optional['outputs.ClusterClassSpecControlPlaneMachineInfrastructure']:
        """
        MachineTemplate defines the metadata and infrastructure information for control plane machines. 
         This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        """
        return pulumi.get(self, "machine_infrastructure")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterClassSpecControlPlaneMetadata']:
        """
        Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         This field is supported if and only if the control plane provider template referenced is Machine based.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class ClusterClassSpecControlPlaneMachineInfrastructure(dict):
    """
    MachineTemplate defines the metadata and infrastructure information for control plane machines. 
     This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
    """
    def __init__(__self__, *,
                 ref: 'outputs.ClusterClassSpecControlPlaneMachineInfrastructureRef'):
        """
        MachineTemplate defines the metadata and infrastructure information for control plane machines. 
         This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
        :param 'ClusterClassSpecControlPlaneMachineInfrastructureRefArgs' ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> 'outputs.ClusterClassSpecControlPlaneMachineInfrastructureRef':
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class ClusterClassSpecControlPlaneMachineInfrastructureRef(dict):
    """
    Ref is a required reference to a custom resource offered by a provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecControlPlaneMachineInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecControlPlaneMachineInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecControlPlaneMachineInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterClassSpecControlPlaneMetadata(dict):
    """
    Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
     This field is supported if and only if the control plane provider template referenced is Machine based.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         This field is supported if and only if the control plane provider template referenced is Machine based.
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ClusterClassSpecControlPlaneRef(dict):
    """
    Ref is a required reference to a custom resource offered by a provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecControlPlaneRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecControlPlaneRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecControlPlaneRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterClassSpecInfrastructure(dict):
    """
    Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
    """
    def __init__(__self__, *,
                 ref: 'outputs.ClusterClassSpecInfrastructureRef'):
        """
        Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
        :param 'ClusterClassSpecInfrastructureRefArgs' ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> 'outputs.ClusterClassSpecInfrastructureRef':
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class ClusterClassSpecInfrastructureRef(dict):
    """
    Ref is a required reference to a custom resource offered by a provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterClassSpecWorkers(dict):
    """
    Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineDeployments":
            suggest = "machine_deployments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecWorkers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecWorkers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecWorkers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_deployments: Optional[Sequence['outputs.ClusterClassSpecWorkersMachineDeployments']] = None):
        """
        Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
        :param Sequence['ClusterClassSpecWorkersMachineDeploymentsArgs'] machine_deployments: MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
        """
        if machine_deployments is not None:
            pulumi.set(__self__, "machine_deployments", machine_deployments)

    @property
    @pulumi.getter(name="machineDeployments")
    def machine_deployments(self) -> Optional[Sequence['outputs.ClusterClassSpecWorkersMachineDeployments']]:
        """
        MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
        """
        return pulumi.get(self, "machine_deployments")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeployments(dict):
    """
    MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster provisioned using the `ClusterClass`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecWorkersMachineDeployments. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecWorkersMachineDeployments.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecWorkersMachineDeployments.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: str,
                 template: 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplate'):
        """
        MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster provisioned using the `ClusterClass`.
        :param str class_: Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateArgs' template: Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplate':
        """
        Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplate(dict):
    """
    Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
    """
    def __init__(__self__, *,
                 bootstrap: 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap',
                 infrastructure: 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure',
                 metadata: Optional['outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata'] = None):
        """
        Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapArgs' bootstrap: Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureArgs' infrastructure: Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateMetadataArgs' metadata: Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "infrastructure", infrastructure)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def bootstrap(self) -> 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap':
        """
        Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter
    def infrastructure(self) -> 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure':
        """
        Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        """
        return pulumi.get(self, "infrastructure")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata']:
        """
        Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap(dict):
    """
    Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
    """
    def __init__(__self__, *,
                 ref: 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef'):
        """
        Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRefArgs' ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef':
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef(dict):
    """
    Ref is a required reference to a custom resource offered by a provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure(dict):
    """
    Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
    """
    def __init__(__self__, *,
                 ref: 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef'):
        """
        Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
        :param 'ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRefArgs' ref: Ref is a required reference to a custom resource offered by a provider.
        """
        pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def ref(self) -> 'outputs.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef':
        """
        Ref is a required reference to a custom resource offered by a provider.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef(dict):
    """
    Ref is a required reference to a custom resource offered by a provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref is a required reference to a custom resource offered by a provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata(dict):
    """
    Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ClusterSpec(dict):
    """
    ClusterSpec defines the desired state of Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterNetwork":
            suggest = "cluster_network"
        elif key == "controlPlaneEndpoint":
            suggest = "control_plane_endpoint"
        elif key == "controlPlaneRef":
            suggest = "control_plane_ref"
        elif key == "infrastructureRef":
            suggest = "infrastructure_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_network: Optional['outputs.ClusterSpecClusterNetwork'] = None,
                 control_plane_endpoint: Optional['outputs.ClusterSpecControlPlaneEndpoint'] = None,
                 control_plane_ref: Optional['outputs.ClusterSpecControlPlaneRef'] = None,
                 infrastructure_ref: Optional['outputs.ClusterSpecInfrastructureRef'] = None,
                 paused: Optional[bool] = None,
                 topology: Optional['outputs.ClusterSpecTopology'] = None):
        """
        ClusterSpec defines the desired state of Cluster.
        :param 'ClusterSpecClusterNetworkArgs' cluster_network: Cluster network configuration.
        :param 'ClusterSpecControlPlaneEndpointArgs' control_plane_endpoint: ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        :param 'ClusterSpecControlPlaneRefArgs' control_plane_ref: ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        :param 'ClusterSpecInfrastructureRefArgs' infrastructure_ref: InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        :param bool paused: Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
        :param 'ClusterSpecTopologyArgs' topology: This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        """
        if cluster_network is not None:
            pulumi.set(__self__, "cluster_network", cluster_network)
        if control_plane_endpoint is not None:
            pulumi.set(__self__, "control_plane_endpoint", control_plane_endpoint)
        if control_plane_ref is not None:
            pulumi.set(__self__, "control_plane_ref", control_plane_ref)
        if infrastructure_ref is not None:
            pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if topology is not None:
            pulumi.set(__self__, "topology", topology)

    @property
    @pulumi.getter(name="clusterNetwork")
    def cluster_network(self) -> Optional['outputs.ClusterSpecClusterNetwork']:
        """
        Cluster network configuration.
        """
        return pulumi.get(self, "cluster_network")

    @property
    @pulumi.getter(name="controlPlaneEndpoint")
    def control_plane_endpoint(self) -> Optional['outputs.ClusterSpecControlPlaneEndpoint']:
        """
        ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        """
        return pulumi.get(self, "control_plane_endpoint")

    @property
    @pulumi.getter(name="controlPlaneRef")
    def control_plane_ref(self) -> Optional['outputs.ClusterSpecControlPlaneRef']:
        """
        ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        """
        return pulumi.get(self, "control_plane_ref")

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> Optional['outputs.ClusterSpecInfrastructureRef']:
        """
        InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter
    def topology(self) -> Optional['outputs.ClusterSpecTopology']:
        """
        This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        """
        return pulumi.get(self, "topology")


@pulumi.output_type
class ClusterSpecClusterNetwork(dict):
    """
    Cluster network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerPort":
            suggest = "api_server_port"
        elif key == "serviceDomain":
            suggest = "service_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecClusterNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecClusterNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecClusterNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_port: Optional[int] = None,
                 pods: Optional['outputs.ClusterSpecClusterNetworkPods'] = None,
                 service_domain: Optional[str] = None,
                 services: Optional['outputs.ClusterSpecClusterNetworkServices'] = None):
        """
        Cluster network configuration.
        :param int api_server_port: APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
        :param 'ClusterSpecClusterNetworkPodsArgs' pods: The network ranges from which Pod networks are allocated.
        :param str service_domain: Domain name for services.
        :param 'ClusterSpecClusterNetworkServicesArgs' services: The network ranges from which service VIPs are allocated.
        """
        if api_server_port is not None:
            pulumi.set(__self__, "api_server_port", api_server_port)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if service_domain is not None:
            pulumi.set(__self__, "service_domain", service_domain)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter(name="apiServerPort")
    def api_server_port(self) -> Optional[int]:
        """
        APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
        """
        return pulumi.get(self, "api_server_port")

    @property
    @pulumi.getter
    def pods(self) -> Optional['outputs.ClusterSpecClusterNetworkPods']:
        """
        The network ranges from which Pod networks are allocated.
        """
        return pulumi.get(self, "pods")

    @property
    @pulumi.getter(name="serviceDomain")
    def service_domain(self) -> Optional[str]:
        """
        Domain name for services.
        """
        return pulumi.get(self, "service_domain")

    @property
    @pulumi.getter
    def services(self) -> Optional['outputs.ClusterSpecClusterNetworkServices']:
        """
        The network ranges from which service VIPs are allocated.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class ClusterSpecClusterNetworkPods(dict):
    """
    The network ranges from which Pod networks are allocated.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlocks":
            suggest = "cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecClusterNetworkPods. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecClusterNetworkPods.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecClusterNetworkPods.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_blocks: Sequence[str]):
        """
        The network ranges from which Pod networks are allocated.
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Sequence[str]:
        return pulumi.get(self, "cidr_blocks")


@pulumi.output_type
class ClusterSpecClusterNetworkServices(dict):
    """
    The network ranges from which service VIPs are allocated.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlocks":
            suggest = "cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecClusterNetworkServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecClusterNetworkServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecClusterNetworkServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_blocks: Sequence[str]):
        """
        The network ranges from which service VIPs are allocated.
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Sequence[str]:
        return pulumi.get(self, "cidr_blocks")


@pulumi.output_type
class ClusterSpecControlPlaneEndpoint(dict):
    """
    ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
    """
    def __init__(__self__, *,
                 host: str,
                 port: int):
        """
        ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        :param str host: The hostname on which the API server is serving.
        :param int port: The port on which the API server is serving.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname on which the API server is serving.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port on which the API server is serving.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ClusterSpecControlPlaneRef(dict):
    """
    ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecControlPlaneRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecControlPlaneRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecControlPlaneRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterSpecInfrastructureRef(dict):
    """
    InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterSpecTopology(dict):
    """
    This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"
        elif key == "controlPlane":
            suggest = "control_plane"
        elif key == "rolloutAfter":
            suggest = "rollout_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecTopology. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecTopology.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecTopology.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: str,
                 version: str,
                 control_plane: Optional['outputs.ClusterSpecTopologyControlPlane'] = None,
                 rollout_after: Optional[str] = None,
                 workers: Optional['outputs.ClusterSpecTopologyWorkers'] = None):
        """
        This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
        :param str class_: The name of the ClusterClass object to create the topology.
        :param str version: The Kubernetes version of the cluster.
        :param 'ClusterSpecTopologyControlPlaneArgs' control_plane: ControlPlane describes the cluster control plane.
        :param str rollout_after: RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments.
        :param 'ClusterSpecTopologyWorkersArgs' workers: Workers encapsulates the different constructs that form the worker nodes for the cluster.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "version", version)
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if rollout_after is not None:
            pulumi.set(__self__, "rollout_after", rollout_after)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        The name of the ClusterClass object to create the topology.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The Kubernetes version of the cluster.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional['outputs.ClusterSpecTopologyControlPlane']:
        """
        ControlPlane describes the cluster control plane.
        """
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter(name="rolloutAfter")
    def rollout_after(self) -> Optional[str]:
        """
        RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments.
        """
        return pulumi.get(self, "rollout_after")

    @property
    @pulumi.getter
    def workers(self) -> Optional['outputs.ClusterSpecTopologyWorkers']:
        """
        Workers encapsulates the different constructs that form the worker nodes for the cluster.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class ClusterSpecTopologyControlPlane(dict):
    """
    ControlPlane describes the cluster control plane.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.ClusterSpecTopologyControlPlaneMetadata'] = None,
                 replicas: Optional[int] = None):
        """
        ControlPlane describes the cluster control plane.
        :param 'ClusterSpecTopologyControlPlaneMetadataArgs' metadata: Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
                This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
        :param int replicas: Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterSpecTopologyControlPlaneMetadata']:
        """
        Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
         This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class ClusterSpecTopologyControlPlaneMetadata(dict):
    """
    Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
     This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
         This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ClusterSpecTopologyWorkers(dict):
    """
    Workers encapsulates the different constructs that form the worker nodes for the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineDeployments":
            suggest = "machine_deployments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecTopologyWorkers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecTopologyWorkers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecTopologyWorkers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_deployments: Optional[Sequence['outputs.ClusterSpecTopologyWorkersMachineDeployments']] = None):
        """
        Workers encapsulates the different constructs that form the worker nodes for the cluster.
        :param Sequence['ClusterSpecTopologyWorkersMachineDeploymentsArgs'] machine_deployments: MachineDeployments is a list of machine deployments in the cluster.
        """
        if machine_deployments is not None:
            pulumi.set(__self__, "machine_deployments", machine_deployments)

    @property
    @pulumi.getter(name="machineDeployments")
    def machine_deployments(self) -> Optional[Sequence['outputs.ClusterSpecTopologyWorkersMachineDeployments']]:
        """
        MachineDeployments is a list of machine deployments in the cluster.
        """
        return pulumi.get(self, "machine_deployments")


@pulumi.output_type
class ClusterSpecTopologyWorkersMachineDeployments(dict):
    """
    MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology. This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpecTopologyWorkersMachineDeployments. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpecTopologyWorkersMachineDeployments.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpecTopologyWorkersMachineDeployments.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: str,
                 name: str,
                 metadata: Optional['outputs.ClusterSpecTopologyWorkersMachineDeploymentsMetadata'] = None,
                 replicas: Optional[int] = None):
        """
        MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology. This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
        :param str class_: Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
        :param str name: Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
        :param 'ClusterSpecTopologyWorkersMachineDeploymentsMetadataArgs' metadata: Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param int replicas: Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to zero) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
        """
        pulumi.set(__self__, "class_", class_)
        pulumi.set(__self__, "name", name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> str:
        """
        Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterSpecTopologyWorkersMachineDeploymentsMetadata']:
        """
        Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to zero) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class ClusterSpecTopologyWorkersMachineDeploymentsMetadata(dict):
    """
    Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ClusterStatus(dict):
    """
    ClusterStatus defines the observed state of Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneReady":
            suggest = "control_plane_ready"
        elif key == "failureDomains":
            suggest = "failure_domains"
        elif key == "failureMessage":
            suggest = "failure_message"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "infrastructureReady":
            suggest = "infrastructure_ready"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ClusterStatusConditions']] = None,
                 control_plane_ready: Optional[bool] = None,
                 failure_domains: Optional[Mapping[str, 'outputs.ClusterStatusFailureDomains']] = None,
                 failure_message: Optional[str] = None,
                 failure_reason: Optional[str] = None,
                 infrastructure_ready: Optional[bool] = None,
                 observed_generation: Optional[int] = None,
                 phase: Optional[str] = None):
        """
        ClusterStatus defines the observed state of Cluster.
        :param Sequence['ClusterStatusConditionsArgs'] conditions: Conditions defines current service state of the cluster.
        :param bool control_plane_ready: ControlPlaneReady defines if the control plane is ready.
        :param Mapping[str, 'ClusterStatusFailureDomainsArgs'] failure_domains: FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
        :param str failure_message: FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
        :param str failure_reason: FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        :param bool infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param int observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param str phase: Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if control_plane_ready is not None:
            pulumi.set(__self__, "control_plane_ready", control_plane_ready)
        if failure_domains is not None:
            pulumi.set(__self__, "failure_domains", failure_domains)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ClusterStatusConditions']]:
        """
        Conditions defines current service state of the cluster.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="controlPlaneReady")
    def control_plane_ready(self) -> Optional[bool]:
        """
        ControlPlaneReady defines if the control plane is ready.
        """
        return pulumi.get(self, "control_plane_ready")

    @property
    @pulumi.getter(name="failureDomains")
    def failure_domains(self) -> Optional[Mapping[str, 'outputs.ClusterStatusFailureDomains']]:
        """
        FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
        """
        return pulumi.get(self, "failure_domains")

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[str]:
        """
        FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
        """
        return pulumi.get(self, "failure_message")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[str]:
        """
        FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[bool]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")


@pulumi.output_type
class ClusterStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class ClusterStatusFailureDomains(dict):
    """
    FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterStatusFailureDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterStatusFailureDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterStatusFailureDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, str]] = None,
                 control_plane: Optional[bool] = None):
        """
        FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
        :param Mapping[str, str] attributes: Attributes is a free form map of attributes an infrastructure provider might use or require.
        :param bool control_plane: ControlPlane determines if this failure domain is suitable for use by control plane machines.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Attributes is a free form map of attributes an infrastructure provider might use or require.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[bool]:
        """
        ControlPlane determines if this failure domain is suitable for use by control plane machines.
        """
        return pulumi.get(self, "control_plane")


@pulumi.output_type
class MachineDeploymentSpec(dict):
    """
    MachineDeploymentSpec defines the desired state of MachineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"
        elif key == "progressDeadlineSeconds":
            suggest = "progress_deadline_seconds"
        elif key == "revisionHistoryLimit":
            suggest = "revision_history_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 selector: 'outputs.MachineDeploymentSpecSelector',
                 template: 'outputs.MachineDeploymentSpecTemplate',
                 min_ready_seconds: Optional[int] = None,
                 paused: Optional[bool] = None,
                 progress_deadline_seconds: Optional[int] = None,
                 replicas: Optional[int] = None,
                 revision_history_limit: Optional[int] = None,
                 strategy: Optional['outputs.MachineDeploymentSpecStrategy'] = None):
        """
        MachineDeploymentSpec defines the desired state of MachineDeployment.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineDeploymentSpecSelectorArgs' selector: Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        :param 'MachineDeploymentSpecTemplateArgs' template: Template describes the machines that will be created.
        :param int min_ready_seconds: Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        :param bool paused: Indicates that the deployment is paused.
        :param int progress_deadline_seconds: The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
        :param int replicas: Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        :param int revision_history_limit: The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        :param 'MachineDeploymentSpecStrategyArgs' strategy: The deployment strategy to use to replace existing machines with new ones.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "template", template)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if progress_deadline_seconds is not None:
            pulumi.set(__self__, "progress_deadline_seconds", progress_deadline_seconds)
        if replicas is None:
            replicas = 1
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if revision_history_limit is not None:
            pulumi.set(__self__, "revision_history_limit", revision_history_limit)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def selector(self) -> 'outputs.MachineDeploymentSpecSelector':
        """
        Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.MachineDeploymentSpecTemplate':
        """
        Template describes the machines that will be created.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        """
        Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        Indicates that the deployment is paused.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="progressDeadlineSeconds")
    def progress_deadline_seconds(self) -> Optional[int]:
        """
        The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
        """
        return pulumi.get(self, "progress_deadline_seconds")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="revisionHistoryLimit")
    def revision_history_limit(self) -> Optional[int]:
        """
        The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        """
        return pulumi.get(self, "revision_history_limit")

    @property
    @pulumi.getter
    def strategy(self) -> Optional['outputs.MachineDeploymentSpecStrategy']:
        """
        The deployment strategy to use to replace existing machines with new ones.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class MachineDeploymentSpecSelector(dict):
    """
    Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.MachineDeploymentSpecSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
        :param Sequence['MachineDeploymentSpecSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.MachineDeploymentSpecSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class MachineDeploymentSpecSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MachineDeploymentSpecStrategy(dict):
    """
    The deployment strategy to use to replace existing machines with new ones.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.MachineDeploymentSpecStrategyRollingUpdate'] = None,
                 type: Optional[str] = None):
        """
        The deployment strategy to use to replace existing machines with new ones.
        :param 'MachineDeploymentSpecStrategyRollingUpdateArgs' rolling_update: Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param str type: Type of deployment. Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.MachineDeploymentSpecStrategyRollingUpdate']:
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        """
        return pulumi.get(self, "rolling_update")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of deployment. Default is RollingUpdate.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MachineDeploymentSpecStrategyRollingUpdate(dict):
    """
    Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletePolicy":
            suggest = "delete_policy"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_policy: Optional[str] = None,
                 max_surge: Optional[Any] = None,
                 max_unavailable: Optional[Any] = None):
        """
        Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
        :param str delete_policy: DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        :param Union[int, str] max_surge: The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        :param Union[int, str] max_unavailable: The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[str]:
        """
        DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
        """
        return pulumi.get(self, "delete_policy")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[Any]:
        """
        The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[Any]:
        """
        The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class MachineDeploymentSpecTemplate(dict):
    """
    Template describes the machines that will be created.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.MachineDeploymentSpecTemplateMetadata'] = None,
                 spec: Optional['outputs.MachineDeploymentSpecTemplateSpec'] = None):
        """
        Template describes the machines that will be created.
        :param 'MachineDeploymentSpecTemplateMetadataArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'MachineDeploymentSpecTemplateSpecArgs' spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MachineDeploymentSpecTemplateMetadata']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.MachineDeploymentSpecTemplateSpec']:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class MachineDeploymentSpecTemplateMetadata(dict):
    """
    Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class MachineDeploymentSpecTemplateSpec(dict):
    """
    Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "infrastructureRef":
            suggest = "infrastructure_ref"
        elif key == "failureDomain":
            suggest = "failure_domain"
        elif key == "nodeDrainTimeout":
            suggest = "node_drain_timeout"
        elif key == "providerID":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap: 'outputs.MachineDeploymentSpecTemplateSpecBootstrap',
                 cluster_name: str,
                 infrastructure_ref: 'outputs.MachineDeploymentSpecTemplateSpecInfrastructureRef',
                 failure_domain: Optional[str] = None,
                 node_drain_timeout: Optional[str] = None,
                 provider_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param 'MachineDeploymentSpecTemplateSpecBootstrapArgs' bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineDeploymentSpecTemplateSpecInfrastructureRefArgs' infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param str node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param str provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param str version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> 'outputs.MachineDeploymentSpecTemplateSpecBootstrap':
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> 'outputs.MachineDeploymentSpecTemplateSpecInfrastructureRef':
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[str]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[str]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[str]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MachineDeploymentSpecTemplateSpecBootstrap(dict):
    """
    Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configRef":
            suggest = "config_ref"
        elif key == "dataSecretName":
            suggest = "data_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecTemplateSpecBootstrap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecTemplateSpecBootstrap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecTemplateSpecBootstrap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_ref: Optional['outputs.MachineDeploymentSpecTemplateSpecBootstrapConfigRef'] = None,
                 data_secret_name: Optional[str] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param 'MachineDeploymentSpecTemplateSpecBootstrapConfigRefArgs' config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional['outputs.MachineDeploymentSpecTemplateSpecBootstrapConfigRef']:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[str]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")


@pulumi.output_type
class MachineDeploymentSpecTemplateSpecBootstrapConfigRef(dict):
    """
    ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecTemplateSpecBootstrapConfigRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineDeploymentSpecTemplateSpecInfrastructureRef(dict):
    """
    InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentSpecTemplateSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineDeploymentStatus(dict):
    """
    MachineDeploymentStatus defines the observed state of MachineDeployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableReplicas":
            suggest = "available_replicas"
        elif key == "observedGeneration":
            suggest = "observed_generation"
        elif key == "readyReplicas":
            suggest = "ready_replicas"
        elif key == "unavailableReplicas":
            suggest = "unavailable_replicas"
        elif key == "updatedReplicas":
            suggest = "updated_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_replicas: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.MachineDeploymentStatusConditions']] = None,
                 observed_generation: Optional[int] = None,
                 phase: Optional[str] = None,
                 ready_replicas: Optional[int] = None,
                 replicas: Optional[int] = None,
                 selector: Optional[str] = None,
                 unavailable_replicas: Optional[int] = None,
                 updated_replicas: Optional[int] = None):
        """
        MachineDeploymentStatus defines the observed state of MachineDeployment.
        :param int available_replicas: Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
        :param Sequence['MachineDeploymentStatusConditionsArgs'] conditions: Conditions defines current service state of the MachineDeployment.
        :param int observed_generation: The generation observed by the deployment controller.
        :param str phase: Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
        :param int ready_replicas: Total number of ready machines targeted by this deployment.
        :param int replicas: Total number of non-terminated machines targeted by this deployment (their labels match the selector).
        :param str selector: Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        :param int unavailable_replicas: Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
        :param int updated_replicas: Total number of non-terminated machines targeted by this deployment that have the desired template spec.
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if unavailable_replicas is not None:
            pulumi.set(__self__, "unavailable_replicas", unavailable_replicas)
        if updated_replicas is not None:
            pulumi.set(__self__, "updated_replicas", updated_replicas)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[int]:
        """
        Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
        """
        return pulumi.get(self, "available_replicas")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MachineDeploymentStatusConditions']]:
        """
        Conditions defines current service state of the MachineDeployment.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation observed by the deployment controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[int]:
        """
        Total number of ready machines targeted by this deployment.
        """
        return pulumi.get(self, "ready_replicas")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Total number of non-terminated machines targeted by this deployment (their labels match the selector).
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="unavailableReplicas")
    def unavailable_replicas(self) -> Optional[int]:
        """
        Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
        """
        return pulumi.get(self, "unavailable_replicas")

    @property
    @pulumi.getter(name="updatedReplicas")
    def updated_replicas(self) -> Optional[int]:
        """
        Total number of non-terminated machines targeted by this deployment that have the desired template spec.
        """
        return pulumi.get(self, "updated_replicas")


@pulumi.output_type
class MachineDeploymentStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineDeploymentStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineDeploymentStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineDeploymentStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class MachineHealthCheckSpec(dict):
    """
    Specification of machine health check policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "unhealthyConditions":
            suggest = "unhealthy_conditions"
        elif key == "maxUnhealthy":
            suggest = "max_unhealthy"
        elif key == "nodeStartupTimeout":
            suggest = "node_startup_timeout"
        elif key == "remediationTemplate":
            suggest = "remediation_template"
        elif key == "unhealthyRange":
            suggest = "unhealthy_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineHealthCheckSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineHealthCheckSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineHealthCheckSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 selector: 'outputs.MachineHealthCheckSpecSelector',
                 unhealthy_conditions: Sequence['outputs.MachineHealthCheckSpecUnhealthyConditions'],
                 max_unhealthy: Optional[Any] = None,
                 node_startup_timeout: Optional[str] = None,
                 remediation_template: Optional['outputs.MachineHealthCheckSpecRemediationTemplate'] = None,
                 unhealthy_range: Optional[str] = None):
        """
        Specification of machine health check policy
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineHealthCheckSpecSelectorArgs' selector: Label selector to match machines whose health will be exercised
        :param Sequence['MachineHealthCheckSpecUnhealthyConditionsArgs'] unhealthy_conditions: UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        :param Union[int, str] max_unhealthy: Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        :param str node_startup_timeout: Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
        :param 'MachineHealthCheckSpecRemediationTemplateArgs' remediation_template: RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
                This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param str unhealthy_range: Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "unhealthy_conditions", unhealthy_conditions)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_startup_timeout is not None:
            pulumi.set(__self__, "node_startup_timeout", node_startup_timeout)
        if remediation_template is not None:
            pulumi.set(__self__, "remediation_template", remediation_template)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def selector(self) -> 'outputs.MachineHealthCheckSpecSelector':
        """
        Label selector to match machines whose health will be exercised
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="unhealthyConditions")
    def unhealthy_conditions(self) -> Sequence['outputs.MachineHealthCheckSpecUnhealthyConditions']:
        """
        UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
        """
        return pulumi.get(self, "unhealthy_conditions")

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[Any]:
        """
        Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
        """
        return pulumi.get(self, "max_unhealthy")

    @property
    @pulumi.getter(name="nodeStartupTimeout")
    def node_startup_timeout(self) -> Optional[str]:
        """
        Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
        """
        return pulumi.get(self, "node_startup_timeout")

    @property
    @pulumi.getter(name="remediationTemplate")
    def remediation_template(self) -> Optional['outputs.MachineHealthCheckSpecRemediationTemplate']:
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        """
        return pulumi.get(self, "remediation_template")

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[str]:
        """
        Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
        """
        return pulumi.get(self, "unhealthy_range")


@pulumi.output_type
class MachineHealthCheckSpecRemediationTemplate(dict):
    """
    RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
     This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineHealthCheckSpecRemediationTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineHealthCheckSpecRemediationTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineHealthCheckSpecRemediationTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineHealthCheckSpecSelector(dict):
    """
    Label selector to match machines whose health will be exercised
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineHealthCheckSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineHealthCheckSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineHealthCheckSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.MachineHealthCheckSpecSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Label selector to match machines whose health will be exercised
        :param Sequence['MachineHealthCheckSpecSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.MachineHealthCheckSpecSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class MachineHealthCheckSpecSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MachineHealthCheckSpecUnhealthyConditions(dict):
    """
    UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
    """
    def __init__(__self__, *,
                 status: str,
                 timeout: str,
                 type: str):
        """
        UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class MachineHealthCheckStatus(dict):
    """
    Most recently observed status of MachineHealthCheck resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentHealthy":
            suggest = "current_healthy"
        elif key == "expectedMachines":
            suggest = "expected_machines"
        elif key == "observedGeneration":
            suggest = "observed_generation"
        elif key == "remediationsAllowed":
            suggest = "remediations_allowed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineHealthCheckStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineHealthCheckStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineHealthCheckStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.MachineHealthCheckStatusConditions']] = None,
                 current_healthy: Optional[int] = None,
                 expected_machines: Optional[int] = None,
                 observed_generation: Optional[int] = None,
                 remediations_allowed: Optional[int] = None,
                 targets: Optional[Sequence[str]] = None):
        """
        Most recently observed status of MachineHealthCheck resource
        :param Sequence['MachineHealthCheckStatusConditionsArgs'] conditions: Conditions defines current service state of the MachineHealthCheck.
        :param int current_healthy: total number of healthy machines counted by this machine health check
        :param int expected_machines: total number of machines counted by this machine health check
        :param int observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param int remediations_allowed: RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
        :param Sequence[str] targets: Targets shows the current list of machines the machine health check is watching
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if current_healthy is not None:
            pulumi.set(__self__, "current_healthy", current_healthy)
        if expected_machines is not None:
            pulumi.set(__self__, "expected_machines", expected_machines)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if remediations_allowed is not None:
            pulumi.set(__self__, "remediations_allowed", remediations_allowed)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MachineHealthCheckStatusConditions']]:
        """
        Conditions defines current service state of the MachineHealthCheck.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="currentHealthy")
    def current_healthy(self) -> Optional[int]:
        """
        total number of healthy machines counted by this machine health check
        """
        return pulumi.get(self, "current_healthy")

    @property
    @pulumi.getter(name="expectedMachines")
    def expected_machines(self) -> Optional[int]:
        """
        total number of machines counted by this machine health check
        """
        return pulumi.get(self, "expected_machines")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="remediationsAllowed")
    def remediations_allowed(self) -> Optional[int]:
        """
        RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
        """
        return pulumi.get(self, "remediations_allowed")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[str]]:
        """
        Targets shows the current list of machines the machine health check is watching
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class MachineHealthCheckStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineHealthCheckStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineHealthCheckStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineHealthCheckStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class MachinePoolSpec(dict):
    """
    MachinePoolSpec defines the desired state of MachinePool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "failureDomains":
            suggest = "failure_domains"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"
        elif key == "providerIDList":
            suggest = "provider_id_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 template: 'outputs.MachinePoolSpecTemplate',
                 failure_domains: Optional[Sequence[str]] = None,
                 min_ready_seconds: Optional[int] = None,
                 provider_id_list: Optional[Sequence[str]] = None,
                 replicas: Optional[int] = None):
        """
        MachinePoolSpec defines the desired state of MachinePool.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachinePoolSpecTemplateArgs' template: Template describes the machines that will be created.
        :param Sequence[str] failure_domains: FailureDomains is the list of failure domains this MachinePool should be attached to.
        :param int min_ready_seconds: Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready)
        :param Sequence[str] provider_id_list: ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        :param int replicas: Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "template", template)
        if failure_domains is not None:
            pulumi.set(__self__, "failure_domains", failure_domains)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if provider_id_list is not None:
            pulumi.set(__self__, "provider_id_list", provider_id_list)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.MachinePoolSpecTemplate':
        """
        Template describes the machines that will be created.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="failureDomains")
    def failure_domains(self) -> Optional[Sequence[str]]:
        """
        FailureDomains is the list of failure domains this MachinePool should be attached to.
        """
        return pulumi.get(self, "failure_domains")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        """
        Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter(name="providerIDList")
    def provider_id_list(self) -> Optional[Sequence[str]]:
        """
        ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
        """
        return pulumi.get(self, "provider_id_list")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class MachinePoolSpecTemplate(dict):
    """
    Template describes the machines that will be created.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.MachinePoolSpecTemplateMetadata'] = None,
                 spec: Optional['outputs.MachinePoolSpecTemplateSpec'] = None):
        """
        Template describes the machines that will be created.
        :param 'MachinePoolSpecTemplateMetadataArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'MachinePoolSpecTemplateSpecArgs' spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MachinePoolSpecTemplateMetadata']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.MachinePoolSpecTemplateSpec']:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class MachinePoolSpecTemplateMetadata(dict):
    """
    Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class MachinePoolSpecTemplateSpec(dict):
    """
    Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "infrastructureRef":
            suggest = "infrastructure_ref"
        elif key == "failureDomain":
            suggest = "failure_domain"
        elif key == "nodeDrainTimeout":
            suggest = "node_drain_timeout"
        elif key == "providerID":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolSpecTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolSpecTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolSpecTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap: 'outputs.MachinePoolSpecTemplateSpecBootstrap',
                 cluster_name: str,
                 infrastructure_ref: 'outputs.MachinePoolSpecTemplateSpecInfrastructureRef',
                 failure_domain: Optional[str] = None,
                 node_drain_timeout: Optional[str] = None,
                 provider_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param 'MachinePoolSpecTemplateSpecBootstrapArgs' bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachinePoolSpecTemplateSpecInfrastructureRefArgs' infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param str node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param str provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param str version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> 'outputs.MachinePoolSpecTemplateSpecBootstrap':
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> 'outputs.MachinePoolSpecTemplateSpecInfrastructureRef':
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[str]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[str]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[str]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MachinePoolSpecTemplateSpecBootstrap(dict):
    """
    Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configRef":
            suggest = "config_ref"
        elif key == "dataSecretName":
            suggest = "data_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolSpecTemplateSpecBootstrap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolSpecTemplateSpecBootstrap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolSpecTemplateSpecBootstrap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_ref: Optional['outputs.MachinePoolSpecTemplateSpecBootstrapConfigRef'] = None,
                 data_secret_name: Optional[str] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param 'MachinePoolSpecTemplateSpecBootstrapConfigRefArgs' config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional['outputs.MachinePoolSpecTemplateSpecBootstrapConfigRef']:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[str]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")


@pulumi.output_type
class MachinePoolSpecTemplateSpecBootstrapConfigRef(dict):
    """
    ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolSpecTemplateSpecBootstrapConfigRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachinePoolSpecTemplateSpecInfrastructureRef(dict):
    """
    InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolSpecTemplateSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachinePoolStatus(dict):
    """
    MachinePoolStatus defines the observed state of MachinePool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableReplicas":
            suggest = "available_replicas"
        elif key == "bootstrapReady":
            suggest = "bootstrap_ready"
        elif key == "failureMessage":
            suggest = "failure_message"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "infrastructureReady":
            suggest = "infrastructure_ready"
        elif key == "nodeRefs":
            suggest = "node_refs"
        elif key == "observedGeneration":
            suggest = "observed_generation"
        elif key == "readyReplicas":
            suggest = "ready_replicas"
        elif key == "unavailableReplicas":
            suggest = "unavailable_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_replicas: Optional[int] = None,
                 bootstrap_ready: Optional[bool] = None,
                 conditions: Optional[Sequence['outputs.MachinePoolStatusConditions']] = None,
                 failure_message: Optional[str] = None,
                 failure_reason: Optional[str] = None,
                 infrastructure_ready: Optional[bool] = None,
                 node_refs: Optional[Sequence['outputs.MachinePoolStatusNodeRefs']] = None,
                 observed_generation: Optional[int] = None,
                 phase: Optional[str] = None,
                 ready_replicas: Optional[int] = None,
                 replicas: Optional[int] = None,
                 unavailable_replicas: Optional[int] = None):
        """
        MachinePoolStatus defines the observed state of MachinePool.
        :param int available_replicas: The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
        :param bool bootstrap_ready: BootstrapReady is the state of the bootstrap provider.
        :param Sequence['MachinePoolStatusConditionsArgs'] conditions: Conditions define the current service state of the MachinePool.
        :param str failure_message: FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
        :param str failure_reason: FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        :param bool infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param Sequence['MachinePoolStatusNodeRefsArgs'] node_refs: NodeRefs will point to the corresponding Nodes if it they exist.
        :param int observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param str phase: Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        :param int ready_replicas: The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
        :param int replicas: Replicas is the most recently observed number of replicas.
        :param int unavailable_replicas: Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if bootstrap_ready is not None:
            pulumi.set(__self__, "bootstrap_ready", bootstrap_ready)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if node_refs is not None:
            pulumi.set(__self__, "node_refs", node_refs)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if unavailable_replicas is not None:
            pulumi.set(__self__, "unavailable_replicas", unavailable_replicas)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[int]:
        """
        The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
        """
        return pulumi.get(self, "available_replicas")

    @property
    @pulumi.getter(name="bootstrapReady")
    def bootstrap_ready(self) -> Optional[bool]:
        """
        BootstrapReady is the state of the bootstrap provider.
        """
        return pulumi.get(self, "bootstrap_ready")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MachinePoolStatusConditions']]:
        """
        Conditions define the current service state of the MachinePool.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[str]:
        """
        FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
        """
        return pulumi.get(self, "failure_message")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[str]:
        """
        FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[bool]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @property
    @pulumi.getter(name="nodeRefs")
    def node_refs(self) -> Optional[Sequence['outputs.MachinePoolStatusNodeRefs']]:
        """
        NodeRefs will point to the corresponding Nodes if it they exist.
        """
        return pulumi.get(self, "node_refs")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[int]:
        """
        The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
        """
        return pulumi.get(self, "ready_replicas")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Replicas is the most recently observed number of replicas.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="unavailableReplicas")
    def unavailable_replicas(self) -> Optional[int]:
        """
        Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
        """
        return pulumi.get(self, "unavailable_replicas")


@pulumi.output_type
class MachinePoolStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class MachinePoolStatusNodeRefs(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
     Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachinePoolStatusNodeRefs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachinePoolStatusNodeRefs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachinePoolStatusNodeRefs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineSetSpec(dict):
    """
    MachineSetSpec defines the desired state of MachineSet.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "deletePolicy":
            suggest = "delete_policy"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: str,
                 selector: 'outputs.MachineSetSpecSelector',
                 delete_policy: Optional[str] = None,
                 min_ready_seconds: Optional[int] = None,
                 replicas: Optional[int] = None,
                 template: Optional['outputs.MachineSetSpecTemplate'] = None):
        """
        MachineSetSpec defines the desired state of MachineSet.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineSetSpecSelectorArgs' selector: Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        :param str delete_policy: DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
        :param int min_ready_seconds: MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        :param int replicas: Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
        :param 'MachineSetSpecTemplateArgs' template: Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "selector", selector)
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if replicas is None:
            replicas = 1
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def selector(self) -> 'outputs.MachineSetSpecSelector':
        """
        Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[str]:
        """
        DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
        """
        return pulumi.get(self, "delete_policy")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        """
        MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
        """
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.MachineSetSpecTemplate']:
        """
        Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class MachineSetSpecSelector(dict):
    """
    Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.MachineSetSpecSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
        :param Sequence['MachineSetSpecSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.MachineSetSpecSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class MachineSetSpecSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MachineSetSpecTemplate(dict):
    """
    Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.MachineSetSpecTemplateMetadata'] = None,
                 spec: Optional['outputs.MachineSetSpecTemplateSpec'] = None):
        """
        Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
        :param 'MachineSetSpecTemplateMetadataArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'MachineSetSpecTemplateSpecArgs' spec: Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.MachineSetSpecTemplateMetadata']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.MachineSetSpecTemplateSpec']:
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class MachineSetSpecTemplateMetadata(dict):
    """
    Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param Mapping[str, str] annotations: Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class MachineSetSpecTemplateSpec(dict):
    """
    Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "infrastructureRef":
            suggest = "infrastructure_ref"
        elif key == "failureDomain":
            suggest = "failure_domain"
        elif key == "nodeDrainTimeout":
            suggest = "node_drain_timeout"
        elif key == "providerID":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpecTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpecTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpecTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap: 'outputs.MachineSetSpecTemplateSpecBootstrap',
                 cluster_name: str,
                 infrastructure_ref: 'outputs.MachineSetSpecTemplateSpecInfrastructureRef',
                 failure_domain: Optional[str] = None,
                 node_drain_timeout: Optional[str] = None,
                 provider_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
        :param 'MachineSetSpecTemplateSpecBootstrapArgs' bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineSetSpecTemplateSpecInfrastructureRefArgs' infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param str node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param str provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param str version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> 'outputs.MachineSetSpecTemplateSpecBootstrap':
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> 'outputs.MachineSetSpecTemplateSpecInfrastructureRef':
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[str]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[str]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[str]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MachineSetSpecTemplateSpecBootstrap(dict):
    """
    Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configRef":
            suggest = "config_ref"
        elif key == "dataSecretName":
            suggest = "data_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpecTemplateSpecBootstrap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpecTemplateSpecBootstrap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpecTemplateSpecBootstrap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_ref: Optional['outputs.MachineSetSpecTemplateSpecBootstrapConfigRef'] = None,
                 data_secret_name: Optional[str] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param 'MachineSetSpecTemplateSpecBootstrapConfigRefArgs' config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional['outputs.MachineSetSpecTemplateSpecBootstrapConfigRef']:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[str]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")


@pulumi.output_type
class MachineSetSpecTemplateSpecBootstrapConfigRef(dict):
    """
    ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpecTemplateSpecBootstrapConfigRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpecTemplateSpecBootstrapConfigRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineSetSpecTemplateSpecInfrastructureRef(dict):
    """
    InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetSpecTemplateSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetSpecTemplateSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineSetStatus(dict):
    """
    MachineSetStatus defines the observed state of MachineSet.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableReplicas":
            suggest = "available_replicas"
        elif key == "failureMessage":
            suggest = "failure_message"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "fullyLabeledReplicas":
            suggest = "fully_labeled_replicas"
        elif key == "observedGeneration":
            suggest = "observed_generation"
        elif key == "readyReplicas":
            suggest = "ready_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_replicas: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.MachineSetStatusConditions']] = None,
                 failure_message: Optional[str] = None,
                 failure_reason: Optional[str] = None,
                 fully_labeled_replicas: Optional[int] = None,
                 observed_generation: Optional[int] = None,
                 ready_replicas: Optional[int] = None,
                 replicas: Optional[int] = None,
                 selector: Optional[str] = None):
        """
        MachineSetStatus defines the observed state of MachineSet.
        :param int available_replicas: The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
        :param Sequence['MachineSetStatusConditionsArgs'] conditions: Conditions defines current service state of the MachineSet.
        :param str failure_reason: In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
                These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
        :param int fully_labeled_replicas: The number of replicas that have labels matching the labels of the machine template of the MachineSet.
        :param int observed_generation: ObservedGeneration reflects the generation of the most recently observed MachineSet.
        :param int ready_replicas: The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
        :param int replicas: Replicas is the most recently observed number of replicas.
        :param str selector: Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        if available_replicas is not None:
            pulumi.set(__self__, "available_replicas", available_replicas)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if fully_labeled_replicas is not None:
            pulumi.set(__self__, "fully_labeled_replicas", fully_labeled_replicas)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if ready_replicas is not None:
            pulumi.set(__self__, "ready_replicas", ready_replicas)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="availableReplicas")
    def available_replicas(self) -> Optional[int]:
        """
        The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
        """
        return pulumi.get(self, "available_replicas")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MachineSetStatusConditions']]:
        """
        Conditions defines current service state of the MachineSet.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[str]:
        return pulumi.get(self, "failure_message")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[str]:
        """
        In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
         These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="fullyLabeledReplicas")
    def fully_labeled_replicas(self) -> Optional[int]:
        """
        The number of replicas that have labels matching the labels of the machine template of the MachineSet.
        """
        return pulumi.get(self, "fully_labeled_replicas")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration reflects the generation of the most recently observed MachineSet.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="readyReplicas")
    def ready_replicas(self) -> Optional[int]:
        """
        The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
        """
        return pulumi.get(self, "ready_replicas")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Replicas is the most recently observed number of replicas.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class MachineSetStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSetStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSetStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSetStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class MachineSpec(dict):
    """
    MachineSpec defines the desired state of Machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "infrastructureRef":
            suggest = "infrastructure_ref"
        elif key == "failureDomain":
            suggest = "failure_domain"
        elif key == "nodeDrainTimeout":
            suggest = "node_drain_timeout"
        elif key == "providerID":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap: 'outputs.MachineSpecBootstrap',
                 cluster_name: str,
                 infrastructure_ref: 'outputs.MachineSpecInfrastructureRef',
                 failure_domain: Optional[str] = None,
                 node_drain_timeout: Optional[str] = None,
                 provider_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        MachineSpec defines the desired state of Machine.
        :param 'MachineSpecBootstrapArgs' bootstrap: Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param str cluster_name: ClusterName is the name of the Cluster this object belongs to.
        :param 'MachineSpecInfrastructureRefArgs' infrastructure_ref: InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str failure_domain: FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        :param str node_drain_timeout: NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        :param str provider_id: ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        :param str version: Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        pulumi.set(__self__, "bootstrap", bootstrap)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "infrastructure_ref", infrastructure_ref)
        if failure_domain is not None:
            pulumi.set(__self__, "failure_domain", failure_domain)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bootstrap(self) -> 'outputs.MachineSpecBootstrap':
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName is the name of the Cluster this object belongs to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="infrastructureRef")
    def infrastructure_ref(self) -> 'outputs.MachineSpecInfrastructureRef':
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ref")

    @property
    @pulumi.getter(name="failureDomain")
    def failure_domain(self) -> Optional[str]:
        """
        FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
        """
        return pulumi.get(self, "failure_domain")

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[str]:
        """
        NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
        """
        return pulumi.get(self, "node_drain_timeout")

    @property
    @pulumi.getter(name="providerID")
    def provider_id(self) -> Optional[str]:
        """
        ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MachineSpecBootstrap(dict):
    """
    Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configRef":
            suggest = "config_ref"
        elif key == "dataSecretName":
            suggest = "data_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSpecBootstrap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSpecBootstrap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSpecBootstrap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_ref: Optional['outputs.MachineSpecBootstrapConfigRef'] = None,
                 data_secret_name: Optional[str] = None):
        """
        Bootstrap is a reference to a local struct which encapsulates fields to configure the Machines bootstrapping mechanism.
        :param 'MachineSpecBootstrapConfigRefArgs' config_ref: ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str data_secret_name: DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if data_secret_name is not None:
            pulumi.set(__self__, "data_secret_name", data_secret_name)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional['outputs.MachineSpecBootstrapConfigRef']:
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        """
        return pulumi.get(self, "config_ref")

    @property
    @pulumi.getter(name="dataSecretName")
    def data_secret_name(self) -> Optional[str]:
        """
        DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
        """
        return pulumi.get(self, "data_secret_name")


@pulumi.output_type
class MachineSpecBootstrapConfigRef(dict):
    """
    ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSpecBootstrapConfigRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSpecBootstrapConfigRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSpecBootstrapConfigRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineSpecInfrastructureRef(dict):
    """
    InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineSpecInfrastructureRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineSpecInfrastructureRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineSpecInfrastructureRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class MachineStatus(dict):
    """
    MachineStatus defines the observed state of Machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapReady":
            suggest = "bootstrap_ready"
        elif key == "failureMessage":
            suggest = "failure_message"
        elif key == "failureReason":
            suggest = "failure_reason"
        elif key == "infrastructureReady":
            suggest = "infrastructure_ready"
        elif key == "lastUpdated":
            suggest = "last_updated"
        elif key == "nodeInfo":
            suggest = "node_info"
        elif key == "nodeRef":
            suggest = "node_ref"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.MachineStatusAddresses']] = None,
                 bootstrap_ready: Optional[bool] = None,
                 conditions: Optional[Sequence['outputs.MachineStatusConditions']] = None,
                 failure_message: Optional[str] = None,
                 failure_reason: Optional[str] = None,
                 infrastructure_ready: Optional[bool] = None,
                 last_updated: Optional[str] = None,
                 node_info: Optional['outputs.MachineStatusNodeInfo'] = None,
                 node_ref: Optional['outputs.MachineStatusNodeRef'] = None,
                 observed_generation: Optional[int] = None,
                 phase: Optional[str] = None,
                 version: Optional[str] = None):
        """
        MachineStatus defines the observed state of Machine.
        :param Sequence['MachineStatusAddressesArgs'] addresses: Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
        :param bool bootstrap_ready: BootstrapReady is the state of the bootstrap provider.
        :param Sequence['MachineStatusConditionsArgs'] conditions: Conditions defines current service state of the Machine.
        :param str failure_message: FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
                This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        :param str failure_reason: FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
                This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
                Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        :param bool infrastructure_ready: InfrastructureReady is the state of the infrastructure provider.
        :param str last_updated: LastUpdated identifies when the phase of the Machine last transitioned.
        :param 'MachineStatusNodeInfoArgs' node_info: NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        :param 'MachineStatusNodeRefArgs' node_ref: NodeRef will point to the corresponding Node if it exists.
        :param int observed_generation: ObservedGeneration is the latest generation observed by the controller.
        :param str phase: Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
        :param str version: Version specifies the current version of Kubernetes running on the corresponding Node. This is meant to be a means of bubbling up status from the Node to the Machine. It is entirely optional, but useful for end-user UX if its present.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if bootstrap_ready is not None:
            pulumi.set(__self__, "bootstrap_ready", bootstrap_ready)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if failure_message is not None:
            pulumi.set(__self__, "failure_message", failure_message)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if infrastructure_ready is not None:
            pulumi.set(__self__, "infrastructure_ready", infrastructure_ready)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if node_info is not None:
            pulumi.set(__self__, "node_info", node_info)
        if node_ref is not None:
            pulumi.set(__self__, "node_ref", node_ref)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.MachineStatusAddresses']]:
        """
        Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="bootstrapReady")
    def bootstrap_ready(self) -> Optional[bool]:
        """
        BootstrapReady is the state of the bootstrap provider.
        """
        return pulumi.get(self, "bootstrap_ready")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.MachineStatusConditions']]:
        """
        Conditions defines current service state of the Machine.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> Optional[str]:
        """
        FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
         This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_message")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[str]:
        """
        FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
         This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
         Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter(name="infrastructureReady")
    def infrastructure_ready(self) -> Optional[bool]:
        """
        InfrastructureReady is the state of the infrastructure provider.
        """
        return pulumi.get(self, "infrastructure_ready")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        """
        LastUpdated identifies when the phase of the Machine last transitioned.
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="nodeInfo")
    def node_info(self) -> Optional['outputs.MachineStatusNodeInfo']:
        """
        NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        """
        return pulumi.get(self, "node_info")

    @property
    @pulumi.getter(name="nodeRef")
    def node_ref(self) -> Optional['outputs.MachineStatusNodeRef']:
        """
        NodeRef will point to the corresponding Node if it exists.
        """
        return pulumi.get(self, "node_ref")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the latest generation observed by the controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version specifies the current version of Kubernetes running on the corresponding Node. This is meant to be a means of bubbling up status from the Node to the Machine. It is entirely optional, but useful for end-user UX if its present.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MachineStatusAddresses(dict):
    """
    MachineAddress contains information for the node's address.
    """
    def __init__(__self__, *,
                 address: str,
                 type: str):
        """
        MachineAddress contains information for the node's address.
        :param str address: The machine address.
        :param str type: Machine address type, one of Hostname, ExternalIP or InternalIP.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The machine address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Machine address type, one of Hostname, ExternalIP or InternalIP.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MachineStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class MachineStatusNodeInfo(dict):
    """
    NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootID":
            suggest = "boot_id"
        elif key == "containerRuntimeVersion":
            suggest = "container_runtime_version"
        elif key == "kernelVersion":
            suggest = "kernel_version"
        elif key == "kubeProxyVersion":
            suggest = "kube_proxy_version"
        elif key == "kubeletVersion":
            suggest = "kubelet_version"
        elif key == "machineID":
            suggest = "machine_id"
        elif key == "operatingSystem":
            suggest = "operating_system"
        elif key == "osImage":
            suggest = "os_image"
        elif key == "systemUUID":
            suggest = "system_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineStatusNodeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineStatusNodeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineStatusNodeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: str,
                 boot_id: str,
                 container_runtime_version: str,
                 kernel_version: str,
                 kube_proxy_version: str,
                 kubelet_version: str,
                 machine_id: str,
                 operating_system: str,
                 os_image: str,
                 system_uuid: str):
        """
        NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
        :param str architecture: The Architecture reported by the node
        :param str boot_id: Boot ID reported by the node.
        :param str container_runtime_version: ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
        :param str kernel_version: Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        :param str kube_proxy_version: KubeProxy Version reported by the node.
        :param str kubelet_version: Kubelet Version reported by the node.
        :param str machine_id: MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
        :param str operating_system: The Operating System reported by the node
        :param str os_image: OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        :param str system_uuid: SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
        """
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "boot_id", boot_id)
        pulumi.set(__self__, "container_runtime_version", container_runtime_version)
        pulumi.set(__self__, "kernel_version", kernel_version)
        pulumi.set(__self__, "kube_proxy_version", kube_proxy_version)
        pulumi.set(__self__, "kubelet_version", kubelet_version)
        pulumi.set(__self__, "machine_id", machine_id)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "os_image", os_image)
        pulumi.set(__self__, "system_uuid", system_uuid)

    @property
    @pulumi.getter
    def architecture(self) -> str:
        """
        The Architecture reported by the node
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter(name="bootID")
    def boot_id(self) -> str:
        """
        Boot ID reported by the node.
        """
        return pulumi.get(self, "boot_id")

    @property
    @pulumi.getter(name="containerRuntimeVersion")
    def container_runtime_version(self) -> str:
        """
        ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
        """
        return pulumi.get(self, "container_runtime_version")

    @property
    @pulumi.getter(name="kernelVersion")
    def kernel_version(self) -> str:
        """
        Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
        """
        return pulumi.get(self, "kernel_version")

    @property
    @pulumi.getter(name="kubeProxyVersion")
    def kube_proxy_version(self) -> str:
        """
        KubeProxy Version reported by the node.
        """
        return pulumi.get(self, "kube_proxy_version")

    @property
    @pulumi.getter(name="kubeletVersion")
    def kubelet_version(self) -> str:
        """
        Kubelet Version reported by the node.
        """
        return pulumi.get(self, "kubelet_version")

    @property
    @pulumi.getter(name="machineID")
    def machine_id(self) -> str:
        """
        MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
        """
        return pulumi.get(self, "machine_id")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        The Operating System reported by the node
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter(name="osImage")
    def os_image(self) -> str:
        """
        OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
        """
        return pulumi.get(self, "os_image")

    @property
    @pulumi.getter(name="systemUUID")
    def system_uuid(self) -> str:
        """
        SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
        """
        return pulumi.get(self, "system_uuid")


@pulumi.output_type
class MachineStatusNodeRef(dict):
    """
    NodeRef will point to the corresponding Node if it exists.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineStatusNodeRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineStatusNodeRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineStatusNodeRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        NodeRef will point to the corresponding Node if it exists.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


