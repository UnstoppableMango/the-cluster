# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'EnvironmentSpec',
    'EnvironmentSpecInitrd',
    'EnvironmentSpecKernel',
    'EnvironmentStatus',
    'EnvironmentStatusConditions',
    'ServerClassSpec',
    'ServerClassSpecConfigPatches',
    'ServerClassSpecEnvironmentRef',
    'ServerClassSpecQualifiers',
    'ServerClassSpecQualifiersHardware',
    'ServerClassSpecQualifiersHardwareCompute',
    'ServerClassSpecQualifiersHardwareComputeProcessors',
    'ServerClassSpecQualifiersHardwareMemory',
    'ServerClassSpecQualifiersHardwareMemoryModules',
    'ServerClassSpecQualifiersHardwareNetwork',
    'ServerClassSpecQualifiersHardwareNetworkInterfaces',
    'ServerClassSpecQualifiersHardwareStorage',
    'ServerClassSpecQualifiersHardwareStorageDevices',
    'ServerClassSpecQualifiersHardwareSystem',
    'ServerClassSpecSelector',
    'ServerClassSpecSelectorMatchExpressions',
    'ServerClassStatus',
    'ServerSpec',
    'ServerSpecBmc',
    'ServerSpecBmcPassFrom',
    'ServerSpecBmcPassFromSecretKeyRef',
    'ServerSpecBmcUserFrom',
    'ServerSpecBmcUserFromSecretKeyRef',
    'ServerSpecConfigPatches',
    'ServerSpecEnvironmentRef',
    'ServerSpecHardware',
    'ServerSpecHardwareCompute',
    'ServerSpecHardwareComputeProcessors',
    'ServerSpecHardwareMemory',
    'ServerSpecHardwareMemoryModules',
    'ServerSpecHardwareNetwork',
    'ServerSpecHardwareNetworkInterfaces',
    'ServerSpecHardwareStorage',
    'ServerSpecHardwareStorageDevices',
    'ServerSpecHardwareSystem',
    'ServerSpecManagementApi',
    'ServerStatus',
    'ServerStatusAddresses',
    'ServerStatusConditions',
]

@pulumi.output_type
class EnvironmentSpec(dict):
    """
    EnvironmentSpec defines the desired state of Environment.
    """
    def __init__(__self__, *,
                 initrd: Optional['outputs.EnvironmentSpecInitrd'] = None,
                 kernel: Optional['outputs.EnvironmentSpecKernel'] = None):
        """
        EnvironmentSpec defines the desired state of Environment.
        """
        if initrd is not None:
            pulumi.set(__self__, "initrd", initrd)
        if kernel is not None:
            pulumi.set(__self__, "kernel", kernel)

    @property
    @pulumi.getter
    def initrd(self) -> Optional['outputs.EnvironmentSpecInitrd']:
        return pulumi.get(self, "initrd")

    @property
    @pulumi.getter
    def kernel(self) -> Optional['outputs.EnvironmentSpecKernel']:
        return pulumi.get(self, "kernel")


@pulumi.output_type
class EnvironmentSpecInitrd(dict):
    def __init__(__self__, *,
                 sha512: Optional[str] = None,
                 url: Optional[str] = None):
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def sha512(self) -> Optional[str]:
        return pulumi.get(self, "sha512")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class EnvironmentSpecKernel(dict):
    def __init__(__self__, *,
                 args: Optional[Sequence[str]] = None,
                 sha512: Optional[str] = None,
                 url: Optional[str] = None):
        if args is not None:
            pulumi.set(__self__, "args", args)
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def sha512(self) -> Optional[str]:
        return pulumi.get(self, "sha512")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class EnvironmentStatus(dict):
    """
    EnvironmentStatus defines the observed state of Environment.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.EnvironmentStatusConditions']] = None):
        """
        EnvironmentStatus defines the observed state of Environment.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EnvironmentStatusConditions']]:
        return pulumi.get(self, "conditions")


@pulumi.output_type
class EnvironmentStatusConditions(dict):
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 sha512: Optional[str] = None,
                 url: Optional[str] = None):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if sha512 is not None:
            pulumi.set(__self__, "sha512", sha512)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def sha512(self) -> Optional[str]:
        return pulumi.get(self, "sha512")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ServerClassSpec(dict):
    """
    ServerClassSpec defines the desired state of ServerClass.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootFromDiskMethod":
            suggest = "boot_from_disk_method"
        elif key == "configPatches":
            suggest = "config_patches"
        elif key == "environmentRef":
            suggest = "environment_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_from_disk_method: Optional[str] = None,
                 config_patches: Optional[Sequence['outputs.ServerClassSpecConfigPatches']] = None,
                 environment_ref: Optional['outputs.ServerClassSpecEnvironmentRef'] = None,
                 qualifiers: Optional['outputs.ServerClassSpecQualifiers'] = None,
                 selector: Optional['outputs.ServerClassSpecSelector'] = None):
        """
        ServerClassSpec defines the desired state of ServerClass.
        :param str boot_from_disk_method: BootFromDiskMethod specifies the method to exit iPXE to force boot from disk. 
                If not set, controller default is used. Valid values: ipxe-exit, http-404, ipxe-sanboot.
        :param Sequence['ServerClassSpecConfigPatchesArgs'] config_patches: Set of config patches to apply to the machine configuration to the servers provisioned via this server class.
        :param 'ServerClassSpecEnvironmentRefArgs' environment_ref: Reference to the environment which should be used to provision the servers via this server class.
        :param 'ServerClassSpecQualifiersArgs' qualifiers: Qualifiers to match on the server spec. 
                If qualifiers are empty, they match all servers. Server should match both qualifiers and selector conditions to be included into the server class.
        :param 'ServerClassSpecSelectorArgs' selector: Label selector to filter the matching servers based on labels. A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        if boot_from_disk_method is not None:
            pulumi.set(__self__, "boot_from_disk_method", boot_from_disk_method)
        if config_patches is not None:
            pulumi.set(__self__, "config_patches", config_patches)
        if environment_ref is not None:
            pulumi.set(__self__, "environment_ref", environment_ref)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="bootFromDiskMethod")
    def boot_from_disk_method(self) -> Optional[str]:
        """
        BootFromDiskMethod specifies the method to exit iPXE to force boot from disk. 
         If not set, controller default is used. Valid values: ipxe-exit, http-404, ipxe-sanboot.
        """
        return pulumi.get(self, "boot_from_disk_method")

    @property
    @pulumi.getter(name="configPatches")
    def config_patches(self) -> Optional[Sequence['outputs.ServerClassSpecConfigPatches']]:
        """
        Set of config patches to apply to the machine configuration to the servers provisioned via this server class.
        """
        return pulumi.get(self, "config_patches")

    @property
    @pulumi.getter(name="environmentRef")
    def environment_ref(self) -> Optional['outputs.ServerClassSpecEnvironmentRef']:
        """
        Reference to the environment which should be used to provision the servers via this server class.
        """
        return pulumi.get(self, "environment_ref")

    @property
    @pulumi.getter
    def qualifiers(self) -> Optional['outputs.ServerClassSpecQualifiers']:
        """
        Qualifiers to match on the server spec. 
         If qualifiers are empty, they match all servers. Server should match both qualifiers and selector conditions to be included into the server class.
        """
        return pulumi.get(self, "qualifiers")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.ServerClassSpecSelector']:
        """
        Label selector to filter the matching servers based on labels. A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class ServerClassSpecConfigPatches(dict):
    def __init__(__self__, *,
                 op: str,
                 path: str,
                 value: Optional[Mapping[str, Any]] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerClassSpecEnvironmentRef(dict):
    """
    Reference to the environment which should be used to provision the servers via this server class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecEnvironmentRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecEnvironmentRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecEnvironmentRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Reference to the environment which should be used to provision the servers via this server class.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ServerClassSpecQualifiers(dict):
    """
    Qualifiers to match on the server spec. 
     If qualifiers are empty, they match all servers. Server should match both qualifiers and selector conditions to be included into the server class.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hardware: Optional[Sequence['outputs.ServerClassSpecQualifiersHardware']] = None,
                 label_selectors: Optional[Sequence[Mapping[str, str]]] = None):
        """
        Qualifiers to match on the server spec. 
         If qualifiers are empty, they match all servers. Server should match both qualifiers and selector conditions to be included into the server class.
        """
        if hardware is not None:
            pulumi.set(__self__, "hardware", hardware)
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)

    @property
    @pulumi.getter
    def hardware(self) -> Optional[Sequence['outputs.ServerClassSpecQualifiersHardware']]:
        return pulumi.get(self, "hardware")

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence[Mapping[str, str]]]:
        return pulumi.get(self, "label_selectors")


@pulumi.output_type
class ServerClassSpecQualifiersHardware(dict):
    def __init__(__self__, *,
                 compute: Optional['outputs.ServerClassSpecQualifiersHardwareCompute'] = None,
                 memory: Optional['outputs.ServerClassSpecQualifiersHardwareMemory'] = None,
                 network: Optional['outputs.ServerClassSpecQualifiersHardwareNetwork'] = None,
                 storage: Optional['outputs.ServerClassSpecQualifiersHardwareStorage'] = None,
                 system: Optional['outputs.ServerClassSpecQualifiersHardwareSystem'] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.ServerClassSpecQualifiersHardwareCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def memory(self) -> Optional['outputs.ServerClassSpecQualifiersHardwareMemory']:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.ServerClassSpecQualifiersHardwareNetwork']:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.ServerClassSpecQualifiersHardwareStorage']:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def system(self) -> Optional['outputs.ServerClassSpecQualifiersHardwareSystem']:
        return pulumi.get(self, "system")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processorCount":
            suggest = "processor_count"
        elif key == "totalCoreCount":
            suggest = "total_core_count"
        elif key == "totalThreadCount":
            suggest = "total_thread_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processor_count: Optional[int] = None,
                 processors: Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareComputeProcessors']] = None,
                 total_core_count: Optional[int] = None,
                 total_thread_count: Optional[int] = None):
        if processor_count is not None:
            pulumi.set(__self__, "processor_count", processor_count)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if total_core_count is not None:
            pulumi.set(__self__, "total_core_count", total_core_count)
        if total_thread_count is not None:
            pulumi.set(__self__, "total_thread_count", total_thread_count)

    @property
    @pulumi.getter(name="processorCount")
    def processor_count(self) -> Optional[int]:
        return pulumi.get(self, "processor_count")

    @property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareComputeProcessors']]:
        return pulumi.get(self, "processors")

    @property
    @pulumi.getter(name="totalCoreCount")
    def total_core_count(self) -> Optional[int]:
        return pulumi.get(self, "total_core_count")

    @property
    @pulumi.getter(name="totalThreadCount")
    def total_thread_count(self) -> Optional[int]:
        return pulumi.get(self, "total_thread_count")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareComputeProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreCount":
            suggest = "core_count"
        elif key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "threadCount":
            suggest = "thread_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareComputeProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareComputeProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareComputeProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_count: Optional[int] = None,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 speed: Optional[int] = None,
                 thread_count: Optional[int] = None):
        """
        :param int speed: Speed is in megahertz (Mhz)
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if thread_count is not None:
            pulumi.set(__self__, "thread_count", thread_count)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def speed(self) -> Optional[int]:
        """
        Speed is in megahertz (Mhz)
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter(name="threadCount")
    def thread_count(self) -> Optional[int]:
        return pulumi.get(self, "thread_count")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "moduleCount":
            suggest = "module_count"
        elif key == "totalSize":
            suggest = "total_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 module_count: Optional[int] = None,
                 modules: Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareMemoryModules']] = None,
                 total_size: Optional[str] = None):
        if module_count is not None:
            pulumi.set(__self__, "module_count", module_count)
        if modules is not None:
            pulumi.set(__self__, "modules", modules)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @property
    @pulumi.getter(name="moduleCount")
    def module_count(self) -> Optional[int]:
        return pulumi.get(self, "module_count")

    @property
    @pulumi.getter
    def modules(self) -> Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareMemoryModules']]:
        return pulumi.get(self, "modules")

    @property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[str]:
        return pulumi.get(self, "total_size")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareMemoryModules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareMemoryModules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareMemoryModules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareMemoryModules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 size: Optional[int] = None,
                 speed: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int size: Size is in megabytes (MB)
        :param int speed: Speed is in megatransfers per second (MT/S)
        """
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size is in megabytes (MB)
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def speed(self) -> Optional[int]:
        """
        Speed is in megatransfers per second (MT/S)
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceCount":
            suggest = "interface_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_count: Optional[int] = None,
                 interfaces: Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareNetworkInterfaces']] = None):
        if interface_count is not None:
            pulumi.set(__self__, "interface_count", interface_count)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)

    @property
    @pulumi.getter(name="interfaceCount")
    def interface_count(self) -> Optional[int]:
        return pulumi.get(self, "interface_count")

    @property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareNetworkInterfaces']]:
        return pulumi.get(self, "interfaces")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareNetworkInterfaces(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 flags: Optional[str] = None,
                 index: Optional[int] = None,
                 mac: Optional[str] = None,
                 mtu: Optional[int] = None,
                 name: Optional[str] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def flags(self) -> Optional[str]:
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceCount":
            suggest = "device_count"
        elif key == "totalSize":
            suggest = "total_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_count: Optional[int] = None,
                 devices: Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareStorageDevices']] = None,
                 total_size: Optional[str] = None):
        if device_count is not None:
            pulumi.set(__self__, "device_count", device_count)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @property
    @pulumi.getter(name="deviceCount")
    def device_count(self) -> Optional[int]:
        return pulumi.get(self, "device_count")

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.ServerClassSpecQualifiersHardwareStorageDevices']]:
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[str]:
        return pulumi.get(self, "total_size")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareStorageDevices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareStorageDevices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareStorageDevices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareStorageDevices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 name: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 size: Optional[int] = None,
                 type: Optional[str] = None,
                 uuid: Optional[str] = None,
                 wwid: Optional[str] = None):
        """
        :param int size: Size is in bytes
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if wwid is not None:
            pulumi.set(__self__, "wwid", wwid)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size is in bytes
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def wwid(self) -> Optional[str]:
        return pulumi.get(self, "wwid")


@pulumi.output_type
class ServerClassSpecQualifiersHardwareSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "skuNumber":
            suggest = "sku_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecQualifiersHardwareSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecQualifiersHardwareSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecQualifiersHardwareSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 family: Optional[str] = None,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 sku_number: Optional[str] = None,
                 uuid: Optional[str] = None,
                 version: Optional[str] = None):
        if family is not None:
            pulumi.set(__self__, "family", family)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if sku_number is not None:
            pulumi.set(__self__, "sku_number", sku_number)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="skuNumber")
    def sku_number(self) -> Optional[str]:
        return pulumi.get(self, "sku_number")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ServerClassSpecSelector(dict):
    """
    Label selector to filter the matching servers based on labels. A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ServerClassSpecSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Label selector to filter the matching servers based on labels. A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['ServerClassSpecSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ServerClassSpecSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ServerClassSpecSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServerClassStatus(dict):
    """
    ServerClassStatus defines the observed state of ServerClass.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serversAvailable":
            suggest = "servers_available"
        elif key == "serversInUse":
            suggest = "servers_in_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerClassStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerClassStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerClassStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 servers_available: Sequence[str],
                 servers_in_use: Sequence[str]):
        """
        ServerClassStatus defines the observed state of ServerClass.
        """
        pulumi.set(__self__, "servers_available", servers_available)
        pulumi.set(__self__, "servers_in_use", servers_in_use)

    @property
    @pulumi.getter(name="serversAvailable")
    def servers_available(self) -> Sequence[str]:
        return pulumi.get(self, "servers_available")

    @property
    @pulumi.getter(name="serversInUse")
    def servers_in_use(self) -> Sequence[str]:
        return pulumi.get(self, "servers_in_use")


@pulumi.output_type
class ServerSpec(dict):
    """
    ServerSpec defines the desired state of Server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootFromDiskMethod":
            suggest = "boot_from_disk_method"
        elif key == "configPatches":
            suggest = "config_patches"
        elif key == "environmentRef":
            suggest = "environment_ref"
        elif key == "managementApi":
            suggest = "management_api"
        elif key == "pxeBootAlways":
            suggest = "pxe_boot_always"
        elif key == "pxeMode":
            suggest = "pxe_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accepted: bool,
                 bmc: Optional['outputs.ServerSpecBmc'] = None,
                 boot_from_disk_method: Optional[str] = None,
                 config_patches: Optional[Sequence['outputs.ServerSpecConfigPatches']] = None,
                 cordoned: Optional[bool] = None,
                 environment_ref: Optional['outputs.ServerSpecEnvironmentRef'] = None,
                 hardware: Optional['outputs.ServerSpecHardware'] = None,
                 hostname: Optional[str] = None,
                 management_api: Optional['outputs.ServerSpecManagementApi'] = None,
                 pxe_boot_always: Optional[bool] = None,
                 pxe_mode: Optional[str] = None):
        """
        ServerSpec defines the desired state of Server.
        :param 'ServerSpecBmcArgs' bmc: BMC defines data about how to talk to the node via ipmitool.
        :param str boot_from_disk_method: BootFromDiskMethod specifies the method to exit iPXE to force boot from disk. 
                If not set, controller default is used. Valid values: ipxe-exit, http-404, ipxe-sanboot.
        :param 'ServerSpecEnvironmentRefArgs' environment_ref: ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
                Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param 'ServerSpecManagementApiArgs' management_api: ManagementAPI defines data about how to talk to the node via simple HTTP API.
        :param str pxe_mode: PXEMode specifies the method to trigger PXE boot via IPMI. 
                If not set, controller default is used. Valid values: uefi, bios.
        """
        pulumi.set(__self__, "accepted", accepted)
        if bmc is not None:
            pulumi.set(__self__, "bmc", bmc)
        if boot_from_disk_method is not None:
            pulumi.set(__self__, "boot_from_disk_method", boot_from_disk_method)
        if config_patches is not None:
            pulumi.set(__self__, "config_patches", config_patches)
        if cordoned is not None:
            pulumi.set(__self__, "cordoned", cordoned)
        if environment_ref is not None:
            pulumi.set(__self__, "environment_ref", environment_ref)
        if hardware is not None:
            pulumi.set(__self__, "hardware", hardware)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if management_api is not None:
            pulumi.set(__self__, "management_api", management_api)
        if pxe_boot_always is not None:
            pulumi.set(__self__, "pxe_boot_always", pxe_boot_always)
        if pxe_mode is not None:
            pulumi.set(__self__, "pxe_mode", pxe_mode)

    @property
    @pulumi.getter
    def accepted(self) -> bool:
        return pulumi.get(self, "accepted")

    @property
    @pulumi.getter
    def bmc(self) -> Optional['outputs.ServerSpecBmc']:
        """
        BMC defines data about how to talk to the node via ipmitool.
        """
        return pulumi.get(self, "bmc")

    @property
    @pulumi.getter(name="bootFromDiskMethod")
    def boot_from_disk_method(self) -> Optional[str]:
        """
        BootFromDiskMethod specifies the method to exit iPXE to force boot from disk. 
         If not set, controller default is used. Valid values: ipxe-exit, http-404, ipxe-sanboot.
        """
        return pulumi.get(self, "boot_from_disk_method")

    @property
    @pulumi.getter(name="configPatches")
    def config_patches(self) -> Optional[Sequence['outputs.ServerSpecConfigPatches']]:
        return pulumi.get(self, "config_patches")

    @property
    @pulumi.getter
    def cordoned(self) -> Optional[bool]:
        return pulumi.get(self, "cordoned")

    @property
    @pulumi.getter(name="environmentRef")
    def environment_ref(self) -> Optional['outputs.ServerSpecEnvironmentRef']:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        """
        return pulumi.get(self, "environment_ref")

    @property
    @pulumi.getter
    def hardware(self) -> Optional['outputs.ServerSpecHardware']:
        return pulumi.get(self, "hardware")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="managementApi")
    def management_api(self) -> Optional['outputs.ServerSpecManagementApi']:
        """
        ManagementAPI defines data about how to talk to the node via simple HTTP API.
        """
        return pulumi.get(self, "management_api")

    @property
    @pulumi.getter(name="pxeBootAlways")
    def pxe_boot_always(self) -> Optional[bool]:
        return pulumi.get(self, "pxe_boot_always")

    @property
    @pulumi.getter(name="pxeMode")
    def pxe_mode(self) -> Optional[str]:
        """
        PXEMode specifies the method to trigger PXE boot via IPMI. 
         If not set, controller default is used. Valid values: uefi, bios.
        """
        return pulumi.get(self, "pxe_mode")


@pulumi.output_type
class ServerSpecBmc(dict):
    """
    BMC defines data about how to talk to the node via ipmitool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pass":
            suggest = "pass_"
        elif key == "passFrom":
            suggest = "pass_from"
        elif key == "userFrom":
            suggest = "user_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecBmc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecBmc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecBmc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 interface: Optional[str] = None,
                 pass_: Optional[str] = None,
                 pass_from: Optional['outputs.ServerSpecBmcPassFrom'] = None,
                 port: Optional[int] = None,
                 user: Optional[str] = None,
                 user_from: Optional['outputs.ServerSpecBmcUserFrom'] = None):
        """
        BMC defines data about how to talk to the node via ipmitool.
        :param str endpoint: BMC endpoint.
        :param str interface: BMC Interface Type. Defaults to lanplus.
        :param str pass_: BMC password value.
        :param 'ServerSpecBmcPassFromArgs' pass_from: Source for the password value. Cannot be used if Pass is not empty.
        :param int port: BMC port. Defaults to 623.
        :param str user: BMC user value.
        :param 'ServerSpecBmcUserFromArgs' user_from: Source for the user value. Cannot be used if User is not empty.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if pass_ is not None:
            pulumi.set(__self__, "pass_", pass_)
        if pass_from is not None:
            pulumi.set(__self__, "pass_from", pass_from)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if user_from is not None:
            pulumi.set(__self__, "user_from", user_from)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        BMC endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        BMC Interface Type. Defaults to lanplus.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> Optional[str]:
        """
        BMC password value.
        """
        return pulumi.get(self, "pass_")

    @property
    @pulumi.getter(name="passFrom")
    def pass_from(self) -> Optional['outputs.ServerSpecBmcPassFrom']:
        """
        Source for the password value. Cannot be used if Pass is not empty.
        """
        return pulumi.get(self, "pass_from")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        BMC port. Defaults to 623.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        BMC user value.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="userFrom")
    def user_from(self) -> Optional['outputs.ServerSpecBmcUserFrom']:
        """
        Source for the user value. Cannot be used if User is not empty.
        """
        return pulumi.get(self, "user_from")


@pulumi.output_type
class ServerSpecBmcPassFrom(dict):
    """
    Source for the password value. Cannot be used if Pass is not empty.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecBmcPassFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecBmcPassFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecBmcPassFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key_ref: Optional['outputs.ServerSpecBmcPassFromSecretKeyRef'] = None):
        """
        Source for the password value. Cannot be used if Pass is not empty.
        :param 'ServerSpecBmcPassFromSecretKeyRefArgs' secret_key_ref: SecretKeyRef defines a ref to a given key within a secret.
        """
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.ServerSpecBmcPassFromSecretKeyRef']:
        """
        SecretKeyRef defines a ref to a given key within a secret.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class ServerSpecBmcPassFromSecretKeyRef(dict):
    """
    SecretKeyRef defines a ref to a given key within a secret.
    """
    def __init__(__self__, *,
                 key: str,
                 name: str,
                 namespace: str):
        """
        SecretKeyRef defines a ref to a given key within a secret.
        :param str key: Key to select
        :param str namespace: Namespace and name of credential secret nb: can't use namespacedname here b/c it doesn't have json tags in the struct :(
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key to select
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace and name of credential secret nb: can't use namespacedname here b/c it doesn't have json tags in the struct :(
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServerSpecBmcUserFrom(dict):
    """
    Source for the user value. Cannot be used if User is not empty.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecBmcUserFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecBmcUserFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecBmcUserFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key_ref: Optional['outputs.ServerSpecBmcUserFromSecretKeyRef'] = None):
        """
        Source for the user value. Cannot be used if User is not empty.
        :param 'ServerSpecBmcUserFromSecretKeyRefArgs' secret_key_ref: SecretKeyRef defines a ref to a given key within a secret.
        """
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.ServerSpecBmcUserFromSecretKeyRef']:
        """
        SecretKeyRef defines a ref to a given key within a secret.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class ServerSpecBmcUserFromSecretKeyRef(dict):
    """
    SecretKeyRef defines a ref to a given key within a secret.
    """
    def __init__(__self__, *,
                 key: str,
                 name: str,
                 namespace: str):
        """
        SecretKeyRef defines a ref to a given key within a secret.
        :param str key: Key to select
        :param str namespace: Namespace and name of credential secret nb: can't use namespacedname here b/c it doesn't have json tags in the struct :(
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key to select
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace and name of credential secret nb: can't use namespacedname here b/c it doesn't have json tags in the struct :(
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServerSpecConfigPatches(dict):
    def __init__(__self__, *,
                 op: str,
                 path: str,
                 value: Optional[Mapping[str, Any]] = None):
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerSpecEnvironmentRef(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
     Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecEnvironmentRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecEnvironmentRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecEnvironmentRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ServerSpecHardware(dict):
    def __init__(__self__, *,
                 compute: Optional['outputs.ServerSpecHardwareCompute'] = None,
                 memory: Optional['outputs.ServerSpecHardwareMemory'] = None,
                 network: Optional['outputs.ServerSpecHardwareNetwork'] = None,
                 storage: Optional['outputs.ServerSpecHardwareStorage'] = None,
                 system: Optional['outputs.ServerSpecHardwareSystem'] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.ServerSpecHardwareCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def memory(self) -> Optional['outputs.ServerSpecHardwareMemory']:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.ServerSpecHardwareNetwork']:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.ServerSpecHardwareStorage']:
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def system(self) -> Optional['outputs.ServerSpecHardwareSystem']:
        return pulumi.get(self, "system")


@pulumi.output_type
class ServerSpecHardwareCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "processorCount":
            suggest = "processor_count"
        elif key == "totalCoreCount":
            suggest = "total_core_count"
        elif key == "totalThreadCount":
            suggest = "total_thread_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processor_count: Optional[int] = None,
                 processors: Optional[Sequence['outputs.ServerSpecHardwareComputeProcessors']] = None,
                 total_core_count: Optional[int] = None,
                 total_thread_count: Optional[int] = None):
        if processor_count is not None:
            pulumi.set(__self__, "processor_count", processor_count)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if total_core_count is not None:
            pulumi.set(__self__, "total_core_count", total_core_count)
        if total_thread_count is not None:
            pulumi.set(__self__, "total_thread_count", total_thread_count)

    @property
    @pulumi.getter(name="processorCount")
    def processor_count(self) -> Optional[int]:
        return pulumi.get(self, "processor_count")

    @property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.ServerSpecHardwareComputeProcessors']]:
        return pulumi.get(self, "processors")

    @property
    @pulumi.getter(name="totalCoreCount")
    def total_core_count(self) -> Optional[int]:
        return pulumi.get(self, "total_core_count")

    @property
    @pulumi.getter(name="totalThreadCount")
    def total_thread_count(self) -> Optional[int]:
        return pulumi.get(self, "total_thread_count")


@pulumi.output_type
class ServerSpecHardwareComputeProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreCount":
            suggest = "core_count"
        elif key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "threadCount":
            suggest = "thread_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareComputeProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareComputeProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareComputeProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_count: Optional[int] = None,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 speed: Optional[int] = None,
                 thread_count: Optional[int] = None):
        """
        :param int speed: Speed is in megahertz (Mhz)
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if thread_count is not None:
            pulumi.set(__self__, "thread_count", thread_count)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def speed(self) -> Optional[int]:
        """
        Speed is in megahertz (Mhz)
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter(name="threadCount")
    def thread_count(self) -> Optional[int]:
        return pulumi.get(self, "thread_count")


@pulumi.output_type
class ServerSpecHardwareMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "moduleCount":
            suggest = "module_count"
        elif key == "totalSize":
            suggest = "total_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 module_count: Optional[int] = None,
                 modules: Optional[Sequence['outputs.ServerSpecHardwareMemoryModules']] = None,
                 total_size: Optional[str] = None):
        if module_count is not None:
            pulumi.set(__self__, "module_count", module_count)
        if modules is not None:
            pulumi.set(__self__, "modules", modules)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @property
    @pulumi.getter(name="moduleCount")
    def module_count(self) -> Optional[int]:
        return pulumi.get(self, "module_count")

    @property
    @pulumi.getter
    def modules(self) -> Optional[Sequence['outputs.ServerSpecHardwareMemoryModules']]:
        return pulumi.get(self, "modules")

    @property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[str]:
        return pulumi.get(self, "total_size")


@pulumi.output_type
class ServerSpecHardwareMemoryModules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareMemoryModules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareMemoryModules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareMemoryModules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 size: Optional[int] = None,
                 speed: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int size: Size is in megabytes (MB)
        :param int speed: Speed is in megatransfers per second (MT/S)
        """
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size is in megabytes (MB)
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def speed(self) -> Optional[int]:
        """
        Speed is in megatransfers per second (MT/S)
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerSpecHardwareNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceCount":
            suggest = "interface_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_count: Optional[int] = None,
                 interfaces: Optional[Sequence['outputs.ServerSpecHardwareNetworkInterfaces']] = None):
        if interface_count is not None:
            pulumi.set(__self__, "interface_count", interface_count)
        if interfaces is not None:
            pulumi.set(__self__, "interfaces", interfaces)

    @property
    @pulumi.getter(name="interfaceCount")
    def interface_count(self) -> Optional[int]:
        return pulumi.get(self, "interface_count")

    @property
    @pulumi.getter
    def interfaces(self) -> Optional[Sequence['outputs.ServerSpecHardwareNetworkInterfaces']]:
        return pulumi.get(self, "interfaces")


@pulumi.output_type
class ServerSpecHardwareNetworkInterfaces(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 flags: Optional[str] = None,
                 index: Optional[int] = None,
                 mac: Optional[str] = None,
                 mtu: Optional[int] = None,
                 name: Optional[str] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def flags(self) -> Optional[str]:
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ServerSpecHardwareStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceCount":
            suggest = "device_count"
        elif key == "totalSize":
            suggest = "total_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_count: Optional[int] = None,
                 devices: Optional[Sequence['outputs.ServerSpecHardwareStorageDevices']] = None,
                 total_size: Optional[str] = None):
        if device_count is not None:
            pulumi.set(__self__, "device_count", device_count)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @property
    @pulumi.getter(name="deviceCount")
    def device_count(self) -> Optional[int]:
        return pulumi.get(self, "device_count")

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.ServerSpecHardwareStorageDevices']]:
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[str]:
        return pulumi.get(self, "total_size")


@pulumi.output_type
class ServerSpecHardwareStorageDevices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareStorageDevices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareStorageDevices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareStorageDevices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 name: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 size: Optional[int] = None,
                 type: Optional[str] = None,
                 uuid: Optional[str] = None,
                 wwid: Optional[str] = None):
        """
        :param int size: Size is in bytes
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if wwid is not None:
            pulumi.set(__self__, "wwid", wwid)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        Size is in bytes
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def wwid(self) -> Optional[str]:
        return pulumi.get(self, "wwid")


@pulumi.output_type
class ServerSpecHardwareSystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productName":
            suggest = "product_name"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "skuNumber":
            suggest = "sku_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSpecHardwareSystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSpecHardwareSystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSpecHardwareSystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 family: Optional[str] = None,
                 manufacturer: Optional[str] = None,
                 product_name: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 sku_number: Optional[str] = None,
                 uuid: Optional[str] = None,
                 version: Optional[str] = None):
        if family is not None:
            pulumi.set(__self__, "family", family)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if sku_number is not None:
            pulumi.set(__self__, "sku_number", sku_number)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="skuNumber")
    def sku_number(self) -> Optional[str]:
        return pulumi.get(self, "sku_number")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ServerSpecManagementApi(dict):
    """
    ManagementAPI defines data about how to talk to the node via simple HTTP API.
    """
    def __init__(__self__, *,
                 endpoint: str):
        """
        ManagementAPI defines data about how to talk to the node via simple HTTP API.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class ServerStatus(dict):
    """
    ServerStatus defines the observed state of Server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inUse":
            suggest = "in_use"
        elif key == "isClean":
            suggest = "is_clean"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.ServerStatusAddresses']] = None,
                 conditions: Optional[Sequence['outputs.ServerStatusConditions']] = None,
                 in_use: Optional[bool] = None,
                 is_clean: Optional[bool] = None,
                 power: Optional[str] = None,
                 ready: Optional[bool] = None):
        """
        ServerStatus defines the observed state of Server.
        :param Sequence['ServerStatusAddressesArgs'] addresses: Addresses lists discovered node IPs.
        :param Sequence['ServerStatusConditionsArgs'] conditions: Conditions defines current service state of the Server.
        :param bool in_use: InUse is true when server is assigned to some MetalMachine.
        :param bool is_clean: IsClean is true when server disks are wiped.
        :param str power: Power is the current power state of the server: "on", "off" or "unknown".
        :param bool ready: Ready is true when server is accepted and in use.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if in_use is not None:
            pulumi.set(__self__, "in_use", in_use)
        if is_clean is not None:
            pulumi.set(__self__, "is_clean", is_clean)
        if power is not None:
            pulumi.set(__self__, "power", power)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.ServerStatusAddresses']]:
        """
        Addresses lists discovered node IPs.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ServerStatusConditions']]:
        """
        Conditions defines current service state of the Server.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="inUse")
    def in_use(self) -> Optional[bool]:
        """
        InUse is true when server is assigned to some MetalMachine.
        """
        return pulumi.get(self, "in_use")

    @property
    @pulumi.getter(name="isClean")
    def is_clean(self) -> Optional[bool]:
        """
        IsClean is true when server disks are wiped.
        """
        return pulumi.get(self, "is_clean")

    @property
    @pulumi.getter
    def power(self) -> Optional[str]:
        """
        Power is the current power state of the server: "on", "off" or "unknown".
        """
        return pulumi.get(self, "power")

    @property
    @pulumi.getter
    def ready(self) -> Optional[bool]:
        """
        Ready is true when server is accepted and in use.
        """
        return pulumi.get(self, "ready")


@pulumi.output_type
class ServerStatusAddresses(dict):
    """
    NodeAddress contains information for the node's address.
    """
    def __init__(__self__, *,
                 address: str,
                 type: str):
        """
        NodeAddress contains information for the node's address.
        :param str address: The node address.
        :param str type: Node address type, one of Hostname, ExternalIP or InternalIP.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The node address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Node address type, one of Hostname, ExternalIP or InternalIP.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerStatusConditions(dict):
    """
    Condition defines an observation of a Cluster API resource operational state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerStatusConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerStatusConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerStatusConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: str,
                 status: str,
                 type: str,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 severity: Optional[str] = None):
        """
        Condition defines an observation of a Cluster API resource operational state.
        :param str last_transition_time: Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        :param str message: A human readable message indicating details about the transition. This field may be empty.
        :param str reason: The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        :param str severity: Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> str:
        """
        Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition. This field may be empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
        """
        return pulumi.get(self, "severity")


