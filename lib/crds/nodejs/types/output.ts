// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace addons {
    export namespace v1alpha3 {
        /**
         * ClusterResourceSetBindingSpec defines the desired state of ClusterResourceSetBinding.
         */
        export interface ClusterResourceSetBindingSpec {
            /**
             * Bindings is a list of ClusterResourceSets and their resources.
             */
            bindings?: outputs.addons.v1alpha3.ClusterResourceSetBindingSpecBindings[];
        }

        /**
         * ResourceSetBinding keeps info on all of the resources in a ClusterResourceSet.
         */
        export interface ClusterResourceSetBindingSpecBindings {
            /**
             * ClusterResourceSetName is the name of the ClusterResourceSet that is applied to the owner cluster of the binding.
             */
            clusterResourceSetName: string;
            /**
             * Resources is a list of resources that the ClusterResourceSet has.
             */
            resources?: outputs.addons.v1alpha3.ClusterResourceSetBindingSpecBindingsResources[];
        }

        /**
         * ResourceBinding shows the status of a resource that belongs to a ClusterResourceSet matched by the owner cluster of the ClusterResourceSetBinding object.
         */
        export interface ClusterResourceSetBindingSpecBindingsResources {
            /**
             * Applied is to track if a resource is applied to the cluster or not.
             */
            applied: boolean;
            /**
             * Hash is the hash of a resource's data. This can be used to decide if a resource is changed. For "ApplyOnce" ClusterResourceSet.spec.strategy, this is no-op as that strategy does not act on change.
             */
            hash?: string;
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * LastAppliedTime identifies when this resource was last applied to the cluster.
             */
            lastAppliedTime?: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetSpec defines the desired state of ClusterResourceSet.
         */
        export interface ClusterResourceSetSpec {
            /**
             * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable.
             */
            clusterSelector: outputs.addons.v1alpha3.ClusterResourceSetSpecClusterSelector;
            /**
             * Resources is a list of Secrets/ConfigMaps where each contains 1 or more resources to be applied to remote clusters.
             */
            resources?: outputs.addons.v1alpha3.ClusterResourceSetSpecResources[];
            /**
             * Strategy is the strategy to be used during applying resources. Defaults to ApplyOnce. This field is immutable.
             */
            strategy?: string;
        }

        /**
         * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable.
         */
        export interface ClusterResourceSetSpecClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.addons.v1alpha3.ClusterResourceSetSpecClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ClusterResourceSetSpecClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * ResourceRef specifies a resource.
         */
        export interface ClusterResourceSetSpecResources {
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetStatus defines the observed state of ClusterResourceSet.
         */
        export interface ClusterResourceSetStatus {
            /**
             * Conditions defines current state of the ClusterResourceSet.
             */
            conditions?: outputs.addons.v1alpha3.ClusterResourceSetStatusConditions[];
            /**
             * ObservedGeneration reflects the generation of the most recently observed ClusterResourceSet.
             */
            observedGeneration?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterResourceSetStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

    }

    export namespace v1alpha4 {
        /**
         * ClusterResourceSetBindingSpec defines the desired state of ClusterResourceSetBinding.
         */
        export interface ClusterResourceSetBindingSpec {
            /**
             * Bindings is a list of ClusterResourceSets and their resources.
             */
            bindings?: outputs.addons.v1alpha4.ClusterResourceSetBindingSpecBindings[];
        }

        /**
         * ResourceSetBinding keeps info on all of the resources in a ClusterResourceSet.
         */
        export interface ClusterResourceSetBindingSpecBindings {
            /**
             * ClusterResourceSetName is the name of the ClusterResourceSet that is applied to the owner cluster of the binding.
             */
            clusterResourceSetName: string;
            /**
             * Resources is a list of resources that the ClusterResourceSet has.
             */
            resources?: outputs.addons.v1alpha4.ClusterResourceSetBindingSpecBindingsResources[];
        }

        /**
         * ResourceBinding shows the status of a resource that belongs to a ClusterResourceSet matched by the owner cluster of the ClusterResourceSetBinding object.
         */
        export interface ClusterResourceSetBindingSpecBindingsResources {
            /**
             * Applied is to track if a resource is applied to the cluster or not.
             */
            applied: boolean;
            /**
             * Hash is the hash of a resource's data. This can be used to decide if a resource is changed. For "ApplyOnce" ClusterResourceSet.spec.strategy, this is no-op as that strategy does not act on change.
             */
            hash?: string;
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * LastAppliedTime identifies when this resource was last applied to the cluster.
             */
            lastAppliedTime?: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetSpec defines the desired state of ClusterResourceSet.
         */
        export interface ClusterResourceSetSpec {
            /**
             * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable. Label selector cannot be empty.
             */
            clusterSelector: outputs.addons.v1alpha4.ClusterResourceSetSpecClusterSelector;
            /**
             * Resources is a list of Secrets/ConfigMaps where each contains 1 or more resources to be applied to remote clusters.
             */
            resources?: outputs.addons.v1alpha4.ClusterResourceSetSpecResources[];
            /**
             * Strategy is the strategy to be used during applying resources. Defaults to ApplyOnce. This field is immutable.
             */
            strategy?: string;
        }

        /**
         * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable. Label selector cannot be empty.
         */
        export interface ClusterResourceSetSpecClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.addons.v1alpha4.ClusterResourceSetSpecClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ClusterResourceSetSpecClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * ResourceRef specifies a resource.
         */
        export interface ClusterResourceSetSpecResources {
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetStatus defines the observed state of ClusterResourceSet.
         */
        export interface ClusterResourceSetStatus {
            /**
             * Conditions defines current state of the ClusterResourceSet.
             */
            conditions?: outputs.addons.v1alpha4.ClusterResourceSetStatusConditions[];
            /**
             * ObservedGeneration reflects the generation of the most recently observed ClusterResourceSet.
             */
            observedGeneration?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterResourceSetStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

    }

    export namespace v1beta1 {
        /**
         * ClusterResourceSetBindingSpec defines the desired state of ClusterResourceSetBinding.
         */
        export interface ClusterResourceSetBindingSpec {
            /**
             * Bindings is a list of ClusterResourceSets and their resources.
             */
            bindings?: outputs.addons.v1beta1.ClusterResourceSetBindingSpecBindings[];
            /**
             * ClusterName is the name of the Cluster this binding applies to. Note: this field mandatory in v1beta2.
             */
            clusterName?: string;
        }

        /**
         * ResourceSetBinding keeps info on all of the resources in a ClusterResourceSet.
         */
        export interface ClusterResourceSetBindingSpecBindings {
            /**
             * ClusterResourceSetName is the name of the ClusterResourceSet that is applied to the owner cluster of the binding.
             */
            clusterResourceSetName: string;
            /**
             * Resources is a list of resources that the ClusterResourceSet has.
             */
            resources?: outputs.addons.v1beta1.ClusterResourceSetBindingSpecBindingsResources[];
        }

        /**
         * ResourceBinding shows the status of a resource that belongs to a ClusterResourceSet matched by the owner cluster of the ClusterResourceSetBinding object.
         */
        export interface ClusterResourceSetBindingSpecBindingsResources {
            /**
             * Applied is to track if a resource is applied to the cluster or not.
             */
            applied: boolean;
            /**
             * Hash is the hash of a resource's data. This can be used to decide if a resource is changed. For "ApplyOnce" ClusterResourceSet.spec.strategy, this is no-op as that strategy does not act on change.
             */
            hash?: string;
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * LastAppliedTime identifies when this resource was last applied to the cluster.
             */
            lastAppliedTime?: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetSpec defines the desired state of ClusterResourceSet.
         */
        export interface ClusterResourceSetSpec {
            /**
             * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable. Label selector cannot be empty.
             */
            clusterSelector: outputs.addons.v1beta1.ClusterResourceSetSpecClusterSelector;
            /**
             * Resources is a list of Secrets/ConfigMaps where each contains 1 or more resources to be applied to remote clusters.
             */
            resources?: outputs.addons.v1beta1.ClusterResourceSetSpecResources[];
            /**
             * Strategy is the strategy to be used during applying resources. Defaults to ApplyOnce. This field is immutable.
             */
            strategy?: string;
        }

        /**
         * Label selector for Clusters. The Clusters that are selected by this will be the ones affected by this ClusterResourceSet. It must match the Cluster labels. This field is immutable. Label selector cannot be empty.
         */
        export interface ClusterResourceSetSpecClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.addons.v1beta1.ClusterResourceSetSpecClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ClusterResourceSetSpecClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * ResourceRef specifies a resource.
         */
        export interface ClusterResourceSetSpecResources {
            /**
             * Kind of the resource. Supported kinds are: Secrets and ConfigMaps.
             */
            kind: string;
            /**
             * Name of the resource that is in the same namespace with ClusterResourceSet object.
             */
            name: string;
        }

        /**
         * ClusterResourceSetStatus defines the observed state of ClusterResourceSet.
         */
        export interface ClusterResourceSetStatus {
            /**
             * Conditions defines current state of the ClusterResourceSet.
             */
            conditions?: outputs.addons.v1beta1.ClusterResourceSetStatusConditions[];
            /**
             * ObservedGeneration reflects the generation of the most recently observed ClusterResourceSet.
             */
            observedGeneration?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterResourceSetStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

    }
}

export namespace bootstrap {
    export namespace v1alpha2 {
        /**
         * TalosConfigSpec defines the desired state of TalosConfig
         */
        export interface TalosConfigSpec {
            data?: string;
            generateType: string;
        }

        /**
         * TalosConfigStatus defines the observed state of TalosConfig
         */
        export interface TalosConfigStatus {
            /**
             * BootstrapData will be a slice of bootstrap data
             */
            bootstrapData?: string;
            /**
             * ErrorMessage will be set on non-retryable errors
             */
            errorMessage?: string;
            /**
             * ErrorReason will be set on non-retryable errors
             */
            errorReason?: string;
            /**
             * Ready indicates the BootstrapData field is ready to be consumed
             */
            ready?: boolean;
            /**
             * Talos config will be a string containing the config for download
             */
            talosConfig?: string;
        }

        /**
         * TalosConfigTemplateSpec defines the desired state of TalosConfigTemplate
         */
        export interface TalosConfigTemplateSpec {
            /**
             * TalosConfigTemplateResource defines the Template structure
             */
            template: outputs.bootstrap.v1alpha2.TalosConfigTemplateSpecTemplate;
        }

        /**
         * TalosConfigTemplateResource defines the Template structure
         */
        export interface TalosConfigTemplateSpecTemplate {
            /**
             * TalosConfigSpec defines the desired state of TalosConfig
             */
            spec?: outputs.bootstrap.v1alpha2.TalosConfigTemplateSpecTemplateSpec;
        }

        /**
         * TalosConfigSpec defines the desired state of TalosConfig
         */
        export interface TalosConfigTemplateSpecTemplateSpec {
            data?: string;
            generateType: string;
        }

    }

    export namespace v1alpha3 {
        /**
         * TalosConfigSpec defines the desired state of TalosConfig
         */
        export interface TalosConfigSpec {
            configPatches?: outputs.bootstrap.v1alpha3.TalosConfigSpecConfigPatches[];
            data?: string;
            generateType: string;
            /**
             * Set hostname in the machine configuration to some value.
             */
            hostname?: outputs.bootstrap.v1alpha3.TalosConfigSpecHostname;
            talosVersion?: string;
        }

        export interface TalosConfigSpecConfigPatches {
            op: string;
            path: string;
            value?: {[key: string]: any};
        }

        /**
         * Set hostname in the machine configuration to some value.
         */
        export interface TalosConfigSpecHostname {
            /**
             * Source of the hostname. 
             *  Allowed values: "MachineName" (use linked Machine's Name).
             */
            source?: string;
        }

        /**
         * TalosConfigStatus defines the observed state of TalosConfig
         */
        export interface TalosConfigStatus {
            /**
             * Conditions defines current service state of the TalosConfig.
             */
            conditions?: outputs.bootstrap.v1alpha3.TalosConfigStatusConditions[];
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script.
             */
            dataSecretName?: string;
            /**
             * FailureMessage will be set on non-retryable errors
             */
            failureMessage?: string;
            /**
             * FailureReason will be set on non-retryable errors
             */
            failureReason?: string;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Ready indicates the BootstrapData field is ready to be consumed
             */
            ready?: boolean;
            /**
             * Talos config will be a string containing the config for download. 
             *  Deprecated: please use `<cluster>-talosconfig` secret.
             */
            talosConfig?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface TalosConfigStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * TalosConfigTemplateSpec defines the desired state of TalosConfigTemplate
         */
        export interface TalosConfigTemplateSpec {
            /**
             * TalosConfigTemplateResource defines the Template structure
             */
            template: outputs.bootstrap.v1alpha3.TalosConfigTemplateSpecTemplate;
        }

        /**
         * TalosConfigTemplateResource defines the Template structure
         */
        export interface TalosConfigTemplateSpecTemplate {
            /**
             * TalosConfigSpec defines the desired state of TalosConfig
             */
            spec?: outputs.bootstrap.v1alpha3.TalosConfigTemplateSpecTemplateSpec;
        }

        /**
         * TalosConfigSpec defines the desired state of TalosConfig
         */
        export interface TalosConfigTemplateSpecTemplateSpec {
            configPatches?: outputs.bootstrap.v1alpha3.TalosConfigTemplateSpecTemplateSpecConfigPatches[];
            data?: string;
            generateType: string;
            /**
             * Set hostname in the machine configuration to some value.
             */
            hostname?: outputs.bootstrap.v1alpha3.TalosConfigTemplateSpecTemplateSpecHostname;
            talosVersion?: string;
        }

        export interface TalosConfigTemplateSpecTemplateSpecConfigPatches {
            op: string;
            path: string;
            value?: {[key: string]: any};
        }

        /**
         * Set hostname in the machine configuration to some value.
         */
        export interface TalosConfigTemplateSpecTemplateSpecHostname {
            /**
             * Source of the hostname. 
             *  Allowed values: "MachineName" (use linked Machine's Name).
             */
            source?: string;
        }

    }
}

export namespace cluster {
    export namespace v1alpha3 {
        /**
         * ClusterSpec defines the desired state of Cluster.
         */
        export interface ClusterSpec {
            /**
             * Cluster network configuration.
             */
            clusterNetwork?: outputs.cluster.v1alpha3.ClusterSpecClusterNetwork;
            /**
             * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
             */
            controlPlaneEndpoint?: outputs.cluster.v1alpha3.ClusterSpecControlPlaneEndpoint;
            /**
             * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
             */
            controlPlaneRef?: outputs.cluster.v1alpha3.ClusterSpecControlPlaneRef;
            /**
             * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
             */
            infrastructureRef?: outputs.cluster.v1alpha3.ClusterSpecInfrastructureRef;
            /**
             * Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
             */
            paused?: boolean;
        }

        /**
         * Cluster network configuration.
         */
        export interface ClusterSpecClusterNetwork {
            /**
             * APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
             */
            apiServerPort?: number;
            /**
             * The network ranges from which Pod networks are allocated.
             */
            pods?: outputs.cluster.v1alpha3.ClusterSpecClusterNetworkPods;
            /**
             * Domain name for services.
             */
            serviceDomain?: string;
            /**
             * The network ranges from which service VIPs are allocated.
             */
            services?: outputs.cluster.v1alpha3.ClusterSpecClusterNetworkServices;
        }

        /**
         * The network ranges from which Pod networks are allocated.
         */
        export interface ClusterSpecClusterNetworkPods {
            cidrBlocks: string[];
        }

        /**
         * The network ranges from which service VIPs are allocated.
         */
        export interface ClusterSpecClusterNetworkServices {
            cidrBlocks: string[];
        }

        /**
         * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
         */
        export interface ClusterSpecControlPlaneEndpoint {
            /**
             * The hostname on which the API server is serving.
             */
            host: string;
            /**
             * The port on which the API server is serving.
             */
            port: number;
        }

        /**
         * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
         */
        export interface ClusterSpecControlPlaneRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
         */
        export interface ClusterSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * ClusterStatus defines the observed state of Cluster.
         */
        export interface ClusterStatus {
            /**
             * Conditions defines current service state of the cluster.
             */
            conditions?: outputs.cluster.v1alpha3.ClusterStatusConditions[];
            /**
             * ControlPlaneInitialized defines if the control plane has been initialized.
             */
            controlPlaneInitialized?: boolean;
            /**
             * ControlPlaneReady defines if the control plane is ready.
             */
            controlPlaneReady?: boolean;
            /**
             * FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
             */
            failureDomains?: {[key: string]: outputs.cluster.v1alpha3.ClusterStatusFailureDomains};
            /**
             * FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
         */
        export interface ClusterStatusFailureDomains {
            /**
             * Attributes is a free form map of attributes an infrastructure provider might use or require.
             */
            attributes?: {[key: string]: string};
            /**
             * ControlPlane determines if this failure domain is suitable for use by control plane machines.
             */
            controlPlane?: boolean;
        }

        /**
         * MachineDeploymentSpec defines the desired state of MachineDeployment.
         */
        export interface MachineDeploymentSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * Indicates that the deployment is paused.
             */
            paused?: boolean;
            /**
             * The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
             */
            progressDeadlineSeconds?: number;
            /**
             * Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
             */
            replicas?: number;
            /**
             * The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
             */
            revisionHistoryLimit?: number;
            /**
             * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
             */
            selector: outputs.cluster.v1alpha3.MachineDeploymentSpecSelector;
            /**
             * The deployment strategy to use to replace existing machines with new ones.
             */
            strategy?: outputs.cluster.v1alpha3.MachineDeploymentSpecStrategy;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplate;
        }

        /**
         * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
         */
        export interface MachineDeploymentSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha3.MachineDeploymentSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineDeploymentSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * The deployment strategy to use to replace existing machines with new ones.
         */
        export interface MachineDeploymentSpecStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1alpha3.MachineDeploymentSpecStrategyRollingUpdate;
            /**
             * Type of deployment. Currently the only supported strategy is "RollingUpdate". Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface MachineDeploymentSpecStrategyRollingUpdate {
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachineDeploymentSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineDeploymentSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. 
             *  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). 
             *  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            generateName?: string;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            name?: string;
            /**
             * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. 
             *  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            namespace?: string;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            ownerReferences?: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateMetadataOwnerReferences[];
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface MachineDeploymentSpecTemplateMetadataOwnerReferences {
            /**
             * API version of the referent.
             */
            apiVersion: string;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: boolean;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: boolean;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string;
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineDeploymentSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha3.MachineDeploymentSpecTemplateSpecBootstrapConfigRef;
            /**
             * Data contains the bootstrap data, such as cloud-init details scripts. If nil, the Machine should remain in the Pending state. 
             *  Deprecated: Switch to DataSecretName.
             */
            data?: string;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineDeploymentSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineDeploymentStatus defines the observed state of MachineDeployment.
         */
        export interface MachineDeploymentStatus {
            /**
             * Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
             */
            availableReplicas?: number;
            /**
             * The generation observed by the deployment controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
             */
            phase?: string;
            /**
             * Total number of ready machines targeted by this deployment.
             */
            readyReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment (their labels match the selector).
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
            /**
             * Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
             */
            unavailableReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment that have the desired template spec.
             */
            updatedReplicas?: number;
        }

        /**
         * Specification of machine health check policy
         */
        export interface MachineHealthCheckSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1alpha3.MachineHealthCheckSpecRemediationTemplate;
            /**
             * Label selector to match machines whose health will be exercised
             */
            selector: outputs.cluster.v1alpha3.MachineHealthCheckSpecSelector;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions: outputs.cluster.v1alpha3.MachineHealthCheckSpecUnhealthyConditions[];
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface MachineHealthCheckSpecRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Label selector to match machines whose health will be exercised
         */
        export interface MachineHealthCheckSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha3.MachineHealthCheckSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineHealthCheckSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface MachineHealthCheckSpecUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * Most recently observed status of MachineHealthCheck resource
         */
        export interface MachineHealthCheckStatus {
            /**
             * Conditions defines current service state of the MachineHealthCheck.
             */
            conditions?: outputs.cluster.v1alpha3.MachineHealthCheckStatusConditions[];
            /**
             * total number of healthy machines counted by this machine health check
             */
            currentHealthy?: number;
            /**
             * total number of machines counted by this machine health check
             */
            expectedMachines?: number;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
             */
            remediationsAllowed?: number;
            /**
             * Targets shows the current list of machines the machine health check is watching
             */
            targets?: string[];
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineHealthCheckStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * MachinePoolSpec defines the desired state of MachinePool.
         */
        export interface MachinePoolSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomains is the list of failure domains this MachinePool should be attached to.
             */
            failureDomains?: string[];
            /**
             * Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
             */
            providerIDList?: string[];
            /**
             * Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
             */
            replicas?: number;
            /**
             * The deployment strategy to use to replace existing machine instances with new ones.
             */
            strategy?: outputs.cluster.v1alpha3.MachinePoolSpecStrategy;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1alpha3.MachinePoolSpecTemplate;
        }

        /**
         * The deployment strategy to use to replace existing machine instances with new ones.
         */
        export interface MachinePoolSpecStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1alpha3.MachinePoolSpecStrategyRollingUpdate;
            /**
             * Type of deployment. Currently the only supported strategy is "RollingUpdate". Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface MachinePoolSpecStrategyRollingUpdate {
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachinePoolSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha3.MachinePoolSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha3.MachinePoolSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachinePoolSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. 
             *  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). 
             *  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            generateName?: string;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            name?: string;
            /**
             * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. 
             *  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            namespace?: string;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            ownerReferences?: outputs.cluster.v1alpha3.MachinePoolSpecTemplateMetadataOwnerReferences[];
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface MachinePoolSpecTemplateMetadataOwnerReferences {
            /**
             * API version of the referent.
             */
            apiVersion: string;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: boolean;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: boolean;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string;
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachinePoolSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha3.MachinePoolSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha3.MachinePoolSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachinePoolSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha3.MachinePoolSpecTemplateSpecBootstrapConfigRef;
            /**
             * Data contains the bootstrap data, such as cloud-init details scripts. If nil, the Machine should remain in the Pending state. 
             *  Deprecated: Switch to DataSecretName.
             */
            data?: string;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
         */
        export interface MachinePoolSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachinePoolSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachinePoolStatus defines the observed state of MachinePool.
         */
        export interface MachinePoolStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
             */
            availableReplicas?: number;
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * Conditions define the current service state of the MachinePool.
             */
            conditions?: outputs.cluster.v1alpha3.MachinePoolStatusConditions[];
            /**
             * FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * NodeRefs will point to the corresponding Nodes if it they exist.
             */
            nodeRefs?: outputs.cluster.v1alpha3.MachinePoolStatusNodeRefs[];
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
            /**
             * The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
             */
            unavailableReplicas?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachinePoolStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         *  Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
         */
        export interface MachinePoolStatusNodeRefs {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetSpec defines the desired state of MachineSet.
         */
        export interface MachineSetSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
             */
            deletePolicy?: string;
            /**
             * MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
             */
            replicas?: number;
            /**
             * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
             */
            selector: outputs.cluster.v1alpha3.MachineSetSpecSelector;
            /**
             * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
             */
            template?: outputs.cluster.v1alpha3.MachineSetSpecTemplate;
        }

        /**
         * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
         */
        export interface MachineSetSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha3.MachineSetSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineSetSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
         */
        export interface MachineSetSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha3.MachineSetSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha3.MachineSetSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineSetSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server. 
             *  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header). 
             *  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            generateName?: string;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            name?: string;
            /**
             * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. 
             *  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            namespace?: string;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. 
             *  Deprecated: This field has no function and is going to be removed in a next release.
             */
            ownerReferences?: outputs.cluster.v1alpha3.MachineSetSpecTemplateMetadataOwnerReferences[];
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface MachineSetSpecTemplateMetadataOwnerReferences {
            /**
             * API version of the referent.
             */
            apiVersion: string;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: boolean;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: boolean;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string;
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineSetSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha3.MachineSetSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha3.MachineSetSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSetSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha3.MachineSetSpecTemplateSpecBootstrapConfigRef;
            /**
             * Data contains the bootstrap data, such as cloud-init details scripts. If nil, the Machine should remain in the Pending state. 
             *  Deprecated: Switch to DataSecretName.
             */
            data?: string;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
         */
        export interface MachineSetSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSetSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetStatus defines the observed state of MachineSet.
         */
        export interface MachineSetStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
             */
            availableReplicas?: number;
            failureMessage?: string;
            /**
             * In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
             *  These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * The number of replicas that have labels matching the labels of the machine template of the MachineSet.
             */
            fullyLabeledReplicas?: number;
            /**
             * ObservedGeneration reflects the generation of the most recently observed MachineSet.
             */
            observedGeneration?: number;
            /**
             * The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
        }

        /**
         * MachineSpec defines the desired state of Machine.
         */
        export interface MachineSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha3.MachineSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha3.MachineSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha3.MachineSpecBootstrapConfigRef;
            /**
             * Data contains the bootstrap data, such as cloud-init details scripts. If nil, the Machine should remain in the Pending state. 
             *  Deprecated: Switch to DataSecretName.
             */
            data?: string;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.Data without the need of a controller.
         */
        export interface MachineSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineStatus defines the observed state of Machine.
         */
        export interface MachineStatus {
            /**
             * Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
             */
            addresses?: outputs.cluster.v1alpha3.MachineStatusAddresses[];
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * Conditions defines current service state of the Machine.
             */
            conditions?: outputs.cluster.v1alpha3.MachineStatusConditions[];
            /**
             * FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureMessage?: string;
            /**
             * FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * LastUpdated identifies when the phase of the Machine last transitioned.
             */
            lastUpdated?: string;
            /**
             * NodeRef will point to the corresponding Node if it exists.
             */
            nodeRef?: outputs.cluster.v1alpha3.MachineStatusNodeRef;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
            /**
             * Version specifies the current version of Kubernetes running on the corresponding Node. This is meant to be a means of bubbling up status from the Node to the Machine. It is entirely optional, but useful for end-user UX if it’s present.
             */
            version?: string;
        }

        /**
         * MachineAddress contains information for the node's address.
         */
        export interface MachineStatusAddresses {
            /**
             * The machine address.
             */
            address: string;
            /**
             * Machine address type, one of Hostname, ExternalIP or InternalIP.
             */
            type: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * NodeRef will point to the corresponding Node if it exists.
         */
        export interface MachineStatusNodeRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

    }

    export namespace v1alpha4 {
        /**
         * ClusterClassSpec describes the desired state of the ClusterClass.
         */
        export interface ClusterClassSpec {
            /**
             * ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
             */
            controlPlane?: outputs.cluster.v1alpha4.ClusterClassSpecControlPlane;
            /**
             * Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
             */
            infrastructure?: outputs.cluster.v1alpha4.ClusterClassSpecInfrastructure;
            /**
             * Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
             */
            workers?: outputs.cluster.v1alpha4.ClusterClassSpecWorkers;
        }

        /**
         * ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
         */
        export interface ClusterClassSpecControlPlane {
            /**
             * MachineTemplate defines the metadata and infrastructure information for control plane machines. 
             *  This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
             */
            machineInfrastructure?: outputs.cluster.v1alpha4.ClusterClassSpecControlPlaneMachineInfrastructure;
            /**
             * Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
             *  This field is supported if and only if the control plane provider template referenced is Machine based.
             */
            metadata?: outputs.cluster.v1alpha4.ClusterClassSpecControlPlaneMetadata;
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1alpha4.ClusterClassSpecControlPlaneRef;
        }

        /**
         * MachineTemplate defines the metadata and infrastructure information for control plane machines. 
         *  This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
         */
        export interface ClusterClassSpecControlPlaneMachineInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1alpha4.ClusterClassSpecControlPlaneMachineInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecControlPlaneMachineInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         *  This field is supported if and only if the control plane provider template referenced is Machine based.
         */
        export interface ClusterClassSpecControlPlaneMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecControlPlaneRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
         */
        export interface ClusterClassSpecInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1alpha4.ClusterClassSpecInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
         */
        export interface ClusterClassSpecWorkers {
            /**
             * MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
             */
            machineDeployments?: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeployments[];
        }

        /**
         * MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster provisioned using the `ClusterClass`.
         */
        export interface ClusterClassSpecWorkersMachineDeployments {
            /**
             * Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
             */
            class: string;
            /**
             * Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
             */
            template: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplate;
        }

        /**
         * Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplate {
            /**
             * Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
             */
            bootstrap: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap;
            /**
             * Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
             */
            infrastructure: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure;
            /**
             * Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
             */
            metadata?: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata;
        }

        /**
         * Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1alpha4.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * ClusterSpec defines the desired state of Cluster.
         */
        export interface ClusterSpec {
            /**
             * Cluster network configuration.
             */
            clusterNetwork?: outputs.cluster.v1alpha4.ClusterSpecClusterNetwork;
            /**
             * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
             */
            controlPlaneEndpoint?: outputs.cluster.v1alpha4.ClusterSpecControlPlaneEndpoint;
            /**
             * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
             */
            controlPlaneRef?: outputs.cluster.v1alpha4.ClusterSpecControlPlaneRef;
            /**
             * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
             */
            infrastructureRef?: outputs.cluster.v1alpha4.ClusterSpecInfrastructureRef;
            /**
             * Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
             */
            paused?: boolean;
            /**
             * This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
             */
            topology?: outputs.cluster.v1alpha4.ClusterSpecTopology;
        }

        /**
         * Cluster network configuration.
         */
        export interface ClusterSpecClusterNetwork {
            /**
             * APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
             */
            apiServerPort?: number;
            /**
             * The network ranges from which Pod networks are allocated.
             */
            pods?: outputs.cluster.v1alpha4.ClusterSpecClusterNetworkPods;
            /**
             * Domain name for services.
             */
            serviceDomain?: string;
            /**
             * The network ranges from which service VIPs are allocated.
             */
            services?: outputs.cluster.v1alpha4.ClusterSpecClusterNetworkServices;
        }

        /**
         * The network ranges from which Pod networks are allocated.
         */
        export interface ClusterSpecClusterNetworkPods {
            cidrBlocks: string[];
        }

        /**
         * The network ranges from which service VIPs are allocated.
         */
        export interface ClusterSpecClusterNetworkServices {
            cidrBlocks: string[];
        }

        /**
         * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
         */
        export interface ClusterSpecControlPlaneEndpoint {
            /**
             * The hostname on which the API server is serving.
             */
            host: string;
            /**
             * The port on which the API server is serving.
             */
            port: number;
        }

        /**
         * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
         */
        export interface ClusterSpecControlPlaneRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
         */
        export interface ClusterSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
         */
        export interface ClusterSpecTopology {
            /**
             * The name of the ClusterClass object to create the topology.
             */
            class: string;
            /**
             * ControlPlane describes the cluster control plane.
             */
            controlPlane?: outputs.cluster.v1alpha4.ClusterSpecTopologyControlPlane;
            /**
             * RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments.
             */
            rolloutAfter?: string;
            /**
             * The Kubernetes version of the cluster.
             */
            version: string;
            /**
             * Workers encapsulates the different constructs that form the worker nodes for the cluster.
             */
            workers?: outputs.cluster.v1alpha4.ClusterSpecTopologyWorkers;
        }

        /**
         * ControlPlane describes the cluster control plane.
         */
        export interface ClusterSpecTopologyControlPlane {
            /**
             * Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
             *  This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
             */
            metadata?: outputs.cluster.v1alpha4.ClusterSpecTopologyControlPlaneMetadata;
            /**
             * Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
             */
            replicas?: number;
        }

        /**
         * Metadata is the metadata applied to the machines of the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass. 
         *  This field is supported if and only if the control plane provider template referenced in the ClusterClass is Machine based.
         */
        export interface ClusterSpecTopologyControlPlaneMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Workers encapsulates the different constructs that form the worker nodes for the cluster.
         */
        export interface ClusterSpecTopologyWorkers {
            /**
             * MachineDeployments is a list of machine deployments in the cluster.
             */
            machineDeployments?: outputs.cluster.v1alpha4.ClusterSpecTopologyWorkersMachineDeployments[];
        }

        /**
         * MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology. This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
         */
        export interface ClusterSpecTopologyWorkersMachineDeployments {
            /**
             * Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
             */
            class: string;
            /**
             * Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
             */
            metadata?: outputs.cluster.v1alpha4.ClusterSpecTopologyWorkersMachineDeploymentsMetadata;
            /**
             * Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
             */
            name: string;
            /**
             * Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to zero) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
             */
            replicas?: number;
        }

        /**
         * Metadata is the metadata applied to the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * ClusterStatus defines the observed state of Cluster.
         */
        export interface ClusterStatus {
            /**
             * Conditions defines current service state of the cluster.
             */
            conditions?: outputs.cluster.v1alpha4.ClusterStatusConditions[];
            /**
             * ControlPlaneReady defines if the control plane is ready.
             */
            controlPlaneReady?: boolean;
            /**
             * FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
             */
            failureDomains?: {[key: string]: outputs.cluster.v1alpha4.ClusterStatusFailureDomains};
            /**
             * FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
         */
        export interface ClusterStatusFailureDomains {
            /**
             * Attributes is a free form map of attributes an infrastructure provider might use or require.
             */
            attributes?: {[key: string]: string};
            /**
             * ControlPlane determines if this failure domain is suitable for use by control plane machines.
             */
            controlPlane?: boolean;
        }

        /**
         * MachineDeploymentSpec defines the desired state of MachineDeployment.
         */
        export interface MachineDeploymentSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * Indicates that the deployment is paused.
             */
            paused?: boolean;
            /**
             * The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
             */
            progressDeadlineSeconds?: number;
            /**
             * Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
             */
            replicas?: number;
            /**
             * The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
             */
            revisionHistoryLimit?: number;
            /**
             * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
             */
            selector: outputs.cluster.v1alpha4.MachineDeploymentSpecSelector;
            /**
             * The deployment strategy to use to replace existing machines with new ones.
             */
            strategy?: outputs.cluster.v1alpha4.MachineDeploymentSpecStrategy;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplate;
        }
        /**
         * machineDeploymentSpecProvideDefaults sets the appropriate defaults for MachineDeploymentSpec
         */
        export function machineDeploymentSpecProvideDefaults(val: MachineDeploymentSpec): MachineDeploymentSpec {
            return {
                ...val,
                replicas: (val.replicas) ?? 1,
            };
        }

        /**
         * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
         */
        export interface MachineDeploymentSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha4.MachineDeploymentSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineDeploymentSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * The deployment strategy to use to replace existing machines with new ones.
         */
        export interface MachineDeploymentSpecStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1alpha4.MachineDeploymentSpecStrategyRollingUpdate;
            /**
             * Type of deployment. Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface MachineDeploymentSpecStrategyRollingUpdate {
            /**
             * DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
             */
            deletePolicy?: string;
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachineDeploymentSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineDeploymentSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineDeploymentSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha4.MachineDeploymentSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineDeploymentSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineDeploymentStatus defines the observed state of MachineDeployment.
         */
        export interface MachineDeploymentStatus {
            /**
             * Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
             */
            availableReplicas?: number;
            /**
             * Conditions defines current service state of the MachineDeployment.
             */
            conditions?: outputs.cluster.v1alpha4.MachineDeploymentStatusConditions[];
            /**
             * The generation observed by the deployment controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
             */
            phase?: string;
            /**
             * Total number of ready machines targeted by this deployment.
             */
            readyReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment (their labels match the selector).
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
            /**
             * Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
             */
            unavailableReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment that have the desired template spec.
             */
            updatedReplicas?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineDeploymentStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * Specification of machine health check policy
         */
        export interface MachineHealthCheckSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1alpha4.MachineHealthCheckSpecRemediationTemplate;
            /**
             * Label selector to match machines whose health will be exercised
             */
            selector: outputs.cluster.v1alpha4.MachineHealthCheckSpecSelector;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions: outputs.cluster.v1alpha4.MachineHealthCheckSpecUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface MachineHealthCheckSpecRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Label selector to match machines whose health will be exercised
         */
        export interface MachineHealthCheckSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha4.MachineHealthCheckSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineHealthCheckSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface MachineHealthCheckSpecUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * Most recently observed status of MachineHealthCheck resource
         */
        export interface MachineHealthCheckStatus {
            /**
             * Conditions defines current service state of the MachineHealthCheck.
             */
            conditions?: outputs.cluster.v1alpha4.MachineHealthCheckStatusConditions[];
            /**
             * total number of healthy machines counted by this machine health check
             */
            currentHealthy?: number;
            /**
             * total number of machines counted by this machine health check
             */
            expectedMachines?: number;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
             */
            remediationsAllowed?: number;
            /**
             * Targets shows the current list of machines the machine health check is watching
             */
            targets?: string[];
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineHealthCheckStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * MachinePoolSpec defines the desired state of MachinePool.
         */
        export interface MachinePoolSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomains is the list of failure domains this MachinePool should be attached to.
             */
            failureDomains?: string[];
            /**
             * Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
             */
            providerIDList?: string[];
            /**
             * Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
             */
            replicas?: number;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1alpha4.MachinePoolSpecTemplate;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachinePoolSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha4.MachinePoolSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha4.MachinePoolSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachinePoolSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachinePoolSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha4.MachinePoolSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha4.MachinePoolSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachinePoolSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha4.MachinePoolSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachinePoolSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachinePoolSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachinePoolStatus defines the observed state of MachinePool.
         */
        export interface MachinePoolStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
             */
            availableReplicas?: number;
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * Conditions define the current service state of the MachinePool.
             */
            conditions?: outputs.cluster.v1alpha4.MachinePoolStatusConditions[];
            /**
             * FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * NodeRefs will point to the corresponding Nodes if it they exist.
             */
            nodeRefs?: outputs.cluster.v1alpha4.MachinePoolStatusNodeRefs[];
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
            /**
             * The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
             */
            unavailableReplicas?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachinePoolStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         *  Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
         */
        export interface MachinePoolStatusNodeRefs {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetSpec defines the desired state of MachineSet.
         */
        export interface MachineSetSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
             */
            deletePolicy?: string;
            /**
             * MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
             */
            replicas?: number;
            /**
             * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
             */
            selector: outputs.cluster.v1alpha4.MachineSetSpecSelector;
            /**
             * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
             */
            template?: outputs.cluster.v1alpha4.MachineSetSpecTemplate;
        }
        /**
         * machineSetSpecProvideDefaults sets the appropriate defaults for MachineSetSpec
         */
        export function machineSetSpecProvideDefaults(val: MachineSetSpec): MachineSetSpec {
            return {
                ...val,
                replicas: (val.replicas) ?? 1,
            };
        }

        /**
         * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
         */
        export interface MachineSetSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1alpha4.MachineSetSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineSetSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
         */
        export interface MachineSetSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1alpha4.MachineSetSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1alpha4.MachineSetSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineSetSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineSetSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha4.MachineSetSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha4.MachineSetSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSetSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha4.MachineSetSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineSetSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSetSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetStatus defines the observed state of MachineSet.
         */
        export interface MachineSetStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
             */
            availableReplicas?: number;
            /**
             * Conditions defines current service state of the MachineSet.
             */
            conditions?: outputs.cluster.v1alpha4.MachineSetStatusConditions[];
            failureMessage?: string;
            /**
             * In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
             *  These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * The number of replicas that have labels matching the labels of the machine template of the MachineSet.
             */
            fullyLabeledReplicas?: number;
            /**
             * ObservedGeneration reflects the generation of the most recently observed MachineSet.
             */
            observedGeneration?: number;
            /**
             * The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineSetStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * MachineSpec defines the desired state of Machine.
         */
        export interface MachineSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1alpha4.MachineSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1alpha4.MachineSpecInfrastructureRef;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1alpha4.MachineSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineStatus defines the observed state of Machine.
         */
        export interface MachineStatus {
            /**
             * Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
             */
            addresses?: outputs.cluster.v1alpha4.MachineStatusAddresses[];
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * Conditions defines current service state of the Machine.
             */
            conditions?: outputs.cluster.v1alpha4.MachineStatusConditions[];
            /**
             * FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureMessage?: string;
            /**
             * FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * LastUpdated identifies when the phase of the Machine last transitioned.
             */
            lastUpdated?: string;
            /**
             * NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
             */
            nodeInfo?: outputs.cluster.v1alpha4.MachineStatusNodeInfo;
            /**
             * NodeRef will point to the corresponding Node if it exists.
             */
            nodeRef?: outputs.cluster.v1alpha4.MachineStatusNodeRef;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
            /**
             * Version specifies the current version of Kubernetes running on the corresponding Node. This is meant to be a means of bubbling up status from the Node to the Machine. It is entirely optional, but useful for end-user UX if it’s present.
             */
            version?: string;
        }

        /**
         * MachineAddress contains information for the node's address.
         */
        export interface MachineStatusAddresses {
            /**
             * The machine address.
             */
            address: string;
            /**
             * Machine address type, one of Hostname, ExternalIP or InternalIP.
             */
            type: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
         */
        export interface MachineStatusNodeInfo {
            /**
             * The Architecture reported by the node
             */
            architecture: string;
            /**
             * Boot ID reported by the node.
             */
            bootID: string;
            /**
             * ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
             */
            containerRuntimeVersion: string;
            /**
             * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
             */
            kernelVersion: string;
            /**
             * KubeProxy Version reported by the node.
             */
            kubeProxyVersion: string;
            /**
             * Kubelet Version reported by the node.
             */
            kubeletVersion: string;
            /**
             * MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
             */
            machineID: string;
            /**
             * The Operating System reported by the node
             */
            operatingSystem: string;
            /**
             * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
             */
            osImage: string;
            /**
             * SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
             */
            systemUUID: string;
        }

        /**
         * NodeRef will point to the corresponding Node if it exists.
         */
        export interface MachineStatusNodeRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

    }

    export namespace v1beta1 {
        /**
         * ClusterClassSpec describes the desired state of the ClusterClass.
         */
        export interface ClusterClassSpec {
            /**
             * ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
             */
            controlPlane?: outputs.cluster.v1beta1.ClusterClassSpecControlPlane;
            /**
             * Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
             */
            infrastructure?: outputs.cluster.v1beta1.ClusterClassSpecInfrastructure;
            /**
             * Patches defines the patches which are applied to customize referenced templates of a ClusterClass. Note: Patches will be applied in the order of the array.
             */
            patches?: outputs.cluster.v1beta1.ClusterClassSpecPatches[];
            /**
             * Variables defines the variables which can be configured in the Cluster topology and are then used in patches.
             */
            variables?: outputs.cluster.v1beta1.ClusterClassSpecVariables[];
            /**
             * Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
             */
            workers?: outputs.cluster.v1beta1.ClusterClassSpecWorkers;
        }

        /**
         * ControlPlane is a reference to a local struct that holds the details for provisioning the Control Plane for the Cluster.
         */
        export interface ClusterClassSpecControlPlane {
            /**
             * MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass. This field is supported if and only if the ControlPlane provider template referenced above is Machine based and supports setting replicas.
             */
            machineHealthCheck?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMachineHealthCheck;
            /**
             * MachineInfrastructure defines the metadata and infrastructure information for control plane machines. 
             *  This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
             */
            machineInfrastructure?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMachineInfrastructure;
            /**
             * Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
             *  This field is supported if and only if the control plane provider template referenced is Machine based.
             */
            metadata?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMetadata;
            /**
             * NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
             */
            namingStrategy?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneNamingStrategy;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology.
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneRef;
        }

        /**
         * MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass. This field is supported if and only if the ControlPlane provider template referenced above is Machine based and supports setting replicas.
         */
        export interface ClusterClassSpecControlPlaneMachineHealthCheck {
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplate;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions?: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface ClusterClassSpecControlPlaneMachineHealthCheckRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface ClusterClassSpecControlPlaneMachineHealthCheckUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * MachineInfrastructure defines the metadata and infrastructure information for control plane machines. 
         *  This field is supported if and only if the control plane provider template referenced above is Machine based and supports setting replicas.
         */
        export interface ClusterClassSpecControlPlaneMachineInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1beta1.ClusterClassSpecControlPlaneMachineInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecControlPlaneMachineInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the topology. 
         *  This field is supported if and only if the control plane provider template referenced is Machine based.
         */
        export interface ClusterClassSpecControlPlaneMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
         */
        export interface ClusterClassSpecControlPlaneNamingStrategy {
            /**
             * Template defines the template to use for generating the name of the ControlPlane object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5.
             */
            template?: string;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecControlPlaneRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Infrastructure is a reference to a provider-specific template that holds the details for provisioning infrastructure specific cluster for the underlying provider. The underlying provider is responsible for the implementation of the template to an infrastructure cluster.
         */
        export interface ClusterClassSpecInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1beta1.ClusterClassSpecInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * ClusterClassPatch defines a patch which is applied to customize the referenced templates.
         */
        export interface ClusterClassSpecPatches {
            /**
             * Definitions define inline patches. Note: Patches will be applied in the order of the array. Note: Exactly one of Definitions or External must be set.
             */
            definitions?: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitions[];
            /**
             * Description is a human-readable description of this patch.
             */
            description?: string;
            /**
             * EnabledIf is a Go template to be used to calculate if a patch should be enabled. It can reference variables defined in .spec.variables and builtin variables. The patch will be enabled if the template evaluates to `true`, otherwise it will be disabled. If EnabledIf is not set, the patch will be enabled per default.
             */
            enabledIf?: string;
            /**
             * External defines an external patch. Note: Exactly one of Definitions or External must be set.
             */
            external?: outputs.cluster.v1beta1.ClusterClassSpecPatchesExternal;
            /**
             * Name of the patch.
             */
            name: string;
        }

        /**
         * PatchDefinition defines a patch which is applied to customize the referenced templates.
         */
        export interface ClusterClassSpecPatchesDefinitions {
            /**
             * JSONPatches defines the patches which should be applied on the templates matching the selector. Note: Patches will be applied in the order of the array.
             */
            jsonPatches: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitionsJsonPatches[];
            /**
             * Selector defines on which templates the patch should be applied.
             */
            selector: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitionsSelector;
        }

        /**
         * JSONPatch defines a JSON patch.
         */
        export interface ClusterClassSpecPatchesDefinitionsJsonPatches {
            /**
             * Op defines the operation of the patch. Note: Only `add`, `replace` and `remove` are supported.
             */
            op: string;
            /**
             * Path defines the path of the patch. Note: Only the spec of a template can be patched, thus the path has to start with /spec/. Note: For now the only allowed array modifications are `append` and `prepend`, i.e.: * for op: `add`: only index 0 (prepend) and - (append) are allowed * for op: `replace` or `remove`: no indexes are allowed
             */
            path: string;
            /**
             * Value defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time. Note: We have to use apiextensionsv1.JSON instead of our JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type (unset type field). Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
             */
            value?: {[key: string]: any};
            /**
             * ValueFrom defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time.
             */
            valueFrom?: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitionsJsonPatchesValueFrom;
        }

        /**
         * ValueFrom defines the value of the patch. Note: Either Value or ValueFrom is required for add and replace operations. Only one of them is allowed to be set at the same time.
         */
        export interface ClusterClassSpecPatchesDefinitionsJsonPatchesValueFrom {
            /**
             * Template is the Go template to be used to calculate the value. A template can reference variables defined in .spec.variables and builtin variables. Note: The template must evaluate to a valid YAML or JSON value.
             */
            template?: string;
            /**
             * Variable is the variable to be used as value. Variable can be one of the variables defined in .spec.variables or a builtin variable.
             */
            variable?: string;
        }

        /**
         * Selector defines on which templates the patch should be applied.
         */
        export interface ClusterClassSpecPatchesDefinitionsSelector {
            /**
             * APIVersion filters templates by apiVersion.
             */
            apiVersion: string;
            /**
             * Kind filters templates by kind.
             */
            kind: string;
            /**
             * MatchResources selects templates based on where they are referenced.
             */
            matchResources: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitionsSelectorMatchResources;
        }

        /**
         * MatchResources selects templates based on where they are referenced.
         */
        export interface ClusterClassSpecPatchesDefinitionsSelectorMatchResources {
            /**
             * ControlPlane selects templates referenced in .spec.ControlPlane. Note: this will match the controlPlane and also the controlPlane machineInfrastructure (depending on the kind and apiVersion).
             */
            controlPlane?: boolean;
            /**
             * InfrastructureCluster selects templates referenced in .spec.infrastructure.
             */
            infrastructureCluster?: boolean;
            /**
             * MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
             */
            machineDeploymentClass?: outputs.cluster.v1beta1.ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClass;
        }

        /**
         * MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
         */
        export interface ClusterClassSpecPatchesDefinitionsSelectorMatchResourcesMachineDeploymentClass {
            /**
             * Names selects templates by class names.
             */
            names?: string[];
        }

        /**
         * External defines an external patch. Note: Exactly one of Definitions or External must be set.
         */
        export interface ClusterClassSpecPatchesExternal {
            /**
             * DiscoverVariablesExtension references an extension which is called to discover variables.
             */
            discoverVariablesExtension?: string;
            /**
             * GenerateExtension references an extension which is called to generate patches.
             */
            generateExtension?: string;
            /**
             * Settings defines key value pairs to be passed to the extensions. Values defined here take precedence over the values defined in the corresponding ExtensionConfig.
             */
            settings?: {[key: string]: string};
            /**
             * ValidateExtension references an extension which is called to validate the topology.
             */
            validateExtension?: string;
        }

        /**
         * ClusterClassVariable defines a variable which can be configured in the Cluster topology and used in patches.
         */
        export interface ClusterClassSpecVariables {
            /**
             * Name of the variable.
             */
            name: string;
            /**
             * Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
             */
            required: boolean;
            /**
             * Schema defines the schema of the variable.
             */
            schema: outputs.cluster.v1beta1.ClusterClassSpecVariablesSchema;
        }

        /**
         * Schema defines the schema of the variable.
         */
        export interface ClusterClassSpecVariablesSchema {
            /**
             * OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
             */
            openAPIV3Schema: outputs.cluster.v1beta1.ClusterClassSpecVariablesSchemaOpenAPIV3Schema;
        }

        /**
         * OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
         */
        export interface ClusterClassSpecVariablesSchemaOpenAPIV3Schema {
            /**
             * AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            additionalProperties?: {[key: string]: any};
            /**
             * Default is the default value of the variable. NOTE: Can be set for all types.
             */
            default?: {[key: string]: any};
            /**
             * Description is a human-readable description of this variable.
             */
            description?: string;
            /**
             * Enum is the list of valid values of the variable. NOTE: Can be set for all types.
             */
            enum?: {[key: string]: any}[];
            /**
             * Example is an example for this variable.
             */
            example?: {[key: string]: any};
            /**
             * ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
             */
            exclusiveMaximum?: boolean;
            /**
             * ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
             */
            exclusiveMinimum?: boolean;
            /**
             * Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
             */
            format?: string;
            /**
             * Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            items?: {[key: string]: any};
            /**
             * MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
             */
            maxItems?: number;
            /**
             * MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
             */
            maxLength?: number;
            /**
             * Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
             */
            maximum?: number;
            /**
             * MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
             */
            minItems?: number;
            /**
             * MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
             */
            minLength?: number;
            /**
             * Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
             */
            minimum?: number;
            /**
             * Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
             */
            pattern?: string;
            /**
             * Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            properties?: {[key: string]: any};
            /**
             * Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
             */
            required?: string[];
            /**
             * Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
             */
            type: string;
            /**
             * UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
             */
            uniqueItems?: boolean;
            /**
             * XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
             */
            'x-kubernetes-preserve-unknown-fields'?: boolean;
        }

        /**
         * Workers describes the worker nodes for the cluster. It is a collection of node types which can be used to create the worker nodes of the cluster.
         */
        export interface ClusterClassSpecWorkers {
            /**
             * MachineDeployments is a list of machine deployment classes that can be used to create a set of worker nodes.
             */
            machineDeployments?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeployments[];
        }

        /**
         * MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster provisioned using the `ClusterClass`.
         */
        export interface ClusterClassSpecWorkersMachineDeployments {
            /**
             * Class denotes a type of worker node present in the cluster, this name MUST be unique within a ClusterClass and can be referenced in the Cluster to create a managed MachineDeployment.
             */
            class: string;
            /**
             * FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            failureDomain?: string;
            /**
             * MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
             */
            machineHealthCheck?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheck;
            /**
             * Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready) NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            minReadySeconds?: number;
            /**
             * NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
             */
            namingStrategy?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsNamingStrategy;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout` NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * The deployment strategy to use to replace existing machines with new ones. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
             */
            strategy?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsStrategy;
            /**
             * Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
             */
            template: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplate;
        }

        /**
         * MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheck {
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplate;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsNamingStrategy {
            /**
             * Template defines the template to use for generating the name of the MachineDeployment object. If not defined, it will fallback to `{{ .cluster.name }}-{{ .machineDeployment.topologyName }}-{{ .random }}`. If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will get concatenated with a random suffix of length 5. The templating mechanism provides the following arguments: * `.cluster.name`: The name of the cluster object. * `.random`: A random alphanumeric string, without vowels, of length 5. * `.machineDeployment.topologyName`: The name of the MachineDeployment topology (Cluster.spec.topology.workers.machineDeployments[].name).
             */
            template?: string;
        }

        /**
         * The deployment strategy to use to replace existing machines with new ones. NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdate;
            /**
             * Type of deployment. Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsStrategyRollingUpdate {
            /**
             * DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
             */
            deletePolicy?: string;
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Template is a local struct containing a collection of templates for creation of MachineDeployment objects representing a set of worker nodes.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplate {
            /**
             * Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
             */
            bootstrap: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap;
            /**
             * Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
             */
            infrastructure: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure;
            /**
             * Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
             */
            metadata?: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata;
        }

        /**
         * Bootstrap contains the bootstrap template reference to be used for the creation of worker Machines.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrap {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateBootstrapRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Infrastructure contains the infrastructure template reference to be used for the creation of worker Machines.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructure {
            /**
             * Ref is a required reference to a custom resource offered by a provider.
             */
            ref: outputs.cluster.v1beta1.ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef;
        }

        /**
         * Ref is a required reference to a custom resource offered by a provider.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the topology.
         */
        export interface ClusterClassSpecWorkersMachineDeploymentsTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * ClusterClassStatus defines the observed state of the ClusterClass.
         */
        export interface ClusterClassStatus {
            /**
             * Conditions defines current observed state of the ClusterClass.
             */
            conditions?: outputs.cluster.v1beta1.ClusterClassStatusConditions[];
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Variables is a list of ClusterClassStatusVariable that are defined for the ClusterClass.
             */
            variables?: outputs.cluster.v1beta1.ClusterClassStatusVariables[];
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterClassStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * ClusterClassStatusVariable defines a variable which appears in the status of a ClusterClass.
         */
        export interface ClusterClassStatusVariables {
            /**
             * Definitions is a list of definitions for a variable.
             */
            definitions: outputs.cluster.v1beta1.ClusterClassStatusVariablesDefinitions[];
            /**
             * DefinitionsConflict specifies whether or not there are conflicting definitions for a single variable name.
             */
            definitionsConflict?: boolean;
            /**
             * Name is the name of the variable.
             */
            name: string;
        }

        /**
         * ClusterClassStatusVariableDefinition defines a variable which appears in the status of a ClusterClass.
         */
        export interface ClusterClassStatusVariablesDefinitions {
            /**
             * From specifies the origin of the variable definition. This will be `inline` for variables defined in the ClusterClass or the name of a patch defined in the ClusterClass for variables discovered from a DiscoverVariables runtime extensions.
             */
            from: string;
            /**
             * Required specifies if the variable is required. Note: this applies to the variable as a whole and thus the top-level object defined in the schema. If nested fields are required, this will be specified inside the schema.
             */
            required: boolean;
            /**
             * Schema defines the schema of the variable.
             */
            schema: outputs.cluster.v1beta1.ClusterClassStatusVariablesDefinitionsSchema;
        }

        /**
         * Schema defines the schema of the variable.
         */
        export interface ClusterClassStatusVariablesDefinitionsSchema {
            /**
             * OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
             */
            openAPIV3Schema: outputs.cluster.v1beta1.ClusterClassStatusVariablesDefinitionsSchemaOpenAPIV3Schema;
        }

        /**
         * OpenAPIV3Schema defines the schema of a variable via OpenAPI v3 schema. The schema is a subset of the schema used in Kubernetes CRDs.
         */
        export interface ClusterClassStatusVariablesDefinitionsSchemaOpenAPIV3Schema {
            /**
             * AdditionalProperties specifies the schema of values in a map (keys are always strings). NOTE: Can only be set if type is object. NOTE: AdditionalProperties is mutually exclusive with Properties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            additionalProperties?: {[key: string]: any};
            /**
             * Default is the default value of the variable. NOTE: Can be set for all types.
             */
            default?: {[key: string]: any};
            /**
             * Description is a human-readable description of this variable.
             */
            description?: string;
            /**
             * Enum is the list of valid values of the variable. NOTE: Can be set for all types.
             */
            enum?: {[key: string]: any}[];
            /**
             * Example is an example for this variable.
             */
            example?: {[key: string]: any};
            /**
             * ExclusiveMaximum specifies if the Maximum is exclusive. NOTE: Can only be set if type is integer or number.
             */
            exclusiveMaximum?: boolean;
            /**
             * ExclusiveMinimum specifies if the Minimum is exclusive. NOTE: Can only be set if type is integer or number.
             */
            exclusiveMinimum?: boolean;
            /**
             * Format is an OpenAPI v3 format string. Unknown formats are ignored. For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using) https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go NOTE: Can only be set if type is string.
             */
            format?: string;
            /**
             * Items specifies fields of an array. NOTE: Can only be set if type is array. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            items?: {[key: string]: any};
            /**
             * MaxItems is the max length of an array variable. NOTE: Can only be set if type is array.
             */
            maxItems?: number;
            /**
             * MaxLength is the max length of a string variable. NOTE: Can only be set if type is string.
             */
            maxLength?: number;
            /**
             * Maximum is the maximum of an integer or number variable. If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum. If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum. NOTE: Can only be set if type is integer or number.
             */
            maximum?: number;
            /**
             * MinItems is the min length of an array variable. NOTE: Can only be set if type is array.
             */
            minItems?: number;
            /**
             * MinLength is the min length of a string variable. NOTE: Can only be set if type is string.
             */
            minLength?: number;
            /**
             * Minimum is the minimum of an integer or number variable. If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum. If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum. NOTE: Can only be set if type is integer or number.
             */
            minimum?: number;
            /**
             * Pattern is the regex which a string variable must match. NOTE: Can only be set if type is string.
             */
            pattern?: string;
            /**
             * Properties specifies fields of an object. NOTE: Can only be set if type is object. NOTE: Properties is mutually exclusive with AdditionalProperties. NOTE: This field uses PreserveUnknownFields and Schemaless, because recursive validation is not possible.
             */
            properties?: {[key: string]: any};
            /**
             * Required specifies which fields of an object are required. NOTE: Can only be set if type is object.
             */
            required?: string[];
            /**
             * Type is the type of the variable. Valid values are: object, array, string, integer, number or boolean.
             */
            type: string;
            /**
             * UniqueItems specifies if items in an array must be unique. NOTE: Can only be set if type is array.
             */
            uniqueItems?: boolean;
            /**
             * XPreserveUnknownFields allows setting fields in a variable object which are not defined in the variable schema. This affects fields recursively, except if nested properties or additionalProperties are specified in the schema.
             */
            'x-kubernetes-preserve-unknown-fields'?: boolean;
        }

        /**
         * ClusterSpec defines the desired state of Cluster.
         */
        export interface ClusterSpec {
            /**
             * Cluster network configuration.
             */
            clusterNetwork?: outputs.cluster.v1beta1.ClusterSpecClusterNetwork;
            /**
             * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
             */
            controlPlaneEndpoint?: outputs.cluster.v1beta1.ClusterSpecControlPlaneEndpoint;
            /**
             * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
             */
            controlPlaneRef?: outputs.cluster.v1beta1.ClusterSpecControlPlaneRef;
            /**
             * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
             */
            infrastructureRef?: outputs.cluster.v1beta1.ClusterSpecInfrastructureRef;
            /**
             * Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
             */
            paused?: boolean;
            /**
             * This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
             */
            topology?: outputs.cluster.v1beta1.ClusterSpecTopology;
        }

        /**
         * Cluster network configuration.
         */
        export interface ClusterSpecClusterNetwork {
            /**
             * APIServerPort specifies the port the API Server should bind to. Defaults to 6443.
             */
            apiServerPort?: number;
            /**
             * The network ranges from which Pod networks are allocated.
             */
            pods?: outputs.cluster.v1beta1.ClusterSpecClusterNetworkPods;
            /**
             * Domain name for services.
             */
            serviceDomain?: string;
            /**
             * The network ranges from which service VIPs are allocated.
             */
            services?: outputs.cluster.v1beta1.ClusterSpecClusterNetworkServices;
        }

        /**
         * The network ranges from which Pod networks are allocated.
         */
        export interface ClusterSpecClusterNetworkPods {
            cidrBlocks: string[];
        }

        /**
         * The network ranges from which service VIPs are allocated.
         */
        export interface ClusterSpecClusterNetworkServices {
            cidrBlocks: string[];
        }

        /**
         * ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
         */
        export interface ClusterSpecControlPlaneEndpoint {
            /**
             * The hostname on which the API server is serving.
             */
            host: string;
            /**
             * The port on which the API server is serving.
             */
            port: number;
        }

        /**
         * ControlPlaneRef is an optional reference to a provider-specific resource that holds the details for provisioning the Control Plane for a Cluster.
         */
        export interface ClusterSpecControlPlaneRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a reference to a provider-specific resource that holds the details for provisioning infrastructure for a cluster in said provider.
         */
        export interface ClusterSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * This encapsulates the topology for the cluster. NOTE: It is required to enable the ClusterTopology feature gate flag to activate managed topologies support; this feature is highly experimental, and parts of it might still be not implemented.
         */
        export interface ClusterSpecTopology {
            /**
             * The name of the ClusterClass object to create the topology.
             */
            class: string;
            /**
             * ControlPlane describes the cluster control plane.
             */
            controlPlane?: outputs.cluster.v1beta1.ClusterSpecTopologyControlPlane;
            /**
             * RolloutAfter performs a rollout of the entire cluster one component at a time, control plane first and then machine deployments. 
             *  Deprecated: This field has no function and is going to be removed in the next apiVersion.
             */
            rolloutAfter?: string;
            /**
             * Variables can be used to customize the Cluster through patches. They must comply to the corresponding VariableClasses defined in the ClusterClass.
             */
            variables?: outputs.cluster.v1beta1.ClusterSpecTopologyVariables[];
            /**
             * The Kubernetes version of the cluster.
             */
            version: string;
            /**
             * Workers encapsulates the different constructs that form the worker nodes for the cluster.
             */
            workers?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkers;
        }

        /**
         * ControlPlane describes the cluster control plane.
         */
        export interface ClusterSpecTopologyControlPlane {
            /**
             * MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this control plane.
             */
            machineHealthCheck?: outputs.cluster.v1beta1.ClusterSpecTopologyControlPlaneMachineHealthCheck;
            /**
             * Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
             */
            metadata?: outputs.cluster.v1beta1.ClusterSpecTopologyControlPlaneMetadata;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * Replicas is the number of control plane nodes. If the value is nil, the ControlPlane object is created without the number of Replicas and it's assumed that the control plane controller does not implement support for this field. When specified against a control plane provider that lacks support for this field, this value will be ignored.
             */
            replicas?: number;
        }

        /**
         * MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this control plane.
         */
        export interface ClusterSpecTopologyControlPlaneMachineHealthCheck {
            /**
             * Enable controls if a MachineHealthCheck should be created for the target machines. 
             *  If false: No MachineHealthCheck will be created. 
             *  If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
             *  If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
             */
            enable?: boolean;
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1beta1.ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplate;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions?: outputs.cluster.v1beta1.ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface ClusterSpecTopologyControlPlaneMachineHealthCheckRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface ClusterSpecTopologyControlPlaneMachineHealthCheckUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it is applied only to the ControlPlane. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
         */
        export interface ClusterSpecTopologyControlPlaneMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a Variable definition in the ClusterClass `status` variables.
         */
        export interface ClusterSpecTopologyVariables {
            /**
             * DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
             */
            definitionFrom?: string;
            /**
             * Name of the variable.
             */
            name: string;
            /**
             * Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
             */
            value: {[key: string]: any};
        }

        /**
         * Workers encapsulates the different constructs that form the worker nodes for the cluster.
         */
        export interface ClusterSpecTopologyWorkers {
            /**
             * MachineDeployments is a list of machine deployments in the cluster.
             */
            machineDeployments?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeployments[];
        }

        /**
         * MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology. This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
         */
        export interface ClusterSpecTopologyWorkersMachineDeployments {
            /**
             * Class is the name of the MachineDeploymentClass used to create the set of worker nodes. This should match one of the deployment classes defined in the ClusterClass object mentioned in the `Cluster.Spec.Class` field.
             */
            class: string;
            /**
             * FailureDomain is the failure domain the machines will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
             */
            machineHealthCheck?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheck;
            /**
             * Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
             */
            metadata?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsMetadata;
            /**
             * Minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)
             */
            minReadySeconds?: number;
            /**
             * Name is the unique identifier for this MachineDeploymentTopology. The value is used with other unique identifiers to create a MachineDeployment's Name (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length, the values are hashed together.
             */
            name: string;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * Replicas is the number of worker nodes belonging to this set. If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1) and it's assumed that an external entity (like cluster autoscaler) is responsible for the management of this value.
             */
            replicas?: number;
            /**
             * The deployment strategy to use to replace existing machines with new ones.
             */
            strategy?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsStrategy;
            /**
             * Variables can be used to customize the MachineDeployment through patches.
             */
            variables?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsVariables;
        }

        /**
         * MachineHealthCheck allows to enable, disable and override the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheck {
            /**
             * Enable controls if a MachineHealthCheck should be created for the target machines. 
             *  If false: No MachineHealthCheck will be created. 
             *  If not set(default): A MachineHealthCheck will be created if it is defined here or in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created. 
             *  If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will block if `enable` is true and no MachineHealthCheck definition is available.
             */
            enable?: boolean;
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplate;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy. The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment. At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * The deployment strategy to use to replace existing machines with new ones.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdate;
            /**
             * Type of deployment. Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsStrategyRollingUpdate {
            /**
             * DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
             */
            deletePolicy?: string;
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Variables can be used to customize the MachineDeployment through patches.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsVariables {
            /**
             * Overrides can be used to override Cluster level variables.
             */
            overrides?: outputs.cluster.v1beta1.ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverrides[];
        }

        /**
         * ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a Variable definition in the ClusterClass `status` variables.
         */
        export interface ClusterSpecTopologyWorkersMachineDeploymentsVariablesOverrides {
            /**
             * DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass `.spec.patches` where the patch is external and provides external variables. This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
             */
            definitionFrom?: string;
            /**
             * Name of the variable.
             */
            name: string;
            /**
             * Value of the variable. Note: the value will be validated against the schema of the corresponding ClusterClassVariable from the ClusterClass. Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools, i.e. it is not possible to have no type field. Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
             */
            value: {[key: string]: any};
        }

        /**
         * ClusterStatus defines the observed state of Cluster.
         */
        export interface ClusterStatus {
            /**
             * Conditions defines current service state of the cluster.
             */
            conditions?: outputs.cluster.v1beta1.ClusterStatusConditions[];
            /**
             * ControlPlaneReady defines if the control plane is ready.
             */
            controlPlaneReady?: boolean;
            /**
             * FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
             */
            failureDomains?: {[key: string]: outputs.cluster.v1beta1.ClusterStatusFailureDomains};
            /**
             * FailureMessage indicates that there is a fatal problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a fatal problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ClusterStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * FailureDomainSpec is the Schema for Cluster API failure domains. It allows controllers to understand how many failure domains a cluster can optionally span across.
         */
        export interface ClusterStatusFailureDomains {
            /**
             * Attributes is a free form map of attributes an infrastructure provider might use or require.
             */
            attributes?: {[key: string]: string};
            /**
             * ControlPlane determines if this failure domain is suitable for use by control plane machines.
             */
            controlPlane?: boolean;
        }

        /**
         * MachineDeploymentSpec defines the desired state of MachineDeployment.
         */
        export interface MachineDeploymentSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
             */
            minReadySeconds?: number;
            /**
             * Indicates that the deployment is paused.
             */
            paused?: boolean;
            /**
             * The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
             */
            progressDeadlineSeconds?: number;
            /**
             * Number of desired machines. This is a pointer to distinguish between explicit zero and not specified. 
             *  Defaults to: * if the Kubernetes autoscaler min size and max size annotations are set: - if it's a new MachineDeployment, use min size - if the replicas field of the old MachineDeployment is < min size, use min size - if the replicas field of the old MachineDeployment is > max size, use max size - if the replicas field of the old MachineDeployment is in the (min size, max size) range, keep the value from the oldMD * otherwise use 1 Note: Defaulting will be run whenever the replicas field is not set: * A new MachineDeployment is created with replicas not set. * On an existing MachineDeployment the replicas field was first set and is now unset. Those cases are especially relevant for the following Kubernetes autoscaler use cases: * A new MachineDeployment is created and replicas should be managed by the autoscaler * An existing MachineDeployment which initially wasn't controlled by the autoscaler should be later controlled by the autoscaler
             */
            replicas?: number;
            /**
             * The number of old MachineSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
             */
            revisionHistoryLimit?: number;
            /**
             * RolloutAfter is a field to indicate a rollout should be performed after the specified time even if no changes have been made to the MachineDeployment. Example: In the YAML the time can be specified in the RFC3339 format. To specify the rolloutAfter target as March 9, 2023, at 9 am UTC use "2023-03-09T09:00:00Z".
             */
            rolloutAfter?: string;
            /**
             * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
             */
            selector: outputs.cluster.v1beta1.MachineDeploymentSpecSelector;
            /**
             * The deployment strategy to use to replace existing machines with new ones.
             */
            strategy?: outputs.cluster.v1beta1.MachineDeploymentSpecStrategy;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1beta1.MachineDeploymentSpecTemplate;
        }

        /**
         * Label selector for machines. Existing MachineSets whose machines are selected by this will be the ones affected by this deployment. It must match the machine template's labels.
         */
        export interface MachineDeploymentSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1beta1.MachineDeploymentSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineDeploymentSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * The deployment strategy to use to replace existing machines with new ones.
         */
        export interface MachineDeploymentSpecStrategy {
            /**
             * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
             */
            rollingUpdate?: outputs.cluster.v1beta1.MachineDeploymentSpecStrategyRollingUpdate;
            /**
             * Type of deployment. Default is RollingUpdate.
             */
            type?: string;
        }

        /**
         * Rolling update config params. Present only if MachineDeploymentStrategyType = RollingUpdate.
         */
        export interface MachineDeploymentSpecStrategyRollingUpdate {
            /**
             * DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling. Valid values are "Random, "Newest", "Oldest" When no value is supplied, the default DeletePolicy of MachineSet is used
             */
            deletePolicy?: string;
            /**
             * The maximum number of machines that can be scheduled above the desired number of machines. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 1. Example: when this is set to 30%, the new MachineSet can be scaled up immediately when the rolling update starts, such that the total number of old and new machines do not exceed 130% of desired machines. Once old machines have been killed, new MachineSet can be scaled up further, ensuring that total number of machines running at any time during the update is at most 130% of desired machines.
             */
            maxSurge?: number | string;
            /**
             * The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 0. Example: when this is set to 30%, the old MachineSet can be scaled down to 70% of desired machines immediately when the rolling update starts. Once new machines are ready, old MachineSet can be scaled down further, followed by scaling up the new MachineSet, ensuring that the total number of machines available at all times during the update is at least 70% of desired machines.
             */
            maxUnavailable?: number | string;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachineDeploymentSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1beta1.MachineDeploymentSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1beta1.MachineDeploymentSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineDeploymentSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineDeploymentSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1beta1.MachineDeploymentSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1beta1.MachineDeploymentSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1beta1.MachineDeploymentSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineDeploymentSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineDeploymentSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineDeploymentStatus defines the observed state of MachineDeployment.
         */
        export interface MachineDeploymentStatus {
            /**
             * Total number of available machines (ready for at least minReadySeconds) targeted by this deployment.
             */
            availableReplicas?: number;
            /**
             * Conditions defines current service state of the MachineDeployment.
             */
            conditions?: outputs.cluster.v1beta1.MachineDeploymentStatusConditions[];
            /**
             * The generation observed by the deployment controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
             */
            phase?: string;
            /**
             * Total number of ready machines targeted by this deployment.
             */
            readyReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment (their labels match the selector).
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
            /**
             * Total number of unavailable machines targeted by this deployment. This is the total number of machines that are still required for the deployment to have 100% available capacity. They may either be machines that are running but not yet available or machines that still have not been created.
             */
            unavailableReplicas?: number;
            /**
             * Total number of non-terminated machines targeted by this deployment that have the desired template spec.
             */
            updatedReplicas?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineDeploymentStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * Specification of machine health check policy
         */
        export interface MachineHealthCheckSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by "selector" are not healthy.
             */
            maxUnhealthy?: number | string;
            /**
             * Machines older than this duration without a node will be considered to have failed and will be remediated. If not set, this value is defaulted to 10 minutes. If you wish to disable this feature, set the value explicitly to 0.
             */
            nodeStartupTimeout?: string;
            /**
             * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
             *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
             */
            remediationTemplate?: outputs.cluster.v1beta1.MachineHealthCheckSpecRemediationTemplate;
            /**
             * Label selector to match machines whose health will be exercised
             */
            selector: outputs.cluster.v1beta1.MachineHealthCheckSpecSelector;
            /**
             * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy.  The conditions are combined in a logical OR, i.e. if any of the conditions is met, the node is unhealthy.
             */
            unhealthyConditions: outputs.cluster.v1beta1.MachineHealthCheckSpecUnhealthyConditions[];
            /**
             * Any further remediation is only allowed if the number of machines selected by "selector" as not healthy is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy. Eg. "[3-5]" - This means that remediation will be allowed only when: (a) there are at least 3 unhealthy machines (and) (b) there are at most 5 unhealthy machines
             */
            unhealthyRange?: string;
        }

        /**
         * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider. 
         *  This field is completely optional, when filled, the MachineHealthCheck controller creates a new object from the template referenced and hands off remediation of the machine to a controller that lives outside of Cluster API.
         */
        export interface MachineHealthCheckSpecRemediationTemplate {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Label selector to match machines whose health will be exercised
         */
        export interface MachineHealthCheckSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1beta1.MachineHealthCheckSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineHealthCheckSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * UnhealthyCondition represents a Node condition type and value with a timeout specified as a duration.  When the named condition has been in the given status for at least the timeout value, a node is considered unhealthy.
         */
        export interface MachineHealthCheckSpecUnhealthyConditions {
            status: string;
            timeout: string;
            type: string;
        }

        /**
         * Most recently observed status of MachineHealthCheck resource
         */
        export interface MachineHealthCheckStatus {
            /**
             * Conditions defines current service state of the MachineHealthCheck.
             */
            conditions?: outputs.cluster.v1beta1.MachineHealthCheckStatusConditions[];
            /**
             * total number of healthy machines counted by this machine health check
             */
            currentHealthy?: number;
            /**
             * total number of machines counted by this machine health check
             */
            expectedMachines?: number;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * RemediationsAllowed is the number of further remediations allowed by this machine health check before maxUnhealthy short circuiting will be applied
             */
            remediationsAllowed?: number;
            /**
             * Targets shows the current list of machines the machine health check is watching
             */
            targets?: string[];
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineHealthCheckStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * MachinePoolSpec defines the desired state of MachinePool.
         */
        export interface MachinePoolSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomains is the list of failure domains this MachinePool should be attached to.
             */
            failureDomains?: string[];
            /**
             * Minimum number of seconds for which a newly created machine instances should be ready. Defaults to 0 (machine instance will be considered available as soon as it is ready) NOTE: No logic is implemented for this field and it currently has no behaviour.
             */
            minReadySeconds?: number;
            /**
             * ProviderIDList are the identification IDs of machine instances provided by the provider. This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
             */
            providerIDList?: string[];
            /**
             * Number of desired machines. Defaults to 1. This is a pointer to distinguish between explicit zero and not specified.
             */
            replicas?: number;
            /**
             * Template describes the machines that will be created.
             */
            template: outputs.cluster.v1beta1.MachinePoolSpecTemplate;
        }

        /**
         * Template describes the machines that will be created.
         */
        export interface MachinePoolSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1beta1.MachinePoolSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1beta1.MachinePoolSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachinePoolSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachinePoolSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1beta1.MachinePoolSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1beta1.MachinePoolSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachinePoolSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1beta1.MachinePoolSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachinePoolSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachinePoolSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachinePoolStatus defines the observed state of MachinePool.
         */
        export interface MachinePoolStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachinePool.
             */
            availableReplicas?: number;
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * Conditions define the current service state of the MachinePool.
             */
            conditions?: outputs.cluster.v1beta1.MachinePoolStatusConditions[];
            /**
             * FailureMessage indicates that there is a problem reconciling the state, and will be set to a descriptive error message.
             */
            failureMessage?: string;
            /**
             * FailureReason indicates that there is a problem reconciling the state, and will be set to a token value suitable for programmatic interpretation.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * NodeRefs will point to the corresponding Nodes if it they exist.
             */
            nodeRefs?: outputs.cluster.v1beta1.MachinePoolStatusNodeRefs[];
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of cluster actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
            /**
             * The number of ready replicas for this MachinePool. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Total number of unavailable machine instances targeted by this machine pool. This is the total number of machine instances that are still required for the machine pool to have 100% available capacity. They may either be machine instances that are running but not yet available or machine instances that still have not been created.
             */
            unavailableReplicas?: number;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachinePoolStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs. 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage. 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted". Those cannot be well described when embedded. 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen. 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple and the version of the actual struct is irrelevant. 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. 
         *  Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
         */
        export interface MachinePoolStatusNodeRefs {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetSpec defines the desired state of MachineSet.
         */
        export interface MachineSetSpec {
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to "Random".  Valid values are "Random, "Newest", "Oldest"
             */
            deletePolicy?: string;
            /**
             * MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available. Defaults to 0 (machine will be considered available as soon as the Node is ready)
             */
            minReadySeconds?: number;
            /**
             * Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.
             */
            replicas?: number;
            /**
             * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
             */
            selector: outputs.cluster.v1beta1.MachineSetSpecSelector;
            /**
             * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
             */
            template?: outputs.cluster.v1beta1.MachineSetSpecTemplate;
        }
        /**
         * machineSetSpecProvideDefaults sets the appropriate defaults for MachineSetSpec
         */
        export function machineSetSpecProvideDefaults(val: MachineSetSpec): MachineSetSpec {
            return {
                ...val,
                replicas: (val.replicas) ?? 1,
            };
        }

        /**
         * Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
         */
        export interface MachineSetSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.cluster.v1beta1.MachineSetSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineSetSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * Template is the object that describes the machine that will be created if insufficient replicas are detected. Object references to custom resources are treated as templates.
         */
        export interface MachineSetSpecTemplate {
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: outputs.cluster.v1beta1.MachineSetSpecTemplateMetadata;
            /**
             * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
             */
            spec?: outputs.cluster.v1beta1.MachineSetSpecTemplateSpec;
        }

        /**
         * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
         */
        export interface MachineSetSpecTemplateMetadata {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
             */
            annotations?: {[key: string]: string};
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
             */
            labels?: {[key: string]: string};
        }

        /**
         * Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface MachineSetSpecTemplateSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1beta1.MachineSetSpecTemplateSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1beta1.MachineSetSpecTemplateSpecInfrastructureRef;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSetSpecTemplateSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1beta1.MachineSetSpecTemplateSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineSetSpecTemplateSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSetSpecTemplateSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineSetStatus defines the observed state of MachineSet.
         */
        export interface MachineSetStatus {
            /**
             * The number of available replicas (ready for at least minReadySeconds) for this MachineSet.
             */
            availableReplicas?: number;
            /**
             * Conditions defines current service state of the MachineSet.
             */
            conditions?: outputs.cluster.v1beta1.MachineSetStatusConditions[];
            failureMessage?: string;
            /**
             * In the event that there is a terminal problem reconciling the replicas, both FailureReason and FailureMessage will be set. FailureReason will be populated with a succinct value suitable for machine interpretation, while FailureMessage will contain a more verbose string suitable for logging and human consumption. 
             *  These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * The number of replicas that have labels matching the labels of the machine template of the MachineSet.
             */
            fullyLabeledReplicas?: number;
            /**
             * ObservedGeneration reflects the generation of the most recently observed MachineSet.
             */
            observedGeneration?: number;
            /**
             * The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is "Ready".
             */
            readyReplicas?: number;
            /**
             * Replicas is the most recently observed number of replicas.
             */
            replicas?: number;
            /**
             * Selector is the same as the label selector but in the string format to avoid introspection by clients. The string will be in the same format as the query-param syntax. More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
             */
            selector?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineSetStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * MachineSpec defines the desired state of Machine.
         */
        export interface MachineSpec {
            /**
             * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
             */
            bootstrap: outputs.cluster.v1beta1.MachineSpecBootstrap;
            /**
             * ClusterName is the name of the Cluster this object belongs to.
             */
            clusterName: string;
            /**
             * FailureDomain is the failure domain the machine will be created in. Must match a key in the FailureDomains map stored on the cluster object.
             */
            failureDomain?: string;
            /**
             * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
             */
            infrastructureRef: outputs.cluster.v1beta1.MachineSpecInfrastructureRef;
            /**
             * NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely. Defaults to 10 seconds.
             */
            nodeDeletionTimeout?: string;
            /**
             * NodeDrainTimeout is the total amount of time that the controller will spend on draining a node. The default value is 0, meaning that the node can be drained without any time limitations. NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
             */
            nodeDrainTimeout?: string;
            /**
             * NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
             */
            nodeVolumeDetachTimeout?: string;
            /**
             * ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.
             */
            providerID?: string;
            /**
             * Version defines the desired Kubernetes version. This field is meant to be optionally used by bootstrap providers.
             */
            version?: string;
        }

        /**
         * Bootstrap is a reference to a local struct which encapsulates fields to configure the Machine’s bootstrapping mechanism.
         */
        export interface MachineSpecBootstrap {
            /**
             * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
             */
            configRef?: outputs.cluster.v1beta1.MachineSpecBootstrapConfigRef;
            /**
             * DataSecretName is the name of the secret that stores the bootstrap data script. If nil, the Machine should remain in the Pending state.
             */
            dataSecretName?: string;
        }

        /**
         * ConfigRef is a reference to a bootstrap provider-specific resource that holds configuration details. The reference is optional to allow users/operators to specify Bootstrap.DataSecretName without the need of a controller.
         */
        export interface MachineSpecBootstrapConfigRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * InfrastructureRef is a required reference to a custom resource offered by an infrastructure provider.
         */
        export interface MachineSpecInfrastructureRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * MachineStatus defines the observed state of Machine.
         */
        export interface MachineStatus {
            /**
             * Addresses is a list of addresses assigned to the machine. This field is copied from the infrastructure provider reference.
             */
            addresses?: outputs.cluster.v1beta1.MachineStatusAddresses[];
            /**
             * BootstrapReady is the state of the bootstrap provider.
             */
            bootstrapReady?: boolean;
            /**
             * CertificatesExpiryDate is the expiry date of the machine certificates. This value is only set for control plane machines.
             */
            certificatesExpiryDate?: string;
            /**
             * Conditions defines current service state of the Machine.
             */
            conditions?: outputs.cluster.v1beta1.MachineStatusConditions[];
            /**
             * FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureMessage?: string;
            /**
             * FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation. 
             *  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured. 
             *  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.
             */
            failureReason?: string;
            /**
             * InfrastructureReady is the state of the infrastructure provider.
             */
            infrastructureReady?: boolean;
            /**
             * LastUpdated identifies when the phase of the Machine last transitioned.
             */
            lastUpdated?: string;
            /**
             * NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
             */
            nodeInfo?: outputs.cluster.v1beta1.MachineStatusNodeInfo;
            /**
             * NodeRef will point to the corresponding Node if it exists.
             */
            nodeRef?: outputs.cluster.v1beta1.MachineStatusNodeRef;
            /**
             * ObservedGeneration is the latest generation observed by the controller.
             */
            observedGeneration?: number;
            /**
             * Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.
             */
            phase?: string;
        }

        /**
         * MachineAddress contains information for the node's address.
         */
        export interface MachineStatusAddresses {
            /**
             * The machine address.
             */
            address: string;
            /**
             * Machine address type, one of Hostname, ExternalIP, InternalIP, ExternalDNS or InternalDNS.
             */
            type: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface MachineStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * NodeInfo is a set of ids/uuids to uniquely identify the node. More info: https://kubernetes.io/docs/concepts/nodes/node/#info
         */
        export interface MachineStatusNodeInfo {
            /**
             * The Architecture reported by the node
             */
            architecture: string;
            /**
             * Boot ID reported by the node.
             */
            bootID: string;
            /**
             * ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
             */
            containerRuntimeVersion: string;
            /**
             * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
             */
            kernelVersion: string;
            /**
             * KubeProxy Version reported by the node.
             */
            kubeProxyVersion: string;
            /**
             * Kubelet Version reported by the node.
             */
            kubeletVersion: string;
            /**
             * MachineID reported by the node. For unique machine identification in the cluster this field is preferred. Learn more from man(5) machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
             */
            machineID: string;
            /**
             * The Operating System reported by the node
             */
            operatingSystem: string;
            /**
             * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
             */
            osImage: string;
            /**
             * SystemUUID reported by the node. For unique machine identification MachineID is preferred. This field is specific to Red Hat hosts https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
             */
            systemUUID: string;
        }

        /**
         * NodeRef will point to the corresponding Node if it exists.
         */
        export interface MachineStatusNodeRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

    }
}

export namespace gateway {
    export namespace v1alpha2 {
        /**
         * Spec defines the desired state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicySpec {
            /**
             * TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy. 
             *  Support: Extended for Kubernetes Service 
             *  Support: Implementation-specific for any other resource
             */
            targetRef: outputs.gateway.v1alpha2.BackendTLSPolicySpecTargetRef;
            /**
             * TLS contains backend TLS policy configuration.
             */
            tls: outputs.gateway.v1alpha2.BackendTLSPolicySpecTls;
        }

        /**
         * TargetRef identifies an API object to apply the policy to. Only Services have Extended support. Implementations MAY support additional objects, with Implementation Specific support. Note that this config applies to the entire referenced resource by default, but this default may change in the future to provide a more granular application of the policy. 
         *  Support: Extended for Kubernetes Service 
         *  Support: Implementation-specific for any other resource
         */
        export interface BackendTLSPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group: string;
            /**
             * Kind is kind of the target resource.
             */
            kind: string;
            /**
             * Name is the name of the target resource.
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, the local namespace is inferred. Even when policy targets a resource in a different namespace, it MUST only apply to traffic originating from the same namespace as the policy.
             */
            namespace?: string;
            /**
             * SectionName is the name of a section within the target resource. When unspecified, this targetRef targets the entire resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name * Service: Port Name 
             *  If a SectionName is specified, but does not exist on the targeted object, the Policy must fail to attach, and the policy implementation should record a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: string;
        }

        /**
         * TLS contains backend TLS policy configuration.
         */
        export interface BackendTLSPolicySpecTls {
            /**
             * CACertRefs contains one or more references to Kubernetes objects that contain a PEM-encoded TLS CA certificate bundle, which is used to validate a TLS handshake between the Gateway and backend Pod. 
             *  If CACertRefs is empty or unspecified, then WellKnownCACerts must be specified. Only one of CACertRefs or WellKnownCACerts may be specified, not both. If CACertRefs is empty or unspecified, the configuration for WellKnownCACerts MUST be honored instead. 
             *  References to a resource in a different namespace are invalid for the moment, although we will revisit this in the future. 
             *  A single CACertRef to a Kubernetes ConfigMap kind has "Core" support. Implementations MAY choose to support attaching multiple certificates to a backend, but this behavior is implementation-specific. 
             *  Support: Core - An optional single reference to a Kubernetes ConfigMap, with the CA certificate in a key named `ca.crt`. 
             *  Support: Implementation-specific (More than one reference, or other kinds of resources).
             */
            caCertRefs?: outputs.gateway.v1alpha2.BackendTLSPolicySpecTlsCaCertRefs[];
            /**
             * Hostname is used for two purposes in the connection between Gateways and backends: 
             *  1. Hostname MUST be used as the SNI to connect to the backend (RFC 6066). 2. Hostname MUST be used for authentication and MUST match the certificate served by the matching backend. 
             *  Support: Core
             */
            hostname: string;
            /**
             * WellKnownCACerts specifies whether system CA certificates may be used in the TLS handshake between the gateway and backend pod. 
             *  If WellKnownCACerts is unspecified or empty (""), then CACertRefs must be specified with at least one entry for a valid configuration. Only one of CACertRefs or WellKnownCACerts may be specified, not both. 
             *  Support: Core for "System"
             */
            wellKnownCACerts?: string;
        }

        /**
         * LocalObjectReference identifies an API object within the namespace of the referrer. The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid. 
         *  References to objects with invalid Group and Kind are not valid, and must be rejected by the implementation, with appropriate Conditions set on the containing object.
         */
        export interface BackendTLSPolicySpecTlsCaCertRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * Status defines the current state of BackendTLSPolicy.
         */
        export interface BackendTLSPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are associated with the policy, and the status of the policy with respect to each ancestor. When this policy attaches to a parent, the controller that manages the parent and the ancestors MUST add an entry to this list when the controller first sees the policy and SHOULD update the entry as appropriate when the relevant ancestor is modified. 
             *  Note that choosing the relevant ancestor is left to the Policy designers; an important part of Policy design is designing the right object level at which to namespace this status. 
             *  Note also that implementations MUST ONLY populate ancestor status for the Ancestor resources they are responsible for. Implementations MUST use the ControllerName field to uniquely identify the entries in this list that they are responsible for. 
             *  Note that to achieve this, the list of PolicyAncestorStatus structs MUST be treated as a map with a composite key, made up of the AncestorRef and ControllerName fields combined. 
             *  A maximum of 16 ancestors will be represented in this list. An empty list means the Policy is not relevant for any ancestors. 
             *  If this slice is full, implementations MUST NOT add further entries. Instead they MUST consider the policy unimplementable and signal that on any related resources such as the ancestor that would be referenced here. For example, if this list was full on BackendTLSPolicy, no additional Gateways would be able to reference the Service targeted by the BackendTLSPolicy.
             */
            ancestors: outputs.gateway.v1alpha2.BackendTLSPolicyStatusAncestors[];
        }

        /**
         * PolicyAncestorStatus describes the status of a route with respect to an associated Ancestor. 
         *  Ancestors refer to objects that are either the Target of a policy or above it in terms of object hierarchy. For example, if a policy targets a Service, the Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most useful object to place Policy status on, so we recommend that implementations SHOULD use Gateway as the PolicyAncestorStatus object unless the designers have a _very_ good reason otherwise. 
         *  In the context of policy attachment, the Ancestor is used to distinguish which resource results in a distinct application of this policy. For example, if a policy targets a Service, it may have a distinct result per attached Gateway. 
         *  Policies targeting the same resource may have different effects depending on the ancestors of those resources. For example, different Gateways targeting the same Service may have different capabilities, especially if they have different underlying implementations. 
         *  For example, in BackendTLSPolicy, the Policy attaches to a Service that is used as a backend in a HTTPRoute that is itself attached to a Gateway. In this case, the relevant object for status is the Gateway, and that is the ancestor object referred to in this status. 
         *  Note that a parent is also an ancestor, so for objects where the parent is the relevant object for status, this struct SHOULD still be used. 
         *  This struct is intended to be used in a slice that's effectively a map, with a composite key made up of the AncestorRef and the ControllerName.
         */
        export interface BackendTLSPolicyStatusAncestors {
            /**
             * AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
             */
            ancestorRef: outputs.gateway.v1alpha2.BackendTLSPolicyStatusAncestorsAncestorRef;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: outputs.gateway.v1alpha2.BackendTLSPolicyStatusAncestorsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass. 
             *  Example: "example.net/gateway-controller". 
             *  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). 
             *  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
             */
            controllerName: string;
        }
        /**
         * backendTLSPolicyStatusAncestorsProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestors
         */
        export function backendTLSPolicyStatusAncestorsProvideDefaults(val: BackendTLSPolicyStatusAncestors): BackendTLSPolicyStatusAncestors {
            return {
                ...val,
                ancestorRef: outputs.gateway.v1alpha2.backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults(val.ancestorRef),
            };
        }

        /**
         * AncestorRef corresponds with a ParentRef in the spec that this PolicyAncestorStatus struct describes the status of.
         */
        export interface BackendTLSPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults sets the appropriate defaults for BackendTLSPolicyStatusAncestorsAncestorRef
         */
        export function backendTLSPolicyStatusAncestorsAncestorRefProvideDefaults(val: BackendTLSPolicyStatusAncestorsAncestorRef): BackendTLSPolicyStatusAncestorsAncestorRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
         *  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         *  // other fields }
         */
        export interface BackendTLSPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition. This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * Spec defines the desired state of GRPCRoute.
         */
        export interface GRPCRouteSpec {
            /**
             * Hostnames defines a set of hostnames to match against the GRPC Host header to select a GRPCRoute to process the request. This matches the RFC 1123 definition of a hostname with 2 notable exceptions: 
             *  1. IPs are not allowed. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label MUST appear by itself as the first label. 
             *  If a hostname is specified by both the Listener and GRPCRoute, there MUST be at least one intersecting hostname for the GRPCRoute to be attached to the Listener. For example: 
             *  * A Listener with `test.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches GRPCRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match. 
             *  Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`. 
             *  If both the Listener and GRPCRoute have specified hostnames, any GRPCRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the GRPCRoute specified `test.example.com` and `test.example.net`, `test.example.net` MUST NOT be considered for a match. 
             *  If both the Listener and GRPCRoute have specified hostnames, and none match with the criteria above, then the GRPCRoute MUST NOT be accepted by the implementation. The implementation MUST raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus. 
             *  If a Route (A) of type HTTPRoute or GRPCRoute is attached to a Listener and that listener already has another Route (B) of the other type attached and the intersection of the hostnames of A and B is non-empty, then the implementation MUST accept exactly one of these two routes, determined by the following criteria, in order: 
             *  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}". 
             *  The rejected Route MUST raise an 'Accepted' condition with a status of 'False' in the corresponding RouteParentStatus. 
             *  Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources. 
             *  ParentRefs must be _distinct_. This means either that: 
             *  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination. 
             *  Some examples: 
             *  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`. 
             *  It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged. 
             *  Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  
             */
            parentRefs?: outputs.gateway.v1alpha2.GRPCRouteSpecParentRefs[];
            /**
             * Rules are a list of GRPC matchers, filters and actions.
             */
            rules?: outputs.gateway.v1alpha2.GRPCRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support: 
         *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
         *  This API may be extended in the future to support additional kinds of parent resources. 
         *  The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
         */
        export interface GRPCRouteSpecParentRefs {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteSpecParentRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecParentRefs
         */
        export function grpcrouteSpecParentRefsProvideDefaults(val: GRPCRouteSpecParentRefs): GRPCRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * GRPCRouteRule defines the semantics for matching a gRPC request based on conditions (matches), processing it (filters), and forwarding the request to an API object (backendRefs).
         */
        export interface GRPCRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be sent. 
             *  Failure behavior here depends on how many BackendRefs are specified and how many are invalid. 
             *  If *all* entries in BackendRefs are invalid, and there are also no filters specified in this route rule, *all* traffic which matches this rule MUST receive an `UNAVAILABLE` status. 
             *  See the GRPCBackendRef definition for the rules about what makes a single GRPCBackendRef invalid. 
             *  When a GRPCBackendRef is invalid, `UNAVAILABLE` statuses MUST be returned for requests that would have otherwise been routed to an invalid backend. If multiple backends are specified, and some are invalid, the proportion of requests that would otherwise have been routed to an invalid backend MUST receive an `UNAVAILABLE` status. 
             *  For example, if two backends are specified with equal weights, and one is invalid, 50 percent of traffic MUST receive an `UNAVAILABLE` status. Implementations may choose how that 50 percent is determined. 
             *  Support: Core for Kubernetes Service 
             *  Support: Implementation-specific for any other resource 
             *  Support for weight: Core
             */
            backendRefs?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefs[];
            /**
             * Filters define the filters that are applied to requests that match this rule. 
             *  The effects of ordering of multiple behaviors are currently unspecified. This can change in the future based on feedback during the alpha stage. 
             *  Conformance-levels at this level are defined based on the type of filter: 
             *  - ALL core filters MUST be supported by all implementations that support GRPCRoute. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations. 
             *  Specifying the same filter multiple times is not supported unless explicitly indicated in the filter. 
             *  If an implementation can not support a combination of filters, it must clearly document that limitation. In cases where incompatible or unsupported filters are specified and cause the `Accepted` condition to be set to status `False`, implementations may use the `IncompatibleFilters` reason to specify this configuration error. 
             *  Support: Core
             */
            filters?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFilters[];
            /**
             * Matches define conditions used for matching the rule against incoming gRPC requests. Each match is independent, i.e. this rule will be matched if **any** one of the matches is satisfied. 
             *  For example, take the following matches configuration: 
             *  ``` matches: - method: service: foo.bar headers: values: version: 2 - method: service: foo.bar.v2 ``` 
             *  For a request to match against this rule, it MUST satisfy EITHER of the two conditions: 
             *  - service of foo.bar AND contains the header `version: 2` - service of foo.bar.v2 
             *  See the documentation for GRPCRouteMatch on how to specify multiple match conditions to be ANDed together. 
             *  If no matches are specified, the implementation MUST match every gRPC request. 
             *  Proxy or Load Balancer routing configuration generated from GRPCRoutes MUST prioritize rules based on the following criteria, continuing on ties. Merging MUST not be done between GRPCRoutes and HTTPRoutes. Precedence MUST be given to the rule with the largest number of: 
             *  * Characters in a matching non-wildcard hostname. * Characters in a matching hostname. * Characters in a matching service. * Characters in a matching method. * Header matches. 
             *  If ties still exist across multiple Routes, matching precedence MUST be determined in order of the following criteria, continuing on ties: 
             *  * The oldest Route based on creation timestamp. * The Route appearing first in alphabetical order by "{namespace}/{name}". 
             *  If ties still exist within the Route that has been given precedence, matching precedence MUST be granted to the first matching rule meeting the above criteria.
             */
            matches?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatches[];
        }

        /**
         * GRPCBackendRef defines how a GRPCRoute forwards a gRPC request. 
         *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
         *  <gateway:experimental:description> 
         *  When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port. 
         *  Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726. 
         *  If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service. 
         *  If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason. 
         *  </gateway:experimental:description>
         */
        export interface GRPCRouteSpecRulesBackendRefs {
            /**
             * Filters defined at this level MUST be executed if and only if the request is being forwarded to the backend defined here. 
             *  Support: Implementation-specific (For broader support of filters, use the Filters field in GRPCRouteRule.)
             */
            filters?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFilters[];
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. 
             *  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. 
             *  Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefs
         */
        export function grpcrouteSpecRulesBackendRefsProvideDefaults(val: GRPCRouteSpecRulesBackendRefs): GRPCRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesBackendRefsFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters. 
             *  Support: Implementation-specific 
             *  This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request headers. 
             *  Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored. 
             *  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends. 
             *  Support: Extended
             */
            requestMirror?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response headers. 
             *  Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels: 
             *  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters. 
             *  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters. 
             *  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters. 
             *  Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior. 
             *  If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response. 
             *  
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFilters
         */
        export function grpcrouteSpecRulesBackendRefsFiltersProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFilters): GRPCRouteSpecRulesBackendRefsFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters. 
         *  Support: Implementation-specific 
         *  This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request headers. 
         *  Support: Core
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: add: - name: "my-header" value: "bar,baz" 
             *  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2). 
             *  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz 
             *  Config: remove: ["my-header1", "my-header3"] 
             *  Output: GET /foo HTTP/1.1 my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value) before the action. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: set: - name: "my-header" value: "bar" 
             *  Output: GET /foo HTTP/1.1 my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored. 
         *  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends. 
         *  Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent. 
             *  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef. 
             *  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation. 
             *  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation. 
             *  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem. 
             *  Support: Extended for Kubernetes Service 
             *  Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirror
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirror): GRPCRouteSpecRulesBackendRefsFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1alpha2.grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent. 
         *  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef. 
         *  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation. 
         *  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation. 
         *  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem. 
         *  Support: Extended for Kubernetes Service 
         *  Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesBackendRefsFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response headers. 
         *  Support: Extended
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: add: - name: "my-header" value: "bar,baz" 
             *  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2). 
             *  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz 
             *  Config: remove: ["my-header1", "my-header3"] 
             *  Output: GET /foo HTTP/1.1 my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value) before the action. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: set: - name: "my-header" value: "bar" 
             *  Output: GET /foo HTTP/1.1 my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteFilter defines processing steps that must be completed during the request or response lifecycle. GRPCRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
         */
        export interface GRPCRouteSpecRulesFilters {
            /**
             * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters. 
             *  Support: Implementation-specific 
             *  This filter can be used multiple times within the same rule.
             */
            extensionRef?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersExtensionRef;
            /**
             * RequestHeaderModifier defines a schema for a filter that modifies request headers. 
             *  Support: Core
             */
            requestHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifier;
            /**
             * RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored. 
             *  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends. 
             *  Support: Extended
             */
            requestMirror?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirror;
            /**
             * ResponseHeaderModifier defines a schema for a filter that modifies response headers. 
             *  Support: Extended
             */
            responseHeaderModifier?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifier;
            /**
             * Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels: 
             *  - Core: Filter types and their corresponding configuration defined by "Support: Core" in this package, e.g. "RequestHeaderModifier". All implementations supporting GRPCRoute MUST support core filters. 
             *  - Extended: Filter types and their corresponding configuration defined by "Support: Extended" in this package, e.g. "RequestMirror". Implementers are encouraged to support extended filters. 
             *  - Implementation-specific: Filters that are defined and supported by specific vendors. In the future, filters showing convergence in behavior across multiple implementations will be considered for inclusion in extended or core conformance levels. Filter-specific configuration for such filters is specified using the ExtensionRef field. `Type` MUST be set to "ExtensionRef" for custom filters. 
             *  Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior. 
             *  If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response. 
             *  
             */
            type: string;
        }
        /**
         * grpcrouteSpecRulesFiltersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFilters
         */
        export function grpcrouteSpecRulesFiltersProvideDefaults(val: GRPCRouteSpecRulesFilters): GRPCRouteSpecRulesFilters {
            return {
                ...val,
                requestMirror: (val.requestMirror ? outputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val.requestMirror) : undefined),
            };
        }

        /**
         * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  For example, resource "myroutefilter" in group "networking.example.net"). ExtensionRef MUST NOT be used for core and extended filters. 
         *  Support: Implementation-specific 
         *  This filter can be used multiple times within the same rule.
         */
        export interface GRPCRouteSpecRulesFiltersExtensionRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group: string;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
        }

        /**
         * RequestHeaderModifier defines a schema for a filter that modifies request headers. 
         *  Support: Core
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: add: - name: "my-header" value: "bar,baz" 
             *  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2). 
             *  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz 
             *  Config: remove: ["my-header1", "my-header3"] 
             *  Output: GET /foo HTTP/1.1 my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value) before the action. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: set: - name: "my-header" value: "bar" 
             *  Output: GET /foo HTTP/1.1 my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersRequestHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * RequestMirror defines a schema for a filter that mirrors requests. Requests are sent to the specified destination, but responses from that destination are ignored. 
         *  This filter can be used multiple times within the same rule. Note that not all implementations will be able to support mirroring to multiple backends. 
         *  Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirror {
            /**
             * BackendRef references a resource where mirrored requests are sent. 
             *  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef. 
             *  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation. 
             *  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation. 
             *  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem. 
             *  Support: Extended for Kubernetes Service 
             *  Support: Implementation-specific for any other resource
             */
            backendRef: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersRequestMirrorBackendRef;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirror
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirror): GRPCRouteSpecRulesFiltersRequestMirror {
            return {
                ...val,
                backendRef: outputs.gateway.v1alpha2.grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val.backendRef),
            };
        }

        /**
         * BackendRef references a resource where mirrored requests are sent. 
         *  Mirrored requests must be sent only to a single destination endpoint within this BackendRef, irrespective of how many endpoints are present within this BackendRef. 
         *  If the referent cannot be found, this BackendRef is invalid and must be dropped from the Gateway. The controller must ensure the "ResolvedRefs" condition on the Route status is set to `status: False` and not configure this backend in the underlying implementation. 
         *  If there is a cross-namespace reference to an *existing* object that is not allowed by a ReferenceGrant, the controller must ensure the "ResolvedRefs"  condition on the Route is set to `status: False`, with the "RefNotPermitted" reason and not configure this backend in the underlying implementation. 
         *  In either error case, the Message of the `ResolvedRefs` Condition should be used to provide more detail about the problem. 
         *  Support: Extended for Kubernetes Service 
         *  Support: Implementation-specific for any other resource
         */
        export interface GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
        }
        /**
         * grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesFiltersRequestMirrorBackendRef
         */
        export function grpcrouteSpecRulesFiltersRequestMirrorBackendRefProvideDefaults(val: GRPCRouteSpecRulesFiltersRequestMirrorBackendRef): GRPCRouteSpecRulesFiltersRequestMirrorBackendRef {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
            };
        }

        /**
         * ResponseHeaderModifier defines a schema for a filter that modifies response headers. 
         *  Support: Extended
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifier {
            /**
             * Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: add: - name: "my-header" value: "bar,baz" 
             *  Output: GET /foo HTTP/1.1 my-header: foo,bar,baz
             */
            add?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd[];
            /**
             * Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2). 
             *  Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz 
             *  Config: remove: ["my-header1", "my-header3"] 
             *  Output: GET /foo HTTP/1.1 my-header2: bar
             */
            remove?: string[];
            /**
             * Set overwrites the request with the given header (name, value) before the action. 
             *  Input: GET /foo HTTP/1.1 my-header: foo 
             *  Config: set: - name: "my-header" value: "bar" 
             *  Output: GET /foo HTTP/1.1 my-header: bar
             */
            set?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesFiltersResponseHeaderModifierSet[];
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        export interface GRPCRouteSpecRulesFiltersResponseHeaderModifierSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). 
             *  If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value: string;
        }

        /**
         * GRPCRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied. 
         *  For example, the match below will match a gRPC request only if its service is `foo` AND it contains the `version: v1` header: 
         *  ``` matches: - method: type: Exact service: "foo" headers: - name: "version" value "v1" 
         *  ```
         */
        export interface GRPCRouteSpecRulesMatches {
            /**
             * Headers specifies gRPC request header matchers. Multiple match values are ANDed together, meaning, a request MUST match all the specified headers to select the route.
             */
            headers?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesHeaders[];
            /**
             * Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
             */
            method?: outputs.gateway.v1alpha2.GRPCRouteSpecRulesMatchesMethod;
        }
        /**
         * grpcrouteSpecRulesMatchesProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatches
         */
        export function grpcrouteSpecRulesMatchesProvideDefaults(val: GRPCRouteSpecRulesMatches): GRPCRouteSpecRulesMatches {
            return {
                ...val,
                method: (val.method ? outputs.gateway.v1alpha2.grpcrouteSpecRulesMatchesMethodProvideDefaults(val.method) : undefined),
            };
        }

        /**
         * GRPCHeaderMatch describes how to select a gRPC route by matching gRPC request headers.
         */
        export interface GRPCRouteSpecRulesMatchesHeaders {
            /**
             * Name is the name of the gRPC Header to be matched. 
             *  If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
             */
            name: string;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: string;
            /**
             * Value is the value of the gRPC Header to be matched.
             */
            value: string;
        }
        /**
         * grpcrouteSpecRulesMatchesHeadersProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesHeaders
         */
        export function grpcrouteSpecRulesMatchesHeadersProvideDefaults(val: GRPCRouteSpecRulesMatchesHeaders): GRPCRouteSpecRulesMatchesHeaders {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Method specifies a gRPC request service/method matcher. If this field is not specified, all services and methods will match.
         */
        export interface GRPCRouteSpecRulesMatchesMethod {
            /**
             * Value of the method to match against. If left empty or omitted, will match all services. 
             *  At least one of Service and Method MUST be a non-empty string.
             */
            method?: string;
            /**
             * Value of the service to match against. If left empty or omitted, will match any service. 
             *  At least one of Service and Method MUST be a non-empty string.
             */
            service?: string;
            /**
             * Type specifies how to match against the service and/or method. Support: Core (Exact with service and method specified) 
             *  Support: Implementation-specific (Exact with method specified but no service specified) 
             *  Support: Implementation-specific (RegularExpression)
             */
            type?: string;
        }
        /**
         * grpcrouteSpecRulesMatchesMethodProvideDefaults sets the appropriate defaults for GRPCRouteSpecRulesMatchesMethod
         */
        export function grpcrouteSpecRulesMatchesMethodProvideDefaults(val: GRPCRouteSpecRulesMatchesMethod): GRPCRouteSpecRulesMatchesMethod {
            return {
                ...val,
                type: (val.type) ?? "Exact",
            };
        }

        /**
         * Status defines the current state of GRPCRoute.
         */
        export interface GRPCRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified. 
             *  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for. 
             *  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.GRPCRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an associated Parent.
         */
        export interface GRPCRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status. 
             *  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why. 
             *  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway. 
             *  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when: 
             *  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.GRPCRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass. 
             *  Example: "example.net/gateway-controller". 
             *  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). 
             *  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.GRPCRouteStatusParentsParentRef;
        }
        /**
         * grpcrouteStatusParentsProvideDefaults sets the appropriate defaults for GRPCRouteStatusParents
         */
        export function grpcrouteStatusParentsProvideDefaults(val: GRPCRouteStatusParents): GRPCRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.grpcrouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
         *  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         *  // other fields }
         */
        export interface GRPCRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition. This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
         */
        export interface GRPCRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * grpcrouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for GRPCRouteStatusParentsParentRef
         */
        export function grpcrouteStatusParentsParentRefProvideDefaults(val: GRPCRouteStatusParentsParentRef): GRPCRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpec {
            /**
             * From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR. 
             *  Support: Core
             */
            from: outputs.gateway.v1alpha2.ReferenceGrantSpecFrom[];
            /**
             * To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR. 
             *  Support: Core
             */
            to: outputs.gateway.v1alpha2.ReferenceGrantSpecTo[];
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFrom {
            /**
             * Group is the group of the referent. When empty, the Kubernetes core API group is inferred. 
             *  Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field. 
             *  When used to permit a SecretObjectReference: 
             *  * Gateway 
             *  When used to permit a BackendObjectReference: 
             *  * GRPCRoute * HTTPRoute * TCPRoute * TLSRoute * UDPRoute
             */
            kind: string;
            /**
             * Namespace is the namespace of the referent. 
             *  Support: Core
             */
            namespace: string;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the references.
         */
        export interface ReferenceGrantSpecTo {
            /**
             * Group is the group of the referent. When empty, the Kubernetes core API group is inferred. 
             *  Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field: 
             *  * Secret when used to permit a SecretObjectReference * Service when used to permit a BackendObjectReference
             */
            kind: string;
            /**
             * Name is the name of the referent. When unspecified, this policy refers to all resources of the specified Group and Kind in the local namespace.
             */
            name?: string;
        }

        /**
         * Spec defines the desired state of TCPRoute.
         */
        export interface TCPRouteSpec {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources. 
             *  ParentRefs must be _distinct_. This means either that: 
             *  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination. 
             *  Some examples: 
             *  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`. 
             *  It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged. 
             *  Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  
             */
            parentRefs?: outputs.gateway.v1alpha2.TCPRouteSpecParentRefs[];
            /**
             * Rules are a list of TCP matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.TCPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support: 
         *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
         *  This API may be extended in the future to support additional kinds of parent resources. 
         *  The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
         */
        export interface TCPRouteSpecParentRefs {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * tcprouteSpecParentRefsProvideDefaults sets the appropriate defaults for TCPRouteSpecParentRefs
         */
        export function tcprouteSpecParentRefsProvideDefaults(val: TCPRouteSpecParentRefs): TCPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TCPRouteRule is the configuration for a given rule.
         */
        export interface TCPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Connection rejections must respect weight; if an invalid backend is requested to have 80% of connections, then 80% of connections must be rejected instead. 
             *  Support: Core for Kubernetes Service 
             *  Support: Extended for Kubernetes ServiceImport 
             *  Support: Implementation-specific for any other resource 
             *  Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.TCPRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes resource. 
         *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
         *  <gateway:experimental:description> 
         *  When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port. 
         *  Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726. 
         *  If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service. 
         *  If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason. 
         *  </gateway:experimental:description> 
         *  Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
         */
        export interface TCPRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. 
             *  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. 
             *  Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * tcprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for TCPRouteSpecRulesBackendRefs
         */
        export function tcprouteSpecRulesBackendRefsProvideDefaults(val: TCPRouteSpecRulesBackendRefs): TCPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TCPRoute.
         */
        export interface TCPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified. 
             *  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for. 
             *  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.TCPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an associated Parent.
         */
        export interface TCPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status. 
             *  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why. 
             *  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway. 
             *  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when: 
             *  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.TCPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass. 
             *  Example: "example.net/gateway-controller". 
             *  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). 
             *  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.TCPRouteStatusParentsParentRef;
        }
        /**
         * tcprouteStatusParentsProvideDefaults sets the appropriate defaults for TCPRouteStatusParents
         */
        export function tcprouteStatusParentsProvideDefaults(val: TCPRouteStatusParents): TCPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.tcprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
         *  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         *  // other fields }
         */
        export interface TCPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition. This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
         */
        export interface TCPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * tcprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for TCPRouteStatusParentsParentRef
         */
        export function tcprouteStatusParentsParentRefProvideDefaults(val: TCPRouteStatusParentsParentRef): TCPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of TLSRoute.
         */
        export interface TLSRouteSpec {
            /**
             * Hostnames defines a set of SNI names that should match against the SNI attribute of TLS ClientHello message in TLS handshake. This matches the RFC 1123 definition of a hostname with 2 notable exceptions: 
             *  1. IPs are not allowed in SNI names per RFC 6066. 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard label must appear by itself as the first label. 
             *  If a hostname is specified by both the Listener and TLSRoute, there must be at least one intersecting hostname for the TLSRoute to be attached to the Listener. For example: 
             *  * A Listener with `test.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames, or have specified at least one of `test.example.com` or `*.example.com`. * A Listener with `*.example.com` as the hostname matches TLSRoutes that have either not specified any hostnames or have specified at least one hostname that matches the Listener hostname. For example, `test.example.com` and `*.example.com` would both match. On the other hand, `example.com` and `test.example.net` would not match. 
             *  If both the Listener and TLSRoute have specified hostnames, any TLSRoute hostnames that do not match the Listener hostname MUST be ignored. For example, if a Listener specified `*.example.com`, and the TLSRoute specified `test.example.com` and `test.example.net`, `test.example.net` must not be considered for a match. 
             *  If both the Listener and TLSRoute have specified hostnames, and none match with the criteria above, then the TLSRoute is not accepted. The implementation must raise an 'Accepted' Condition with a status of `False` in the corresponding RouteParentStatus. 
             *  Support: Core
             */
            hostnames?: string[];
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources. 
             *  ParentRefs must be _distinct_. This means either that: 
             *  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination. 
             *  Some examples: 
             *  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`. 
             *  It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged. 
             *  Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  
             */
            parentRefs?: outputs.gateway.v1alpha2.TLSRouteSpecParentRefs[];
            /**
             * Rules are a list of TLS matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.TLSRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support: 
         *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
         *  This API may be extended in the future to support additional kinds of parent resources. 
         *  The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
         */
        export interface TLSRouteSpecParentRefs {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * tlsrouteSpecParentRefsProvideDefaults sets the appropriate defaults for TLSRouteSpecParentRefs
         */
        export function tlsrouteSpecParentRefsProvideDefaults(val: TLSRouteSpecParentRefs): TLSRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * TLSRouteRule is the configuration for a given rule.
         */
        export interface TLSRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the rule performs no forwarding; if no filters are specified that would result in a response being sent, the underlying implementation must actively reject request attempts to this backend, by rejecting the connection or returning a 500 status code. Request rejections must respect weight; if an invalid backend is requested to have 80% of requests, then 80% of requests must be rejected instead. 
             *  Support: Core for Kubernetes Service 
             *  Support: Extended for Kubernetes ServiceImport 
             *  Support: Implementation-specific for any other resource 
             *  Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.TLSRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes resource. 
         *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
         *  <gateway:experimental:description> 
         *  When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port. 
         *  Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726. 
         *  If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service. 
         *  If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason. 
         *  </gateway:experimental:description> 
         *  Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
         */
        export interface TLSRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. 
             *  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. 
             *  Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * tlsrouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for TLSRouteSpecRulesBackendRefs
         */
        export function tlsrouteSpecRulesBackendRefsProvideDefaults(val: TLSRouteSpecRulesBackendRefs): TLSRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of TLSRoute.
         */
        export interface TLSRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified. 
             *  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for. 
             *  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.TLSRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an associated Parent.
         */
        export interface TLSRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status. 
             *  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why. 
             *  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway. 
             *  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when: 
             *  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.TLSRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass. 
             *  Example: "example.net/gateway-controller". 
             *  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). 
             *  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.TLSRouteStatusParentsParentRef;
        }
        /**
         * tlsrouteStatusParentsProvideDefaults sets the appropriate defaults for TLSRouteStatusParents
         */
        export function tlsrouteStatusParentsProvideDefaults(val: TLSRouteStatusParents): TLSRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.tlsrouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
         *  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         *  // other fields }
         */
        export interface TLSRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition. This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
         */
        export interface TLSRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * tlsrouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for TLSRouteStatusParentsParentRef
         */
        export function tlsrouteStatusParentsParentRefProvideDefaults(val: TLSRouteStatusParentsParentRef): TLSRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * Spec defines the desired state of UDPRoute.
         */
        export interface UDPRouteSpec {
            /**
             * ParentRefs references the resources (usually Gateways) that a Route wants to be attached to. Note that the referenced parent resource needs to allow this for the attachment to be complete. For Gateways, that means the Gateway needs to allow attachment from Routes of this kind and namespace. For Services, that means the Service must either be in the same namespace for a "producer" route, or the mesh implementation must support and allow "consumer" routes for the referenced Service. ReferenceGrant is not applicable for governing ParentRefs to Services - it is not possible to create a "producer" route for a Service in a different namespace from the Route. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile)  * Service (Mesh conformance profile, experimental, ClusterIP Services only)  This API may be extended in the future to support additional kinds of parent resources. 
             *  ParentRefs must be _distinct_. This means either that: 
             *  * They select different objects.  If this is the case, then parentRef entries are distinct. In terms of fields, this means that the multi-part key defined by `group`, `kind`, `namespace`, and `name` must be unique across all parentRef entries in the Route. * They do not select different objects, but for each optional field used, each ParentRef that selects the same object must set the same set of optional fields to different values. If one ParentRef sets a combination of optional fields, all must set the same combination. 
             *  Some examples: 
             *  * If one ParentRef sets `sectionName`, all ParentRefs referencing the same object must also set `sectionName`. * If one ParentRef sets `port`, all ParentRefs referencing the same object must also set `port`. * If one ParentRef sets `sectionName` and `port`, all ParentRefs referencing the same object must also set `sectionName` and `port`. 
             *  It is possible to separately reference multiple distinct objects that may be collapsed by an implementation. For example, some implementations may choose to merge compatible Gateway Listeners together. If that is the case, the list of routes attached to those resources should also be merged. 
             *  Note that for ParentRefs that cross namespace boundaries, there are specific rules. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example, Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable other kinds of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  
             */
            parentRefs?: outputs.gateway.v1alpha2.UDPRouteSpecParentRefs[];
            /**
             * Rules are a list of UDP matchers and actions.
             */
            rules: outputs.gateway.v1alpha2.UDPRouteSpecRules[];
        }

        /**
         * ParentReference identifies an API object (usually a Gateway) that can be considered a parent of this resource (usually a route). There are two kinds of parent resources with "Core" support: 
         *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
         *  This API may be extended in the future to support additional kinds of parent resources. 
         *  The API object must be valid in the cluster; the Group and Kind must be registered in the cluster for this reference to be valid.
         */
        export interface UDPRouteSpecParentRefs {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * udprouteSpecParentRefsProvideDefaults sets the appropriate defaults for UDPRouteSpecParentRefs
         */
        export function udprouteSpecParentRefsProvideDefaults(val: UDPRouteSpecParentRefs): UDPRouteSpecParentRefs {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

        /**
         * UDPRouteRule is the configuration for a given rule.
         */
        export interface UDPRouteSpecRules {
            /**
             * BackendRefs defines the backend(s) where matching requests should be sent. If unspecified or invalid (refers to a non-existent resource or a Service with no endpoints), the underlying implementation MUST actively reject connection attempts to this backend. Packet drops must respect weight; if an invalid backend is requested to have 80% of the packets, then 80% of packets must be dropped instead. 
             *  Support: Core for Kubernetes Service 
             *  Support: Extended for Kubernetes ServiceImport 
             *  Support: Implementation-specific for any other resource 
             *  Support for weight: Extended
             */
            backendRefs?: outputs.gateway.v1alpha2.UDPRouteSpecRulesBackendRefs[];
        }

        /**
         * BackendRef defines how a Route should forward a request to a Kubernetes resource. 
         *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
         *  <gateway:experimental:description> 
         *  When the BackendRef points to a Kubernetes Service, implementations SHOULD honor the appProtocol field if it is set for the target Service Port. 
         *  Implementations supporting appProtocol SHOULD recognize the Kubernetes Standard Application Protocols defined in KEP-3726. 
         *  If a Service appProtocol isn't specified, an implementation MAY infer the backend protocol through its own means. Implementations MAY infer the protocol from the Route type referring to the backend Service. 
         *  If a Route is not able to send traffic to the backend using the specified protocol then the backend is considered invalid. Implementations MUST set the "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason. 
         *  </gateway:experimental:description> 
         *  Note that when the BackendTLSPolicy object is enabled by the implementation, there are some extra rules about validity to consider here. See the fields where this struct is used for more information about the exact behavior.
         */
        export interface UDPRouteSpecRulesBackendRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io". When unspecified or empty string, core API group is inferred.
             */
            group?: string;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example "Service". 
             *  Defaults to "Service" when not specified. 
             *  ExternalName services can refer to CNAME DNS records that may live outside of the cluster and as such are difficult to reason about in terms of conformance. They also may not be safe to forward to (see CVE-2021-25740 for more information). Implementations SHOULD NOT support ExternalName Services. 
             *  Support: Core (Services with a type other than ExternalName) 
             *  Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: string;
            /**
             * Name is the name of the referent.
             */
            name: string;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local namespace is inferred. 
             *  Note that when a namespace different than the local namespace is specified, a ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. 
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port specifies the destination port number to use for this resource. Port is required when the referent is a Kubernetes Service. In this case, the port number is the service port number, not the target port. For other resources, destination port might be derived from the referent resource or this field.
             */
            port?: number;
            /**
             * Weight specifies the proportion of requests forwarded to the referenced backend. This is computed as weight/(sum of all weights in this BackendRefs list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports. Weight is not a percentage and the sum of weights does not need to equal 100. 
             *  If only one backend is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend. If weight is set to 0, no traffic should be forwarded for this entry. If unspecified, weight defaults to 1. 
             *  Support for this field varies based on the context where used.
             */
            weight?: number;
        }
        /**
         * udprouteSpecRulesBackendRefsProvideDefaults sets the appropriate defaults for UDPRouteSpecRulesBackendRefs
         */
        export function udprouteSpecRulesBackendRefsProvideDefaults(val: UDPRouteSpecRulesBackendRefs): UDPRouteSpecRulesBackendRefs {
            return {
                ...val,
                group: (val.group) ?? "",
                kind: (val.kind) ?? "Service",
                weight: (val.weight) ?? 1,
            };
        }

        /**
         * Status defines the current state of UDPRoute.
         */
        export interface UDPRouteStatus {
            /**
             * Parents is a list of parent resources (usually Gateways) that are associated with the route, and the status of the route with respect to each parent. When this route attaches to a parent, the controller that manages the parent must add an entry to this list when the controller first sees the route and should update the entry as appropriate when the route or gateway is modified. 
             *  Note that parent references that cannot be resolved by an implementation of this API will not be added to this list. Implementations of this API can only populate Route status for the Gateways/parent resources they are responsible for. 
             *  A maximum of 32 Gateways will be represented in this list. An empty list means the route has not been attached to any Gateway.
             */
            parents: outputs.gateway.v1alpha2.UDPRouteStatusParents[];
        }

        /**
         * RouteParentStatus describes the status of a route with respect to an associated Parent.
         */
        export interface UDPRouteStatusParents {
            /**
             * Conditions describes the status of the route with respect to the Gateway. Note that the route's availability is also subject to the Gateway's own status conditions and listener status. 
             *  If the Route's ParentRef specifies an existing Gateway that supports Routes of this kind AND that Gateway's controller has sufficient access, then that Gateway's controller MUST set the "Accepted" condition on the Route, to indicate whether the route has been accepted or rejected by the Gateway, and why. 
             *  A Route MUST be considered "Accepted" if at least one of the Route's rules is implemented by the Gateway. 
             *  There are a number of cases where the "Accepted" condition may not be set due to lack of controller visibility, that includes when: 
             *  * The Route refers to a non-existent parent. * The Route is of a type that the controller does not support. * The Route is in a namespace the controller does not have access to.
             */
            conditions?: outputs.gateway.v1alpha2.UDPRouteStatusParentsConditions[];
            /**
             * ControllerName is a domain/path string that indicates the name of the controller that wrote this status. This corresponds with the controllerName field on GatewayClass. 
             *  Example: "example.net/gateway-controller". 
             *  The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are valid Kubernetes names (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names). 
             *  Controllers MUST populate this field when writing status. Controllers should ensure that entries to status populated with their ControllerName are cleaned up when they are no longer necessary.
             */
            controllerName: string;
            /**
             * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
             */
            parentRef: outputs.gateway.v1alpha2.UDPRouteStatusParentsParentRef;
        }
        /**
         * udprouteStatusParentsProvideDefaults sets the appropriate defaults for UDPRouteStatusParents
         */
        export function udprouteStatusParentsProvideDefaults(val: UDPRouteStatusParents): UDPRouteStatusParents {
            return {
                ...val,
                parentRef: outputs.gateway.v1alpha2.udprouteStatusParentsParentRefProvideDefaults(val.parentRef),
            };
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, 
         *  type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         *  // other fields }
         */
        export interface UDPRouteStatusParentsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * message is a human readable message indicating details about the transition. This may be an empty string.
             */
            message: string;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
             */
            observedGeneration?: number;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
             */
            reason: string;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
             */
            type: string;
        }

        /**
         * ParentRef corresponds with a ParentRef in the spec that this RouteParentStatus struct describes the status of.
         */
        export interface UDPRouteStatusParentsParentRef {
            /**
             * Group is the group of the referent. When unspecified, "gateway.networking.k8s.io" is inferred. To set the core API group (such as for a "Service" kind referent), Group must be explicitly set to "" (empty string). 
             *  Support: Core
             */
            group?: string;
            /**
             * Kind is kind of the referent. 
             *  There are two kinds of parent resources with "Core" support: 
             *  * Gateway (Gateway conformance profile) * Service (Mesh conformance profile, experimental, ClusterIP Services only) 
             *  Support for other resources is Implementation-Specific.
             */
            kind?: string;
            /**
             * Name is the name of the referent. 
             *  Support: Core
             */
            name: string;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers to the local namespace of the Route. 
             *  Note that there are specific rules for ParentRefs which cross namespace boundaries. Cross-namespace references are only valid if they are explicitly allowed by something in the namespace they are referring to. For example: Gateway has the AllowedRoutes field, and ReferenceGrant provides a generic way to enable any other kind of cross-namespace reference. 
             *   ParentRefs from a Route to a Service in the same namespace are "producer" routes, which apply default routing rules to inbound connections from any namespace to the Service. 
             *  ParentRefs from a Route to a Service in a different namespace are "consumer" routes, and these routing rules are only applied to outbound connections originating from the same namespace as the Route, for which the intended destination of the connections are a Service targeted as a ParentRef of the Route.  
             *  Support: Core
             */
            namespace?: string;
            /**
             * Port is the network port this Route targets. It can be interpreted differently based on the type of parent resource. 
             *  When the parent resource is a Gateway, this targets all listeners listening on the specified port that also support this kind of Route(and select this Route). It's not recommended to set `Port` unless the networking behaviors specified in a Route must apply to a specific port as opposed to a listener(s) whose port(s) may be changed. When both Port and SectionName are specified, the name and port of the selected listener must match both specified values. 
             *   When the parent resource is a Service, this targets a specific port in the Service spec. When both Port (experimental) and SectionName are specified, the name and port of the selected port must match both specified values.  
             *  Implementations MAY choose to support other parent resources. Implementations supporting other types of parent resources MUST clearly document how/if Port is interpreted. 
             *  For the purpose of status, an attachment is considered successful as long as the parent resource accepts it partially. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Extended 
             *  
             */
            port?: number;
            /**
             * SectionName is the name of a section within the target resource. In the following resources, SectionName is interpreted as the following: 
             *  * Gateway: Listener Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. * Service: Port Name. When both Port (experimental) and SectionName are specified, the name and port of the selected listener must match both specified values. Note that attaching Routes to Services as Parents is part of experimental Mesh support and is not supported for any other purpose. 
             *  Implementations MAY choose to support attaching Routes to other resources. If that is the case, they MUST clearly document how SectionName is interpreted. 
             *  When unspecified (empty string), this will reference the entire resource. For the purpose of status, an attachment is considered successful if at least one section in the parent resource accepts it. For example, Gateway listeners can restrict which Routes can attach to them by Route kind, namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from the referencing Route, the Route MUST be considered successfully attached. If no Gateway listeners accept attachment from this Route, the Route MUST be considered detached from the Gateway. 
             *  Support: Core
             */
            sectionName?: string;
        }
        /**
         * udprouteStatusParentsParentRefProvideDefaults sets the appropriate defaults for UDPRouteStatusParentsParentRef
         */
        export function udprouteStatusParentsParentRefProvideDefaults(val: UDPRouteStatusParentsParentRef): UDPRouteStatusParentsParentRef {
            return {
                ...val,
                group: (val.group) ?? "gateway.networking.k8s.io",
                kind: (val.kind) ?? "Gateway",
            };
        }

    }

    export namespace v1beta1 {
        /**
         * Spec defines the desired state of ReferenceGrant.
         */
        export interface ReferenceGrantSpec {
            /**
             * From describes the trusted namespaces and kinds that can reference the resources described in "To". Each entry in this list MUST be considered to be an additional place that references can be valid from, or to put this another way, entries MUST be combined using OR. 
             *  Support: Core
             */
            from: outputs.gateway.v1beta1.ReferenceGrantSpecFrom[];
            /**
             * To describes the resources that may be referenced by the resources described in "From". Each entry in this list MUST be considered to be an additional place that references can be valid to, or to put this another way, entries MUST be combined using OR. 
             *  Support: Core
             */
            to: outputs.gateway.v1beta1.ReferenceGrantSpecTo[];
        }

        /**
         * ReferenceGrantFrom describes trusted namespaces and kinds.
         */
        export interface ReferenceGrantSpecFrom {
            /**
             * Group is the group of the referent. When empty, the Kubernetes core API group is inferred. 
             *  Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field. 
             *  When used to permit a SecretObjectReference: 
             *  * Gateway 
             *  When used to permit a BackendObjectReference: 
             *  * GRPCRoute * HTTPRoute * TCPRoute * TLSRoute * UDPRoute
             */
            kind: string;
            /**
             * Namespace is the namespace of the referent. 
             *  Support: Core
             */
            namespace: string;
        }

        /**
         * ReferenceGrantTo describes what Kinds are allowed as targets of the references.
         */
        export interface ReferenceGrantSpecTo {
            /**
             * Group is the group of the referent. When empty, the Kubernetes core API group is inferred. 
             *  Support: Core
             */
            group: string;
            /**
             * Kind is the kind of the referent. Although implementations may support additional resources, the following types are part of the "Core" support level for this field: 
             *  * Secret when used to permit a SecretObjectReference * Service when used to permit a BackendObjectReference
             */
            kind: string;
            /**
             * Name is the name of the referent. When unspecified, this policy refers to all resources of the specified Group and Kind in the local namespace.
             */
            name?: string;
        }

    }
}

export namespace ipam {
    export namespace v1alpha1 {
        /**
         * IPAddressClaimSpec is the desired state of an IPAddressClaim.
         */
        export interface IPAddressClaimSpec {
            /**
             * PoolRef is a reference to the pool from which an IP address should be created.
             */
            poolRef: outputs.ipam.v1alpha1.IPAddressClaimSpecPoolRef;
        }

        /**
         * PoolRef is a reference to the pool from which an IP address should be created.
         */
        export interface IPAddressClaimSpecPoolRef {
            /**
             * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
             */
            apiGroup: string;
            /**
             * Kind is the type of resource being referenced
             */
            kind: string;
            /**
             * Name is the name of resource being referenced
             */
            name: string;
        }

        /**
         * IPAddressClaimStatus is the observed status of a IPAddressClaim.
         */
        export interface IPAddressClaimStatus {
            /**
             * AddressRef is a reference to the address that was created for this claim.
             */
            addressRef?: outputs.ipam.v1alpha1.IPAddressClaimStatusAddressRef;
            /**
             * Conditions summarises the current state of the IPAddressClaim
             */
            conditions?: outputs.ipam.v1alpha1.IPAddressClaimStatusConditions[];
        }

        /**
         * AddressRef is a reference to the address that was created for this claim.
         */
        export interface IPAddressClaimStatusAddressRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface IPAddressClaimStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * IPAddressSpec is the desired state of an IPAddress.
         */
        export interface IPAddressSpec {
            /**
             * Address is the IP address.
             */
            address: string;
            /**
             * ClaimRef is a reference to the claim this IPAddress was created for.
             */
            claimRef: outputs.ipam.v1alpha1.IPAddressSpecClaimRef;
            /**
             * Gateway is the network gateway of the network the address is from.
             */
            gateway?: string;
            /**
             * PoolRef is a reference to the pool that this IPAddress was created from.
             */
            poolRef: outputs.ipam.v1alpha1.IPAddressSpecPoolRef;
            /**
             * Prefix is the prefix of the address.
             */
            prefix: number;
        }

        /**
         * ClaimRef is a reference to the claim this IPAddress was created for.
         */
        export interface IPAddressSpecClaimRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
        }

        /**
         * PoolRef is a reference to the pool that this IPAddress was created from.
         */
        export interface IPAddressSpecPoolRef {
            /**
             * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
             */
            apiGroup: string;
            /**
             * Kind is the type of resource being referenced
             */
            kind: string;
            /**
             * Name is the name of resource being referenced
             */
            name: string;
        }

    }
}

export namespace runtime {
    export namespace v1alpha1 {
        /**
         * ExtensionConfigSpec is the desired state of the ExtensionConfig
         */
        export interface ExtensionConfigSpec {
            /**
             * ClientConfig defines how to communicate with the Extension server.
             */
            clientConfig: outputs.runtime.v1alpha1.ExtensionConfigSpecClientConfig;
            /**
             * NamespaceSelector decides whether to call the hook for an object based on whether the namespace for that object matches the selector. Defaults to the empty LabelSelector, which matches all objects.
             */
            namespaceSelector?: outputs.runtime.v1alpha1.ExtensionConfigSpecNamespaceSelector;
            /**
             * Settings defines key value pairs to be passed to all calls to all supported RuntimeExtensions. Note: Settings can be overridden on the ClusterClass.
             */
            settings?: {[key: string]: string};
        }

        /**
         * ClientConfig defines how to communicate with the Extension server.
         */
        export interface ExtensionConfigSpecClientConfig {
            /**
             * CABundle is a PEM encoded CA bundle which will be used to validate the Extension server's server certificate.
             */
            caBundle?: string;
            /**
             * Service is a reference to the Kubernetes service for the Extension server. Note: Exactly one of `url` or `service` must be specified. 
             *  If the Extension server is running within a cluster, then you should use `service`.
             */
            service?: outputs.runtime.v1alpha1.ExtensionConfigSpecClientConfigService;
            /**
             * URL gives the location of the Extension server, in standard URL form (`scheme://host:port/path`). Note: Exactly one of `url` or `service` must be specified. 
             *  The scheme must be "https". 
             *  The `host` should not refer to a service running in the cluster; use the `service` field instead. 
             *  A path is optional, and if present may be any string permissible in a URL. If a path is set it will be used as prefix to the hook-specific path. 
             *  Attempting to use a user or basic auth e.g. "user:password@" is not allowed. Fragments ("#...") and query parameters ("?...") are not allowed either.
             */
            url?: string;
        }

        /**
         * Service is a reference to the Kubernetes service for the Extension server. Note: Exactly one of `url` or `service` must be specified. 
         *  If the Extension server is running within a cluster, then you should use `service`.
         */
        export interface ExtensionConfigSpecClientConfigService {
            /**
             * Name is the name of the service.
             */
            name: string;
            /**
             * Namespace is the namespace of the service.
             */
            namespace: string;
            /**
             * Path is an optional URL path and if present may be any string permissible in a URL. If a path is set it will be used as prefix to the hook-specific path.
             */
            path?: string;
            /**
             * Port is the port on the service that's hosting the Extension server. Defaults to 443. Port should be a valid port number (1-65535, inclusive).
             */
            port?: number;
        }

        /**
         * NamespaceSelector decides whether to call the hook for an object based on whether the namespace for that object matches the selector. Defaults to the empty LabelSelector, which matches all objects.
         */
        export interface ExtensionConfigSpecNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.runtime.v1alpha1.ExtensionConfigSpecNamespaceSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ExtensionConfigSpecNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * ExtensionConfigStatus is the current state of the ExtensionConfig
         */
        export interface ExtensionConfigStatus {
            /**
             * Conditions define the current service state of the ExtensionConfig.
             */
            conditions?: outputs.runtime.v1alpha1.ExtensionConfigStatusConditions[];
            /**
             * Handlers defines the current ExtensionHandlers supported by an Extension.
             */
            handlers?: outputs.runtime.v1alpha1.ExtensionConfigStatusHandlers[];
        }

        /**
         * Condition defines an observation of a Cluster API resource operational state.
         */
        export interface ExtensionConfigStatusConditions {
            /**
             * Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string;
            /**
             * A human readable message indicating details about the transition. This field may be empty.
             */
            message?: string;
            /**
             * The reason for the condition's last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.
             */
            reason?: string;
            /**
             * Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.
             */
            severity?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.
             */
            type: string;
        }

        /**
         * ExtensionHandler specifies the details of a handler for a particular runtime hook registered by an Extension server.
         */
        export interface ExtensionConfigStatusHandlers {
            /**
             * FailurePolicy defines how failures in calls to the ExtensionHandler should be handled by a client. Defaults to Fail if not set.
             */
            failurePolicy?: string;
            /**
             * Name is the unique name of the ExtensionHandler.
             */
            name: string;
            /**
             * RequestHook defines the versioned runtime hook which this ExtensionHandler serves.
             */
            requestHook: outputs.runtime.v1alpha1.ExtensionConfigStatusHandlersRequestHook;
            /**
             * TimeoutSeconds defines the timeout duration for client calls to the ExtensionHandler. Defaults to 10 is not set.
             */
            timeoutSeconds?: number;
        }

        /**
         * RequestHook defines the versioned runtime hook which this ExtensionHandler serves.
         */
        export interface ExtensionConfigStatusHandlersRequestHook {
            /**
             * APIVersion is the group and version of the Hook.
             */
            apiVersion: string;
            /**
             * Hook is the name of the hook.
             */
            hook: string;
        }

    }
}
