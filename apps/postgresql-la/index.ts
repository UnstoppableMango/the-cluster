import * as pulumi from '@pulumi/pulumi';
import * as random from '@pulumi/random';
import * as k8s from '@pulumi/kubernetes';
import { provider, storageClasses } from '@unmango/thecluster/cluster/from-stack';
import { adminPasswordKey, architecture, exporterRepository, gid, hosts, loadBalancerIP, metricsPort, postgresPort, primaryDatabase, primaryUsername, registry, replicationPasswordKey, replicationUsername, repository, resources, uid, userPasswordKey, versions } from './config';

const ns = k8s.core.v1.Namespace.get('postgres', 'postgres', { provider });

const adminPassword = password('postgres');
const primaryPassword = password(primaryUsername);
const replicationPassword = password(replicationUsername);

const secret = new k8s.core.v1.Secret('postgres', {
  metadata: {
    name: 'postgres',
    namespace: ns.metadata.name,
  },
  stringData: {
    [adminPasswordKey]: adminPassword.result,
    [userPasswordKey]: primaryPassword.result,
    [replicationPasswordKey]: replicationPassword.result,
  },
}, { provider });

const chart = new k8s.helm.v3.Chart('postgres', {
  path: './',
  namespace: ns.metadata.name,
  values: {
    postgresql: {
      global: {
        storageClass: storageClasses.rbd,
        postgresql: {
          // The values.yaml mentions this overrides `service.ports.postgresql`
          // but I don't think this chart has a top-level `service` object...
          // They seem to be split into `primary.service` and `read.service`.
          service: {
            ports: {
              postgresql: postgresPort,
            },
          },
        },
      },
      image: {
        registry,
        repository,
        tag: versions.bitnamiPostgresql,
      },
      auth: {
        username: primaryUsername,
        database: primaryDatabase,
        replicationUsername,
        existingSecret: secret.metadata.name,
        secretKeys: {
          adminPasswordKey,
          userPasswordKey,
          replicationPasswordKey,
        },
      },
      architecture,
      replication: {
        applicationName: 'thecluster',
      },
      tls: {
        enabled: true,
        autoGenerated: true,
      },
      primary: {
        resources,
        podSecurityContext: {
          fsGroup: gid,
        },
        containerSecurityContext: {
          runAsUser: uid,
        },
        priorityClassName: 'system-cluster-critical',
        service: {
          type: 'LoadBalancer',
          loadBalancerIP,
          annotations: {
            'external-dns.alpha.kubernetes.io/hostname': hosts.internal,
          },
        },
        persistence: {
          size: '100Gi',
        },
        persistentVolumeClaimRetentionPolicy: {
          enabled: false,
          whenScaled: 'Retain',
          whenDeleted: 'Retain',
        },
      },
      readReplicas: {
        replicaCount: 4,
        resources,
        podSecurityContext: {
          fsGroup: gid,
        },
        containerSecurityContext: {
          runAsUser: uid,
        },
        service: {
          type: 'ClusterIP',
        },
        persistence: {
          size: '100Gi',
        },
      },
      serviceAccount: { create: true },
      rbac: { create: true },
      metrics: {
        enabled: false,
        image: {
          registry,
          repository: exporterRepository,
          tag: versions.bitnamiExporter,
        },
        containerSecurityContext: {
          runAsUser: uid,
        },
        service: {
          ports: {
            metrics: metricsPort,
          },
        },
      },
    },
  },
  transformations: [],
}, { provider });

export const passwords = {
  postgres: adminPassword.result,
  primary: primaryPassword.result,
};

function password(name: string): random.RandomPassword {
  return new random.RandomPassword(name, {
    length: 48,
    special: false,
  });
}
