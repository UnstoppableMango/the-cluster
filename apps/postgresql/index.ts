import * as pulumi from '@pulumi/pulumi';
import * as random from '@pulumi/random';
import * as k8s from '@pulumi/kubernetes';
import { Certificate, Issuer, ClusterIssuer } from '@pulumi/crds/certmanager/v1';
import { provider } from '@unmango/thecluster/cluster/from-stack';
import { rbdStorageClass } from '@unmango/thecluster/storage';
import { clusterIssuers } from '@unmango/thecluster/tls';
import { required } from '@unmango/thecluster';
import { keepers, username, database, versions } from './config';

const ns = new k8s.core.v1.Namespace('postgresql', {
  metadata: { name: 'postgresql' },
}, { provider });

const tlsSecretName = 'postgres-tls';
const clusterIssuer = ClusterIssuer.get('selfsigned', clusterIssuers.selfSigned);
const ca = new Certificate('postgres-ca', {
  metadata: {
    name: 'postgres-ca',
    namespace: ns.metadata.name,
  },
  spec: {
    isCA: true,
    commonName: 'unmango-postgres-ca',
    secretName: tlsSecretName,
    privateKey: {
      algorithm: 'ECDSA',
      size: 256,
    },
    issuerRef: {
      group: 'cert-manager.io',
      kind: clusterIssuer.kind.apply(required),
      name: clusterIssuers.selfSigned,
    },
  },
}, { provider });

const issuer = new Issuer('postgres', {
  metadata: {
    name: 'postgres',
    namespace: ns.metadata.name,
  },
  spec: {
    ca: {
      secretName: tlsSecretName,
    },
  },
}, { provider });

const adminPassword = new random.RandomPassword('admin', {
  length: 48,
  keepers: {
    // Manual password reset with `./scripts/reset-password.sh`
    manual: keepers.admin,
  },
});

const userPassword = new random.RandomPassword('user', {
  length: 48,
  keepers: {
    // Manual password reset with `./scripts/reset-password.sh`
    manual: keepers.user,
  },
});

const replicationPassword = new random.RandomPassword('replication', {
  length: 48,
  keepers: {
    // Manual password reset with `./scripts/reset-password.sh`
    manual: keepers.replication,
  },
});

const credSecret = new k8s.core.v1.Secret('credentials', {
  metadata: {
    name: 'credentials',
    namespace: ns.metadata.name,
  },
  stringData: {
    admin: adminPassword.result,
    user: userPassword.result,
    replication: replicationPassword.result,
  },
}, { provider });

// No idea if this is a good idea or not
// const primaryPv = new k8s.core.v1.PersistentVolume('primary', {
//   metadata: {
//     name: 'primary',
//     namespace: ns.metadata.name,
//   },
//   spec: {
//     accessModes: ['ReadWriteOnce'],
//   },
// }, { provider });

const primaryPvc = new k8s.core.v1.PersistentVolumeClaim('primary', {
  metadata: {
    name: 'primary',
    namespace: ns.metadata.name,
  },
  spec: {
    storageClassName: rbdStorageClass,
    accessModes: ['ReadWriteOnce'],
    resources: {
      requests: {
        storage: '500Gi',
      },
    },
  },
}, { provider });

const readReplicaPvc = new k8s.core.v1.PersistentVolumeClaim('read-replica', {
  metadata: {
    name: 'read-replica',
    namespace: ns.metadata.name,
  },
  spec: {
    storageClassName: rbdStorageClass,
    accessModes: ['ReadWriteOnce'],
    resources: {
      requests: {
        storage: '500Gi',
      },
    },
  },
}, { provider });

const chart = new k8s.helm.v3.Chart('postgresql', {
  path: './',
  namespace: ns.metadata.name,
  values: {
    // https://github.com/bitnami/charts/blob/main/bitnami/postgresql/values.yaml
    postgresql: {
      global: {
        storageClass: rbdStorageClass,
        postgresql: {
          auth: {
            username,
            database,
            existingSecret: credSecret.metadata.name,
            secretKeys: {
              adminPasswordKey: 'admin',
              userPasswordKey: 'user',
              replicationPasswordKey: 'replication',
            },
          },
        },
      },
      kubeVersion: versions.k8s,
      // TODO: See if one of these can make things prettier
      // nameOverride: '',
      // fullnameOverride: '',
      image: {
        tag: versions.bitnami.postgres,
      },
      auth: {
        enablePostgresUser: true,
      },
      architecture: 'replication',
      replication: {
        applicationName: 'THECLUSTER',
      },
      audit: {
        logConnections: true,
      },
      tls: {
        // Maybe one day when I'm not an idiot
        enabled: false,
        autoGenerated: false,
      },
      primary: {
        priorityClassName: 'system-cluster-critical',
        service: {
          type: 'ClusterIP',
          // TODO: Probably pin this so its easier to pass around
          // clusterIP: '69.69.69.69',
        },
        persistence: {
          existingClaim: primaryPvc.metadata.name,
        },
      },
      readReplicas: {
        replicaCount: 3,
        priorityClassName: 'system-cluster-critical',
        service: {
          type: 'ClusterIP',
          // TODO: Probably pin this so its easier to pass around
          // clusterIP: '69.69.69.69',
        },
        persistence: {
          existingClaim: readReplicaPvc.metadata.name,
        },
      },
      serviceAccount: {
        create: true,
      },
      rbac: {
        create: true,
      },
      metrics: {
        enabled: true,
        image: {
          tag: versions.bitnami.postgresExporter,
        },
        service: {
          // TODO: Probably pin this so its easier to pass around
          // clusterIP: '69.69.69.69',
        },
        serviceMonitor: {
          // Soon
          enabled: false,
        },
        prometheusRule: {
          // Soon
          enabled: false,
        },
      },
    },
  },
}, { provider });

export const credentials = {
  admin: adminPassword.result,
  user: userPassword.result,
  replication: replicationPassword.result,
};
